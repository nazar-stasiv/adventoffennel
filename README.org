# -*- mode:org; org-export-use-babel:nil; org-export-babel-evaluate:nil -*-
#+TITLE: Advent of fennel
#+AUTHOR: Nazar Stasiv
#+EMAIL: nazar@autistici.org
#+DATE: 2024
#+LANGUAGE: en
#+OPTIONS: title:t author:t email:t toc:t num:nil timestamp:nil
#+PANDOC_OPTIONS: standalone:t pdf-engine:lualatex template:~/.pandoc/templates/eisvogel.tex
#+PANDOC_VARIABLES: papersize:a4 titlepage:t book:true toc:true toc-own-page:true toc-depth:1

* 2024 [4/9]
** DONE Day 1.1

The Chief  Historian is  always present for  the big  Christmas sleigh
launch, but nobody  has seen him in months! Last  anyone heard, he was
visiting  locations that  are  historically significant  to the  North
Pole; a group of Senior Historians  has asked you to accompany them as
they check the places they think he was most likely to visit.

As each location  is checked, they will  mark it on their  list with a
star. They  figure the  Chief Historian  must be in  one of  the first
fifty places they'll look, so in  order to save Christmas, you need to
help them  get fifty  stars on  their list before  Santa takes  off on
December 25th.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

You haven't  even left yet and  the group of Elvish  Senior Historians
has  already hit  a  problem:  their list  of  locations  to check  is
currently empty.  Eventually, someone decides  that the best  place to
check first would be the Chief Historian's office.

Upon  pouring  into  the  office, everyone  confirms  that  the  Chief
Historian is indeed  nowhere to be found. Instead,  the Elves discover
an  assortment   of  notes  and  lists   of  historically  significant
locations! This seems to be the planning the Chief Historian was doing
before he  left. Perhaps these  notes can  be used to  determine which
locations to search?

Throughout the Chief's office,  the historically significant locations
are listed  not by  name but  by a unique  number called  the location
ID. To make  sure they don't miss anything, The  Historians split into
two groups, each  searching the office and trying to  create their own
complete list of location IDs.

There's just  one problem: by  holding the two  lists up side  by side
(your puzzle  input), it quickly  becomes clear that the  lists aren't
very similar. Maybe you can help The Historians reconcile their lists?

For example:
#+begin_example
3   4
4   3
2   5
1   3
3   9
3   3
#+end_example

Maybe the lists are  only off by a small amount! To  find out, pair up
the numbers and  measure how far apart they are.  Pair up the smallest
number in  the left list with  the smallest number in  the right list,
then the  second-smallest left  number with the  second-smallest right
number, and so on.

Within each pair, figure out how far apart the two numbers are; you'll
need to add up all of those distances. For example, if you pair up a 3
from the left list with a 7 from the right list, the distance apart is
4; if you pair up a 9 with a 3, the distance apart is 6.

In the example list above, the pairs and distances would be as
follows:
- The smallest number in the left list is 1, and the smallest number
  in the right list is 3. The distance between them is 2.
- The second-smallest number in the left list is 2, and the
  second-smallest number in the right list is another 3. The distance
  between them is 1.
- The third-smallest number in both lists is 3, so the distance
  between them is 0.
- The next numbers to pair up are 3 and 4, a distance of 1.  
- The fifth-smallest numbers in each list are 3 and 5, a distance
  of 2.  
- Finally, the largest number in the left list is 4, while the largest
  number in the right list is 9; these are a distance 5 apart.
  
To find the  total distance between the left list  and the right list,
add  up the  distances between  all  of the  pairs you  found. In  the
example above, this is 2 + 1 + 0 + 1 + 2 + 5, a total distance of 11!

Your actual  left and right lists  contain many location IDs.  What is
the total distance between your lists?

#+begin_src fennel -n :session d2401 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["3   4"
        "4   3"
        "2   5"
        "1   3"
        "3   9"
        "3   3"])

(fn read-input [lines]
  (let [x []
        y []]
    (each [_ line (ipairs lines)]
      (let [xy (aoc.string-tonumarray line)]
        (table.insert x (. xy 1))
        (table.insert y (. xy 2))))
    (table.sort x)
    (table.sort y)
    [x y]))

(fn zip [[x y]]
  (aoc.table-zip x y))

(fn solve [input]
  (-> input
      (read-input)
      (zip)
      (lume.map #(math.abs (- (. $ 1) (. $ 2))))
      (aoc.table-sum)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 11 test-input)

(solve (aoc.string-from "2024/01.inp"))
#+end_src

#+RESULTS:
: 1765812

** DONE Day 1.2

Your analysis  only confirmed what  everyone feared: the two  lists of
location IDs are indeed very different.

Or are they?

The Historians can't agree on which  group made the mistakes or how to
read most of the Chief's handwriting,  but in the commotion you notice
an interesting  detail: a lot  of location  IDs appear in  both lists!
Maybe  the  other  numbers  aren't  location IDs  at  all  but  rather
misinterpreted handwriting.

This time,  you'll need to  figure out  exactly how often  each number
from  the left  list  appears in  the right  list.  Calculate a  total
similarity  score by  adding up  each number  in the  left list  after
multiplying it by the number of times that number appears in the right
list.

Here are the same example lists again:

#+begin_example
3   4
4   3
2   5
1   3
3   9
3   3
#+end_example

For these example lists, here is the process of finding the similarity
score:
- The first number in the left list is 3. It appears in the right list
  three times, so the similarity score increases by 3 * 3 = 9.
- The second number in the left list is 4. It appears in the right
  list once, so the similarity score increases by 4 * 1 = 4.
- The third number in the left list is 2. It does not appear in the
  right list, so the similarity score does not increase (2 * 0 = 0).
- The fourth number, 1, also does not appear in the right list.
- The fifth number, 3, appears in the right list three times; the
  similarity score increases by 9.
- The last number, 3, appears in the right list three times; the
  similarity score again increases by 9.

So, for these example lists, the similarity score at the end of this
process is 31 (9 + 4 + 0 + 0 + 9 + 9).

Once again consider your left and right lists. What is their
similarity score?

#+begin_src fennel -n :session d2401 :exports both
(fn solve2 [input]
  (let [[xs ys] (read-input input)
        zs (lume.map xs (fn [x] (length (lume.filter ys (fn [y] (= y x))))))
        res (aoc.table-zip xs zs)]
    (aoc.table-sum (lume.map res #(* (. $ 1) (. $ 2))))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 31 test-input)

(solve2 (aoc.string-from "2024/01.inp"))
#+end_src

#+RESULTS:
: 20520794

** DONE Day 2.1

Fortunately, the first location The Historians want to search isn't a
long walk from the Chief Historian's office.

While the  Red-Nosed Reindeer nuclear fusion/fission  plant appears to
contain no sign of the Chief  Historian, the engineers there run up to
you as  soon as they  see you. Apparently,  they still talk  about the
time  Rudolph was  saved  through molecular  synthesis  from a  single
electron.

They're quick to add that -  since you're already here - they'd really
appreciate your  help analyzing some  unusual data from  the Red-Nosed
reactor. You turn to check if  The Historians are waiting for you, but
they  seem to  have already  divided  into groups  that are  currently
searching every  corner of the  facility. You  offer to help  with the
unusual data.

The unusual  data (your  puzzle input) consists  of many  reports, one
report per line.  Each report is a list of  numbers called levels that
are separated by spaces. For example:

#+begin_example
7 6 4 2 1
1 2 7 8 9
9 7 6 2 1
1 3 2 4 5
8 6 4 4 1
1 3 6 7 9
#+end_example

This example data contains six reports each containing five levels.

The engineers  are trying to  figure out  which reports are  safe. The
Red-Nosed reactor  safety systems  can only  tolerate levels  that are
either gradually increasing or gradually decreasing. So, a report only
counts as safe if both of the following are true:
- The levels are either all increasing or all decreasing.
- Any two adjacent levels differ by at least one and at most three.

In the example above, the reports can be found safe or unsafe by
checking those rules:
- 7 6 4 2 1: Safe because the levels are all decreasing by 1 or 2.
- 1 2 7 8 9: Unsafe because 2 7 is an increase of 5.
- 9 7 6 2 1: Unsafe because 6 2 is a decrease of 4.
- 1 3 2 4 5: Unsafe because 1 3 is increasing but 3 2 is decreasing.
- 8 6 4 4 1: Unsafe because 4 4 is neither an increase or a decrease.
- 1 3 6 7 9: Safe because the levels are all increasing by 1, 2, or 3.

So, in this example, 2 reports are safe.

Analyze the unusual data from the engineers. How many reports are
safe?

#+begin_src fennel -n :session d2402 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["7 6 4 2 1"
        "1 2 7 8 9"
        "9 7 6 2 1"
        "1 3 2 4 5"
        "8 6 4 4 1"
        "1 3 6 7 9"])

(fn level-decrease [xs]
  (let [ys (aoc.partition1 xs)]
    (lume.all ys #(> (. $ 1) (. $ 2)))))

(fn level-increase [xs]
  (let [ys (aoc.partition1 xs)]
    (lume.all ys #(< (. $ 1) (. $ 2)))))

(fn level-gradual [xs]
  (or (level-decrease xs)
      (level-increase xs)))

(fn level-differ [xs]
  (let [ys (aoc.partition1 xs)]
    (lume.all ys #(<= 1 (math.abs (- (. $ 1) (. $ 2))) 3))))

(fn solve [input]
  (-> input
      (lume.map #(aoc.string-tonumarray $))
      (lume.filter #(level-gradual $))
      (lume.filter #(level-differ $))
      (length)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 2 test-input)

(solve (aoc.string-from "2024/02.inp"))
#+end_src

#+RESULTS:
: 598

** TODO Day 2.2                                                   :noexport:

The engineers  are surprised by the  low number of safe  reports until
they realize they forgot to tell you about the Problem Dampener.

The Problem Dampener is a reactor-mounted module that lets the reactor
safety systems tolerate a single bad  level in what would otherwise be
a safe report. It's like the bad level never happened!

Now, the same rules apply as before, except if removing a single level
from an unsafe report would make it safe, the report instead counts as
safe.

More of the above example's reports are now safe:
- 7 6 4 2 1: Safe without removing any level.
- 1 2 7 8 9: Unsafe regardless of which level is removed.
- 9 7 6 2 1: Unsafe regardless of which level is removed.
- 1 3 2 4 5: Safe by removing the second level, 3.
- 8 6 4 4 1: Safe by removing the third level, 4.
- 1 3 6 7 9: Safe without removing any level.

Thanks to the Problem Dampener, 4 reports are actually safe!

Update your analysis by handling situations where the Problem Dampener
can remove  a single level from  unsafe reports. How many  reports are
now safe?

** DONE Day 3.1

"Our computers  are having issues,  so I have no  idea if we  have any
Chief  Historians in  stock! You're  welcome to  check the  warehouse,
though,"  says  the mildly  flustered  shopkeeper  at the  North  Pole
Toboggan Rental Shop. The Historians head out to take a look.

The shopkeeper turns to you. "Any chance you can see why our computers
are having issues again?"

The computer  appears to be  trying to run  a program, but  its memory
(your puzzle  input) is corrupted.  All of the instructions  have been
jumbled up!

It  seems like  the  goal of  the  program is  just  to multiply  some
numbers. It does  that with instructions like mul(X,Y), where  X and Y
are each 1-3 digit numbers.  For instance, mul(44,46) multiplies 44 by
46 to get  a result of 2024. Similarly, mul(123,4)  would multiply 123
by 4.

However, because  the program's memory  has been corrupted,  there are
also many invalid characters that should be ignored, even if they look
like  part of  a  mul instruction.  Sequences  like mul(4*,  mul(6,9!,
?(12,34), or mul ( 2 , 4 ) do nothing.

For example, consider the following section of corrupted memory:
#+begin_example
xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))
#+end_example

Only the four  highlighted sections are real  mul instructions. Adding
up the  result of each  instruction produces 161 (2*4  + 5*5 +  11*8 +
8*5).

Scan the corrupted memory for uncorrupted mul instructions. What do
you get if you add up all of the results of the multiplications?

#+begin_src fennel -n :session d2403 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))"])

(fn match-expr [s expr]
  (icollect [e (string.gmatch s expr)] e))

(fn multiply [s]
  (let [[a b] (aoc.string-split s ",")]
    (* a b)))

(fn eval-expr [xs]
  (let [res []]
    (each [_ s (ipairs xs)]
      (case (aoc.string-split s "()")
        ["mul" ab] (table.insert res (multiply ab))
        _ (print (.. "No match for " s))))
    res))

(fn solve [input]
  (-> input
      (lume.map #(match-expr $ "mul%(%d*,%d*%)"))
      (lume.map #(eval-expr $))
      (aoc.table-sum)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 161 test-input)

(solve (aoc.string-from "2024/03.inp"))
#+end_src

#+RESULTS:
: 180233229

** TODO Day 3.2                                                   :noexport:

As you scan through the corrupted memory, you notice that some of the
conditional statements are also still intact. If you handle some of
the uncorrupted conditional statements in the program, you might be
able to get an even more accurate result.

There are two new instructions you'll need to handle:
- The do() instruction enables future mul instructions.
- The don't() instruction disables future mul instructions.

Only the most recent do() or don't() instruction applies. At the beginning of the program, mul instructions are enabled.

For example:
#+begin_example
xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))
#+end_example

This corrupted memory is similar to  the example from before, but this
time  the mul(5,5)  and  mul(11,8) instructions  are disabled  because
there is a don't() instruction before them. The other mul instructions
function normally, including  the one at the end  that gets re-enabled
by a do() instruction.

This time, the sum of the results is 48 (2*4 + 8*5).

Handle the new instructions; what do you  get if you add up all of the
results of just the enabled multiplications?

** TODO Day 4.1                                                   :noexport:

"Looks like the  Chief's not here. Next!" One of  The Historians pulls
out a device  and pushes the only  button on it. After  a brief flash,
you recognize the interior of the Ceres monitoring station!

As the search  for the Chief continues,  a small Elf who  lives on the
station tugs on your  shirt; she'd like to know if  you could help her
with her  word search (your  puzzle input). She  only has to  find one
word: XMAS.

This word  search allows words  to be horizontal,  vertical, diagonal,
written  backwards, or  even overlapping  other words.  It's a  little
unusual, though,  as you  don't merely  need to  find one  instance of
XMAS - you  need to find all of  them. Here are a few  ways XMAS might
appear, where irrelevant characters have been replaced with .:

#+begin_example
..X...
.SAMX.
.A..A.
XMAS.S
.X....
#+end_example

The actual word search will be full of letters instead. For example:

#+begin_example
MMMSXXMASM
MSAMXMSMSA
AMXSXMAAMM
MSAMASMSMX
XMASAMXAMM
XXAMMXXAMA
SMSMSASXSS
SAXAMASAAA
MAMMMXMMMM
MXMXAXMASX
#+end_example

In this word search, XMAS occurs a  total of 18 times; here's the same
word search  again, but where  letters not  involved in any  XMAS have
been replaced with .:

#+begin_example
....XXMAS.
.SAMXMS...
...S..A...
..A.A.MS.X
XMASAMX.MM
X.....XA.A
S.S.S.S.SS
.A.A.A.A.A
..M.M.M.MM
.X.X.XMASX
#+end_example

Take a look at the little Elf's  word search. How many times does XMAS
appear?

** TODO Day 5.1                                                   :noexport:

Satisfied  with  their  search  on Ceres,  the  squadron  of  scholars
suggests    subsequently   scanning    the   stationery    stacks   of
sub-basement 17.

The North Pole  printing department is busier than ever  this close to
Christmas,  and while  The Historians  continue their  search of  this
historically significant  facility, an  Elf operating a  very familiar
printer beckons you over.

The Elf must recognize you, because they waste no time explaining that
the   new   sleigh   launch   safety  manual   updates   won't   print
correctly. Failure to update the  safety manuals would be dire indeed,
so you offer your services.

Safety  protocols  clearly indicate  that  new  pages for  the  safety
manuals must  be printed in  a very  specific order. The  notation X|Y
means that if both page number X  and page number Y are to be produced
as part  of an  update, page number  X must be  printed at  some point
before page number Y.

The Elf  has for  you both the  page ordering rules  and the  pages to
produce  in each  update (your  puzzle  input), but  can't figure  out
whether each update has the pages in the right order.

For example:

#+begin_example
47|53
97|13
97|61
97|47
75|29
61|13
75|53
29|13
97|29
53|29
61|53
97|53
61|29
47|13
75|47
97|75
47|61
75|61
47|29
75|13
53|13

75,47,61,53,29
97,61,53,29,13
75,29,13
75,97,47,61,53
61,13,29
97,13,75,29,47
#+end_example

The first section specifies the page ordering rules, one per line. The
first rule, 47|53,  means that if an update includes  both page number
47 and  page number 53,  then page number 47  must be printed  at some
point  before page  number  53.  (47 doesn't  necessarily  need to  be
immediately before 53; other pages are allowed to be between them.)

The second section specifies the  page numbers of each update. Because
most safety manuals are different, the pages needed in the updates are
different too. The first update, 75,47,61,53,29, means that the update
consists of page numbers 75, 47, 61, 53, and 29.

To get  the printers going as  soon as possible, start  by identifying
which updates are already in the right order.

In  the above  example, the  first update  (75,47,61,53,29) is  in the
right order:
- 75 is correctly first because there are rules that put each other
  page after it: 75|47, 75|61, 75|53, and 75|29.
- 47 is correctly second because 75 must be before it (75|47) and
  every other page must be after it according to 47|61, 47|53, and
  47|29.
- 61 is correctly in the middle because 75 and 47 are before it (75|61
  and 47|61) and 53 and 29 are after it (61|53 and 61|29).
- 53 is correctly fourth because it is before page number 29 (53|29).
- 29 is the only page left and so is correctly last.
  
Because  the first  update does  not  include some  page numbers,  the
ordering rules involving those missing page numbers are ignored.

The second and  third updates are also in the  correct order according
to the  rules. Like the first  update, they also do  not include every
page number,  and so only  some of the  ordering rules apply  - within
each update, the ordering rules  that involve missing page numbers are
not used.

The fourth  update, 75,97,47,61,53,  is not in  the correct  order: it
would print 75 before 97, which violates the rule 97|75.

The fifth update, 61,13,29, is also not in the correct order, since it
breaks the rule 29|13.

The last  update, 97,13,75,29,47, is not  in the correct order  due to
breaking several rules.

For some reason, the Elves also need to know the middle page number of
each update being printed. Because you are currently only printing the
correctly-ordered  updates, you  will  need to  find  the middle  page
number of  each correctly-ordered  update. In  the above  example, the
correctly-ordered updates are:

#+begin_example
75,47,61,53,29
97,61,53,29,13
75,29,13
#+end_example

These have middle page numbers of  61, 53, and 29 respectively. Adding
these page numbers together gives 143.

Of course, you'll need to be careful: the actual list of page ordering
rules is bigger and more complicated than the above example.

Determine which updates are already in  the correct order. What do you
get if you add up the  middle page number from those correctly-ordered
updates?

** TODO Day 6.1                                                   :noexport:

The Historians  use their fancy device  again, this time to  whisk you
all away to the North Pole  prototype suit manufacturing lab... in the
year 1518! It  turns out that having direct access  to history is very
convenient for a group of historians.

You still  have to  be careful of  time paradoxes, and  so it  will be
important to  avoid anyone from  1518 while The Historians  search for
the Chief.  Unfortunately, a single  guard is patrolling this  part of
the lab.

Maybe you can work  out where the guard will go ahead  of time so that
The Historians can search safely?

You start  by making a map  (your puzzle input) of  the situation. For
example:

#+begin_example
....#.....
.........#
..........
..#.......
.......#..
..........
.#..^.....
........#.
#.........
......#...
#+end_example

The map  shows the current position  of the guard with  ^ (to indicate
the guard is currently facing up from the perspective of the map). Any
obstructions - crates, desks, alchemical reactors, etc. - are shown as
#.

Lab guards in 1518 follow a very strict patrol protocol which involves
repeatedly following these steps:
- If there is something directly in front of you, turn right 90 degrees.
- Otherwise, take a step forward.

Following the above  protocol, the guard moves up  several times until
she  reaches  an  obstacle  (in  this case,  a  pile  of  failed  suit
prototypes):

#+begin_example
....#.....
....^....#
..........
..#.......
.......#..
..........
.#........
........#.
#.........
......#...
#+end_example

Because there  is now  an obstacle  in front of  the guard,  she turns
right before continuing straight in her new facing direction:

#+begin_example
....#.....
........>#
..........
..#.......
.......#..
..........
.#........
........#.
#.........
......#...
#+end_example

Reaching another obstacle (a spool of several very long polymers), she
turns right again and continues downward:

#+begin_example
....#.....
.........#
..........
..#.......
.......#..
..........
.#......v.
........#.
#.........
......#...
#+end_example

This process  continues for a  while, but the guard  eventually leaves
the mapped area (after walking past a tank of universal solvent):

#+begin_example
....#.....
.........#
..........
..#.......
.......#..
..........
.#........
........#.
#.........
......#v..
#+end_example

By  predicting the  guard's route,  you can  determine which  specific
positions in the lab will be in the patrol path. Including the guard's
starting position, the  positions visited by the  guard before leaving
the area are marked with an X:

#+begin_example
....#.....
....XXXXX#
....X...X.
..#.X...X.
..XXXXX#X.
..X.X.X.X.
.#XXXXXXX.
.XXXXXXX#.
#XXXXXXX..
......#X..
#+end_example

In this  example, the guard will  visit 41 distinct positions  on your
map.

Predict the  path of the guard.  How many distinct positions  will the
guard visit before leaving the mapped area?

* 2023 [18/50]
** DONE Day 1.1
You  try to  ask  why they  can't  just use  a  weather machine  ("not
powerful enough") and  where they're even sending you  ("the sky") and
why your  map looks mostly blank  ("you sure ask a  lot of questions")
and hang on did  you just say the sky ("of course,  where do you think
snow comes from") when you realize  that the Elves are already loading
you into a trebuchet ("please hold still, we need to strap you in").

As  they're making  the final  adjustments, they  discover that  their
calibration document  (your puzzle input)  has been amended by  a very
young  Elf  who was  apparently  just  excited  to  show off  her  art
skills. Consequently, the Elves are  having trouble reading the values
on the document.

The  newly-improved calibration  document consists  of lines  of text;
each line originally  contained a specific calibration  value that the
Elves now need to recover. On  each line, the calibration value can be
found by combining the first digit  and the last digit (in that order)
to form a single two-digit number.

For example:
#+begin_example
1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet
#+end_example

In this example, the calibration values of these four lines are 12,
38, 15, and 77. Adding these together produces 142.

Consider your entire calibration document. What is the sum of all of
the calibration values?

#+begin_src fennel -n :session d2301 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [lines]
  (let [numbers []]
    (each [_ line (ipairs lines)]
      (let [fd (string.match line "[0-9]")
            ld (string.match (string.reverse line) "[0-9]")]
        (table.insert numbers (tonumber (.. fd ld)))))
    (aoc.fold numbers)))

(fn test1 [expected lines]
  (assert (= expected (solve lines))))

(test1 142 ["1abc2" "pqr3stu8vwx" "a1b2c3d4e5f" "treb7uchet"])

(solve (aoc.string-from "2023/01.inp"))
#+end_src

#+RESULTS:
: 56506

** DONE Day 1.2
Your calculation isn't  quite right. It looks like some  of the digits
are actually  spelled out with  letters: one, two, three,  four, five,
six, seven, eight, and nine also count as valid "digits".

Equipped with  this new  information, you  now need  to find  the real
first and last digit on each line. For example:
#+begin_example
two1nine
eightwothree
abcone2threexyz
xtwone3four
4nineeightseven2
zoneight234
7pqrstsixteen
#+end_example

In this  example, the calibration values  are 29, 83, 13,  24, 42, 14,
and 76. Adding these together produces 281.

What is the sum of all of the calibration values?

#+begin_src fennel -n :session d2301 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn starts-at-index [s idx pref]
  (= (string.sub s idx (- (+ idx (length pref)) 1)) pref))

(fn replace-by-index [line index]
  (let [new-line
        (if (starts-at-index line index "one")
            (string.gsub line "one" "o1e" 1)
            (starts-at-index line index "two")
            (string.gsub line "two" "t2o" 1)
            (starts-at-index line index "three")
            (string.gsub line "three" "th3ee" 1)
            (starts-at-index line index "four")
            (string.gsub line "four" "fo4r" 1)
            (starts-at-index line index "five")
            (string.gsub line "five" "fi5e" 1)
            (starts-at-index line index "six")
            (string.gsub line "six" "s6x" 1)
            (starts-at-index line index "seven")
            (string.gsub line "seven" "se7en" 1)
            (starts-at-index line index "eight")
            (string.gsub line "eight" "ei8ht" 1)
            (starts-at-index line index "nine")
            (string.gsub line "nine" "n9ne" 1)
            line)]
    (if (< (+ 1 index) (length new-line))
        (replace-by-index new-line (+ 1 index))
        new-line)))

(fn replace-literal-numbers [lines]
  (let [new-lines []]
    (each [_ line (ipairs lines)]
      (let [new-line (replace-by-index line 1)]
        (table.insert new-lines new-line)))
    new-lines))

(fn solve2 [input]
  (let [lines (replace-literal-numbers input)]
    (solve lines)))

(fn test2 [expected lines]
  (assert (= expected (solve2 lines))))

(test2 281
       ["two1nine"
        "eightwothree"
        "abcone2threexyz"
        "xtwone3four"
        "4nineeightseven2"
        "zoneight234"
        "7pqrstsixteen"])

(solve2 (aoc.string-from "2023/01.inp"))
#+end_src

#+RESULTS:
: 56017

** DONE Day 2.1

You're launched high into the  atmosphere! The apex of your trajectory
just barely  reaches the  surface of  a large  island floating  in the
sky. You gently land in a fluffy  pile of leaves. It's quite cold, but
you don't see much snow. An Elf runs over to greet you.

The Elf explains that you've arrived at Snow Island and apologizes for
the lack of snow. He'll be happy  to explain the situation, but it's a
bit of a walk, so you have  some time. They don't get many visitors up
here; would you like to play a game in the meantime?

As you walk,  the Elf shows you  a small bag and some  cubes which are
either red, green, or blue. Each time you play this game, he will hide
a secret number of cubes of each color in the bag, and your goal is to
figure out information about the number of cubes.

To get  information, once a  bag has been  loaded with cubes,  the Elf
will reach into the bag, grab a  handful of random cubes, show them to
you, and then put them back in the  bag. He'll do this a few times per
game.

You play several games and record the information from each game (your
puzzle input). Each game is listed with  its ID number (like the 11 in
Game 11:  ...) followed  by a semicolon-separated  list of  subsets of
cubes that were revealed from the bag (like 3 red, 5 green, 4 blue).

For example, the record of a few games might look like this:

#+begin_example
Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue
Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red
Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red
Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green
#+end_example

In game 1, three sets of cubes are revealed from the bag (and then put
back again). The first set is 3 blue cubes and 4 red cubes; the second
set is 1 red  cube, 2 green cubes, and 6 blue cubes;  the third set is
only 2 green cubes.

The Elf would first like to  know which games would have been possible
if the bag  contained only 12 red  cubes, 13 green cubes,  and 14 blue
cubes?

In the example  above, games 1, 2,  and 5 would have  been possible if
the bag had been loaded with that configuration. However, game 3 would
have been  impossible because at one  point the Elf showed  you 20 red
cubes  at once;  similarly, game  4  would also  have been  impossible
because the Elf  showed you 15 blue  cubes at once. If you  add up the
IDs of the games that would have been possible, you get 8.

Determine which  games would have  been possible  if the bag  had been
loaded with only 12 red cubes, 13 green cubes, and 14 blue cubes. What
is the sum of the IDs of those games?

#+begin_src fennel -n :session d2302 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn parse-take [take]
  {:r (tonumber (string.match take "([0-9]*) red"))
   :g (tonumber (string.match take "([0-9]*) green"))
   :b (tonumber (string.match take "([0-9]*) blue"))})

(fn read-game [game]
  {:id (tonumber (string.match game "Game ([0-9]*):"))
   :takes (lume.map (aoc.string-split game ";") parse-take)})

(fn possible-take? [take]
  (let [max-red 12
        red (or (. take :r) 0)
        max-green 13
        green (or (. take :g) 0)
        max-blue 14
        blue (or (. take :b) 0)]
    (not (or (> red max-red)
             (> green max-green)
             (> blue max-blue)))))

(fn possible-game? [game]
  (= nil (lume.find (lume.map (. game :takes) possible-take?) false)))
  
(fn sum-game-ids [games]
  (accumulate [sum 0 _ game (ipairs games)]
    (+ sum (. game :id))))

(fn solve [lines]
  (let [games []]
    (each [_ line (ipairs lines)]
      (let [game (read-game line)]
        (table.insert games game)))
    (sum-game-ids (lume.filter games possible-game?))))

(fn test1 [expected lines]
  (assert (= expected (solve lines))))

(local test-input
       ["Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green"
        "Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue"
        "Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red"
        "Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red"
        "Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green"])

(test1 8 test-input)

(solve (aoc.string-from "2023/02.inp"))
#+end_src

#+RESULTS:
: 2449

** DONE Day 2.2
The  Elf  says they've  stopped  producing  snow because  they  aren't
getting any  water! He isn't sure  why the water stopped;  however, he
can  show you  how to  get to  the water  source to  check it  out for
yourself. It's just up ahead!

As you  continue your walk, the  Elf poses a second  question: in each
game you played, what is the fewest number of cubes of each color that
could have been in the bag to make the game possible?

Again consider the example games from earlier:

#+begin_example
Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue
Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red
Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red
Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green
#+end_example

- In game 1, the game could have been played with as few as 4 red, 2
  green, and 6 blue cubes. If any color had even one fewer cube, the
  game would have been impossible.
- Game 2 could have been played with a minimum of 1 red, 3 green, and
  4 blue cubes.
- Game 3 must have been played with at least 20 red, 13 green, and 6
  blue cubes.
- Game 4 required at least 14 red, 3 green, and 15 blue cubes.
- Game 5 needed no fewer than 6 red, 3 green, and 2 blue cubes in the
  bag.
  
The power of a set of cubes is equal to the numbers of red, green, and
blue cubes multiplied together. The power  of the minimum set of cubes
in  game  1 is  48.  In  games  2-5 it  was  12,  1560, 630,  and  36,
respectively. Adding up these five powers produces the sum 2286.

For each game, find the minimum set of cubes that must have been
present. What is the sum of the power of these sets?

#+begin_src fennel -n :session d2302 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn find-max-red-take [game]
  (aoc.table-max
   (lume.map (. game :takes)
             (fn [take] (or (. take :r) 0)))))

(fn find-max-green-take [game]
  (aoc.table-max
   (lume.map (. game :takes)
             (fn [take] (or (. take :g) 0)))))

(fn find-max-blue-take [game]
  (aoc.table-max
   (lume.map (. game :takes)
             (fn [take] (or (. take :b) 0)))))

(fn find-game-power-cube [game]
  (*
   (find-max-red-take game)
   (find-max-green-take game)
   (find-max-blue-take game)))

(fn solve [lines]
  (let [power-cubes []]
    (each [_ line (ipairs lines)]
      (let [game (read-game line)]
        (table.insert power-cubes (find-game-power-cube game))))
    (aoc.table-sum power-cubes)))

(fn test2 [expected lines]
  (assert (= expected (solve lines))))

(test2 2286 test-input)

(solve (aoc.string-from "2023/02.inp"))
#+end_src

#+RESULTS:
: 63981

** TODO Day 3.1                                                   :noexport:

You and the  Elf eventually reach a gondola lift  station; he says the
gondola lift will take you up to  the water source, but this is as far
as he can bring you. You go inside.

It doesn't take long to find the gondolas, but there seems to be a
problem: they're not moving.

"Aaah!"

You turn around to see a slightly-greasy  Elf with a wrench and a look
of surprise. "Sorry, I wasn't expecting anyone! The gondola lift isn't
working right now;  it'll still be a  while before I can  fix it." You
offer to help.

The engineer explains that an engine part seems to be missing from the
engine, but nobody can figure out which one. If you can add up all the
part numbers  in the engine schematic,  it should be easy  to work out
which part is missing.

The  engine  schematic  (your  puzzle  input)  consists  of  a  visual
representation of  the engine. There  are lots of numbers  and symbols
you don't really  understand, but apparently any number  adjacent to a
symbol, even diagonally, is a "part  number" and should be included in
your sum. (Periods (.) do not count as a symbol.)

Here is an example engine schematic:
#+begin_example
467..114..
...*......
..35..633.
......#...
617*......
.....+.58.
..592.....
......755.
...$.*....
.664.598..
#+end_example

In this schematic,  two numbers are not part numbers  because they are
not adjacent to a symbol: 114 (top right) and 58 (middle right). Every
other number is  adjacent to a symbol  and so is a  part number; their
sum is 4361.

Of course, the actual engine schematic is much larger. What is the sum
of all of the part numbers in the engine schematic?
** TODO Day 3.2                                                   :noexport:

** DONE Day 4.1

The gondola takes  you up. Strangely, though, the  ground doesn't seem
to be coming  with you; you're not climbing a  mountain. As the circle
of  Snow Island  recedes below  you, an  entire new  landmass suddenly
appears above you!  The gondola carries you to the  surface of the new
island and lurches into the station.

As you exit  the gondola, the first  thing you notice is  that the air
here  is much  warmer than  it  was on  Snow Island.  It's also  quite
humid. Is this where the water source is?

The next thing  you notice is an  Elf sitting on the  floor across the
station in what seems to be a pile of colorful square cards.

"Oh! Hello!"  The Elf  excitedly runs over  to you. "How  may I  be of
service?" You ask about water sources.

"I'm not sure;  I just operate the gondola lift.  That does sound like
something we'd have, though - this  is Island Island, after all! I bet
the gardener would know. He's on  a different island, though - er, the
small kind surrounded by water, not  the floating kind. We really need
to come up with a better naming scheme. Tell you what: if you can help
me with something  quick, I'll let you  borrow my boat and  you can go
visit the  gardener. I  got all  these scratchcards as  a gift,  but I
can't figure out what I've won."

The  Elf leads  you over  to the  pile of  colorful cards.  There, you
discover  dozens  of  scratchcards,  all with  their  opaque  covering
already scratched off. Picking one up, it looks like each card has two
lists of  numbers separated by a  vertical bar (|): a  list of winning
numbers  and  then a  list  of  numbers  you  have. You  organize  the
information into a table (your puzzle input).

As far as the Elf has been able  to figure out, you have to figure out
which  of  the  numbers  you  have  appear  in  the  list  of  winning
numbers. The first match makes the card worth one point and each match
after the first doubles the point value of that card.

For example:

#+begin_example
Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53
Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19
Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1
Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83
Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36
Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11
#+end_example

In the above example, card 1 has five winning numbers (41, 48, 83, 86,
and 17)  and eight numbers  you have  (83, 86, 6,  31, 17, 9,  48, and
53). Of the  numbers you have, four  of them (48, 83, 17,  and 86) are
winning numbers! That means card 1 is  worth 8 points (1 for the first
match, then  doubled three times for  each of the three  matches after
the first).
- Card 2 has two winning numbers (32 and 61), so it is worth 2 points.
- Card 3 has two winning numbers (1 and 21), so it is worth 2 points.
- Card 4 has one winning number (84), so it is worth 1 point.
- Card 5 has no winning numbers, so it is worth no points.
- Card 6 has no winning numbers, so it is worth no points.

So,  in this  example,  the Elf's  pile of  scratchcards  is worth  13
points. Take  a seat  in the  large pile of  colorful cards.  How many
points are they worth in total?

#+begin_src fennel -n :session d2304 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-game [s]
  (let [id (tonumber (string.match s "Card *([0-9]*):"))
        lottery (aoc.string-split (string.match s ":([0-9 ]*)|") " ")
        ticket (aoc.string-split (string.match s "|([0-9 ]*)$") " ")]
    {:id id :lottery (lume.map lottery tonumber) :ticket (lume.map ticket tonumber)}))

(fn read-games [lines]
  (let [result []]
    (each [_ line (ipairs lines)]
      (let [game (read-game line)]
        (table.insert result game)))
    result))

(fn wins-to-points [n]
  (if (> n 0)
      (aoc.math-pow 2 (- n 1))
      0))

(fn count-points [games]
  (let [result []]
    (each [_ game (ipairs games)]
      (let [wins (aoc.table-intersect (. game :lottery) (. game :ticket))
            points (wins-to-points (length wins))]
        (table.insert result points)))
    result))

(fn solve [lines]
  (let [games (read-games lines)]
    (aoc.table-sum (count-points games))))

(fn test [expected input]
  (assert (= expected (solve input))))

(local test-input
       ["Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53"
        "Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19"
        "Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1"
        "Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83"
        "Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36"
        "Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11"])

(test 13 test-input)

(solve (aoc.string-from "2023/04.inp"))
#+end_src

#+RESULTS:
: 18653

** DONE Day 4.2

Just as you're  about to report your  findings to the Elf,  one of you
realizes that  the rules  have actually  been printed  on the  back of
every card this whole time.

There's no  such thing as  "points". Instead, scratchcards  only cause
you to  win more scratchcards equal  to the number of  winning numbers
you have.

Specifically, you  win copies  of the  scratchcards below  the winning
card equal  to the number of  matches. So, if  card 10 were to  have 5
matching numbers, you would win one copy each of cards 11, 12, 13, 14,
and 15.

Copies of  scratchcards are scored  like normal scratchcards  and have
the same card number as the card they copied. So, if you win a copy of
card 10 and it has 5 matching numbers, it would then win a copy of the
same  cards that  the original  card  10 won:  cards 11,  12, 13,  14,
and 15. This process repeats until none of the copies cause you to win
any more cards. (Cards will never make you copy a card past the end of
the table.)

This time, the above example goes differently:

#+begin_example
Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53
Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19
Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1
Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83
Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36
Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11
#+end_example

- Card 1 has four matching numbers, so you win one copy each of the
  next four cards: cards 2, 3, 4, and 5.
- Your original card 2 has two matching numbers, so you win one copy
  each of cards 3 and 4.
- Your copy of card 2 also wins one copy each of cards 3 and 4.
- Your four instances of card 3 (one original and three copies) have
  two matching numbers, so you win four copies each of cards 4 and 5.
- Your eight instances of card 4 (one original and seven copies) have
  one matching number, so you win eight copies of card 5.
- Your fourteen instances of card 5 (one original and thirteen copies)
  have no matching numbers and win no more cards.
- Your one instance of card 6 (one original) has no matching numbers
  and wins no more cards.

Once all of  the originals and copies have been  processed, you end up
with 1 instance of card 1, 2  instances of card 2, 4 instances of card
3, 8 instances  of card 4, 14  instances of card 5, and  1 instance of
card 6.  In total,  this example  pile of  scratchcards causes  you to
ultimately have 30 scratchcards!

Process  all of  the original  and copied  scratchcards until  no more
scratchcards are won. Including the  original set of scratchcards, how
many total scratchcards do you end up with?

#+begin_src fennel -n :session d2304 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn table.increment [t i v]
  (let [o (. t i)]
    (table.remove t i)
    (table.insert t i (+ o v)))
  t)

(fn collect-cards [games]
  (let [result []]
    (each [_ game (ipairs games)]
      (let [count (length (aoc.table-intersect (. game :lottery) (. game :ticket)))
            id (. game :id)
            cards []]
        (when (< 0 count)
          (fcollect [i (+ id 1) (+ count id) 1]
            (table.insert cards i)))
        (tset result id cards)))
    result))

(fn count-cards [games]
  (let [cards (collect-cards games)
        result (fcollect [i 1 (length cards) 1] 1)]
    (each [i v (ipairs cards)]
      (each [j w (ipairs v)]
        (table.increment result w (. result i))))
    result))

(fn solve2 [input]
  (let [games (read-games input)]
    (aoc.table-sum (count-cards games))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 30 test-input)

(solve2 (aoc.string-from "2023/04.inp"))
#+end_src

#+RESULTS:
: 5921508

** DONE Day 5.1

You take the boat  and find the gardener right where  you were told he
would be:  managing a  giant "garden"  that looks more  to you  like a
farm.

"A water  source? Island Island  is the  water source!" You  point out
that Snow Island isn't receiving any water.

"Oh, we had to stop the water because  we ran out of sand to filter it
with! Can't  make snow with dirty  water. Don't worry, I'm  sure we'll
get  more   sand  soon;   we  only   turned  off   the  water   a  few
days...  weeks... oh  no." His  face sinks  into a  look of  horrified
realization.

"I've  been  so  busy  making  sure everyone  here  has  food  that  I
completely forgot to check why we stopped getting more sand! There's a
ferry leaving soon  that is headed over in that  direction - it's much
faster than your boat. Could you please go check it out?"

You  barely have  time to  agree  to this  request when  he brings  up
another. "While you wait for the ferry, maybe you can help us with our
food production problem. The latest Island Island Almanac just arrived
and we're having trouble making sense of it."

The almanac (your puzzle input) lists all of the seeds that need to be
planted. It  also lists  what type of  soil to use  with each  kind of
seed, what type of fertilizer to use with each kind of soil, what type
of water to use with each kind of fertilizer, and so on. Every type of
seed, soil,  fertilizer and  so on  is identified  with a  number, but
numbers are reused by each category - that is, soil 123 and fertilizer
123 aren't necessarily related to each other.

For example:

#+begin_example
seeds: 79 14 55 13

seed-to-soil map:
50 98 2
52 50 48

soil-to-fertilizer map:
0 15 37
37 52 2
39 0 15

fertilizer-to-water map:
49 53 8
0 11 42
42 0 7
57 7 4

water-to-light map:
88 18 7
18 25 70

light-to-temperature map:
45 77 23
81 45 19
68 64 13

temperature-to-humidity map:
0 69 1
1 0 69

humidity-to-location map:
60 56 37
56 93 4
#+end_example

The almanac starts by listing which seeds need to be planted: seeds
79, 14, 55, and 13.

The rest of the almanac contains a  list of maps which describe how to
convert numbers from  a source category into numbers  in a destination
category.  That is,  the section  that starts  with seed-to-soil  map:
describes how to  convert a seed number (the source)  to a soil number
(the destination). This lets the gardener and his team know which soil
to use with which seeds, which water to use with which fertilizer, and
so on.

Rather than list every source number and its corresponding destination
number one by one, the maps describe entire ranges of numbers that can
be  converted. Each  line within  a  map contains  three numbers:  the
destination range start, the source range start, and the range length.

Consider again the example seed-to-soil map:

#+begin_example
50 98 2
52 50 48
#+end_example

The first  line has a  destination range start  of 50, a  source range
start of 98, and a range length  of 2. This line means that the source
range starts at 98 and contains two values: 98 and 99. The destination
range is the same  length, but it starts at 50, so  its two values are
50  and 51.  With  this  information, you  know  that  seed number  98
corresponds to soil  number 50 and that seed number  99 corresponds to
soil number 51.

The second line means that the  source range starts at 50 and contains
48 values:  50, 51,  ..., 96,  97. This  corresponds to  a destination
range  starting at  52 and  also containing  48 values:  52, 53,  ...,
98, 99. So, seed number 53 corresponds to soil number 55.

Any  source  numbers  that  aren't   mapped  correspond  to  the  same
destination number. So, seed number 10 corresponds to soil number 10.

So,  the entire  list of  seed  numbers and  their corresponding  soil
numbers looks like this:

#+begin_example
seed  soil
0     0
1     1
...   ...
48    48
49    49
50    52
51    53
...   ...
96    98
97    99
98    50
99    51
#+end_example

With  this map,  you can  look up  the soil  number required  for each
initial seed number:

- Seed number 79 corresponds to soil number 81.
- Seed number 14 corresponds to soil number 14.
- Seed number 55 corresponds to soil number 57.
- Seed number 13 corresponds to soil number 13.

The gardener and his team want to  get started as soon as possible, so
they'd like  to know  the closest  location that  needs a  seed. Using
these maps, find the lowest location number that corresponds to any of
the initial seeds. To do this, you'll need to convert each seed number
through other categories until you can find its corresponding location
number. In this example, the corresponding types are:

- Seed 79, soil 81, fertilizer 81, water 81, light 74, temperature 78,
  humidity 78, location 82.
- Seed 14, soil 14, fertilizer 53, water 49, light 42, temperature 42,
  humidity 43, location 43.
- Seed 55, soil 57, fertilizer 57, water 53, light 46, temperature 82,
  humidity 82, location 86.
- Seed 13, soil 13, fertilizer 52, water 41, light 34, temperature 34,
  humidity 35, location 35.

So, the lowest location number in this example is 35.

What is  the lowest  location number  that corresponds  to any  of the
initial seed numbers?

#+begin_src fennel -n :session d2305 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn vec2tree2 [node t ?f]
  (let [len (length t)]
    (if (= 0 len) nil
        (= 1 len) (tset node :val (. t 1))
        (do
          (table.sort t ?f)
          (let [mid (math.ceil (/ len 2))
                left (aoc.table-range t 1 (- mid 1))
                right (aoc.table-range t (+ mid 1) len)]
            (tset node :val (. t mid))
            (when (not (aoc.empty? left)) (tset node :left (vec2tree2 {} left ?f)))
            (when (not (aoc.empty? right)) (tset node :right (vec2tree2 {} right ?f))))))
    node))

(fn comp [a b]
  (< (. a 2) (. b 2)))

(local seed2soil
       (vec2tree2 {}
                  [[50 98 2]
                   [52 50 48]]
                  comp))

(local soil2fertilizer
       (vec2tree2 {}
                  [[0 15 37]
                   [37 52 2]
                   [39 0 15]]
                  comp))

(local fertilizer2water
       (vec2tree2 {}
                  [[49 53 8]
                   [0 11 42]
                   [42 0 7]
                   [57 7 4]]
                  comp))


(local water2light
       (vec2tree2 {}
                  [[88 18 7]
                   [18 25 70]]
                  comp))

(local light2temperature
       (vec2tree2 {}
                  [[45 77 23]
                   [81 45 19]
                   [68 64 13]]
                  comp))

(local temperature2humidity
       (vec2tree2 {}
                  [[0 69 1]
                   [1 0 69]]
                  comp))

(local humidity2location
       (vec2tree2 {}
                  [[60 56 37]
                   [56 93 4]]
                  comp))

(local test-seeds
       [79 14 55 13])

(fn search-in-range [node v]
  (if node
      (let [from (. (. node :val) 2)
            to (- (+ from (. (. node :val) 3)) 1)]
        (if (< v from) (search-in-range (. node :left) v)
            (> v to) (search-in-range (. node :right) v)
            (and (<= from v) (<= v to)) (+ (- v from) (. (. node :val) 1))))
      v))

(fn seed2soil2fert2water2light2temp2hum2loc [x t1 t2 t3 t4 t5 t6 t7]
  (->> x
       (search-in-range t1)
       (search-in-range t2)
       (search-in-range t3)
       (search-in-range t4)
       (search-in-range t5)
       (search-in-range t6)
       (search-in-range t7)))

(fn test1 [xs t1 t2 t3 t4 t5 t6 t7]
  (let [locations []]
    (each [_ seed (ipairs xs)]
      (let [location (seed2soil2fert2water2light2temp2hum2loc seed t1 t2 t3 t4 t5 t6 t7)]
        (table.insert locations location)))
    (assert (= 35 (aoc.table-min locations)))))

(test1 test-seeds seed2soil soil2fertilizer fertilizer2water water2light light2temperature temperature2humidity humidity2location)

(fn solve [xs]
  (let [locations []
        seeds (aoc.table-unpack (lume.map (aoc.table-range xs 1 1) #(aoc.string-tonumarray $)))
        t1 (vec2tree2 {} (lume.map (aoc.table-range xs 4 27) #(aoc.string-tonumarray $))  comp)
        t2 (vec2tree2 {} (lume.map (aoc.table-range xs 30 60) #(aoc.string-tonumarray $)) comp)
        t3 (vec2tree2 {} (lume.map (aoc.table-range xs 63 72) #(aoc.string-tonumarray $)) comp)
        t4 (vec2tree2 {} (lume.map (aoc.table-range xs 75 101) #(aoc.string-tonumarray $)) comp)
        t5 (vec2tree2 {} (lume.map (aoc.table-range xs 104 114) #(aoc.string-tonumarray $)) comp)
        t6 (vec2tree2 {} (lume.map (aoc.table-range xs 117 129) #(aoc.string-tonumarray $)) comp)
        t7 (vec2tree2 {} (lume.map (aoc.table-range xs 132 139) #(aoc.string-tonumarray $)) comp)]
    (each [_ seed (ipairs seeds)]
      (table.insert locations (seed2soil2fert2water2light2temp2hum2loc seed t1 t2 t3 t4 t5 t6 t7)))
    (aoc.table-min locations)))

(solve (aoc.string-from "2023/05.inp"))
#+end_src

#+RESULTS:
: 1181555926

** TODO Day 5.2                                                   :noexport:

Everyone  will  starve if  you  only  plant  such  a small  number  of
seeds. Re-reading the almanac, it  looks like the seeds: line actually
describes ranges of seed numbers.

The values on the initial seeds: line come in pairs. Within each pair,
the first value is the start of  the range and the second value is the
length of the range. So, in the first line of the example above:

seeds: 79 14 55 13

This line  describes two ranges of  seed numbers to be  planted in the
garden. The  first range starts  with seed  number 79 and  contains 14
values: 79, 80, ..., 91, 92.  The second range starts with seed number
55 and contains 13 values: 55, 56, ..., 66, 67.

Now, rather than considering four seed numbers, you need to consider a
total of 27 seed numbers.

In the above example, the lowest  location number can be obtained from
seed number 82, which corresponds to soil 84, fertilizer 84, water 84,
light 77, temperature 45, humidity 46, and location 46. So, the lowest
location number is 46.

Consider all of  the initial seed numbers listed in  the ranges on the
first line  of the almanac.  What is  the lowest location  number that
corresponds to any of the initial seed numbers?
** DONE Day 6.1

The  ferry  quickly brings  you  across  Island Island.  After  asking
around, you  discover that there  is indeed  normally a large  pile of
sand somewhere near  here, but you don't see anything  besides lots of
water and the small island where the ferry has docked.

As you  try to figure out  what to do next,  you notice a poster  on a
wall near the ferry dock. "Boat races! Open to the public! Grand prize
is an all-expenses-paid trip to Desert Island!" That must be where the
sand comes from!  Best of all, the  boat races are starting  in just a
few minutes.

You  manage to  sign up  as a  competitor in  the boat  races just  in
time. The organizer explains that it's not really a traditional race -
instead, you  will get a fixed  amount of time during  which your boat
has to  travel as far  as it can,  and you win  if your boat  goes the
farthest.

As part of  signing up, you get  a sheet of paper  (your puzzle input)
that lists the  time allowed for each race and  also the best distance
ever recorded in that race. To  guarantee you win the grand prize, you
need to make sure you go farther  in each race than the current record
holder.

The organizer  brings you over  to the area  where the boat  races are
held. The boats are much smaller  than you expected - they're actually
toy boats,  each with  a big  button on top.  Holding down  the button
charges  the  boat,  and  releasing  the button  allows  the  boat  to
move. Boats  move faster  if their  button was  held longer,  but time
spent holding the  button counts against the total race  time. You can
only hold the  button at the start  of the race, and  boats don't move
until the button is released.

For example:

#+begin_example
Time:      7  15   30
Distance:  9  40  200
#+end_example

This document describes three races:
- The first race lasts 7 milliseconds. The record distance in this
  race is 9 millimeters.
- The second race lasts 15 milliseconds. The record distance in this
  race is 40 millimeters.
- The third race lasts 30 milliseconds. The record distance in this
  race is 200 millimeters.
  
Your  toy  boat   has  a  starting  speed  of   zero  millimeters  per
millisecond. For each whole millisecond  you spend at the beginning of
the race  holding down the button,  the boat's speed increases  by one
millimeter per millisecond.

So, because the first race lasts 7 milliseconds, you only have a few
options:
- Don't hold the  button at all (that is, hold  it for 0 milliseconds)
  at the start of the race. The boat won't move; it will have traveled
  0 millimeters by the end of the race.
- Hold the  button for 1 millisecond  at the start of  the race. Then,
  the boat will travel at a  speed of 1 millimeter per millisecond for
  6 milliseconds, reaching a total distance traveled of 6 millimeters.
- Hold the  button for 2  milliseconds, giving the  boat a speed  of 2
  millimeters per  millisecond.  It  will then  get 5  milliseconds to
  move, reaching a total distance of 10 millimeters.
- Hold  the  button   for  3  milliseconds.  After   its  remaining  4
  milliseconds of travel time, the boat will have gone 12 millimeters.
- Hold  the  button   for  4  milliseconds.  After   its  remaining  3
  milliseconds of travel time, the boat will have gone 12 millimeters.
- Hold the  button for 5  milliseconds, causing  the boat to  travel a
  total of 10 millimeters.
- Hold the  button for 6  milliseconds, causing  the boat to  travel a
  total of 6 millimeters.
- Hold the  button for 7  milliseconds. That's the entire  duration of
  the race. You never let go of  the button. The boat can't move until
  you let you of the button. Please make sure you let go of the button
  so the boat gets to move. 0 millimeters.
  
Since the  current record for  this race  is 9 millimeters,  there are
actually 4 different ways you could win: you could hold the button for
2, 3, 4, or 5 milliseconds at the start of the race.

In  the  second  race, you  could  hold  the  button  for at  least  4
milliseconds and at most 11 milliseconds  and beat the record, a total
of 8 different ways to win.

In  the  third  race, you  could  hold  the  button  for at  least  11
milliseconds  and no  more than  19  milliseconds and  still beat  the
record, a total of 9 ways you could win.

To see how much margin of error you have, determine the number of ways
you can beat the record in each race; in this example, if you multiply
these values together, you get 288 (4 * 8 * 9).

Determine  the number  of  ways  you could  beat  the  record in  each
race. What do you get if you multiply these numbers together?

#+begin_src fennel -n :session d2306 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn time2distance [time speed]
  (* time speed))

(fn race2distance [time]
  (fcollect [charge 0 time 1]
    (time2distance (- time charge) charge)))

(fn find-wins [input]
  (let [result []]
    (each [_ [time record] (ipairs input)]
      (table.insert result
                    (lume.reduce
                     (race2distance time)
                     (fn [acc x] (if (> x record) (+ acc 1) acc)))))
    result))

(fn count-wins [wins]
  (accumulate [prod 1
               _ win (ipairs wins)]
    (* prod win)))

(fn lines-to-array [lines]
  [(lume.map (aoc.string-split (. lines 1) " ") #(tonumber $))
   (lume.map (aoc.string-split (. lines 2) " ") #(tonumber $))])

(fn solve [lines]
  (let [[i1 i2] (lines-to-array lines)
        input (aoc.table-zip i1 i2)]
    (count-wins (find-wins input))))

(local test-input
       ["Time:      7  15   30"
        "Distance:  9  40  200"])

(fn test1 [expected input]
  (assert (= expected (solve input))))

(test1 288 test-input)

(solve (aoc.string-from "2023/06.inp"))
#+end_src

#+RESULTS:
: 4811940

** DONE Day 6.2

As the  race is about  to start, you realize  the piece of  paper with
race times and record distances you got earlier actually just has very
bad kerning. There's really only one  race - ignore the spaces between
the numbers on each line.

So, the example from before:

#+begin_example
Time:      7  15   30
Distance:  9  40  200
#+end_example

...now instead means this:

#+begin_example
Time:      71530
Distance:  940200
#+end_example

Now, you have to figure out how many ways there are to win this single
race. In this  example, the race lasts for 71530  milliseconds and the
record distance you need to beat is 940200 millimeters. You could hold
the button anywhere from 14 to 71516 milliseconds and beat the record,
a total of 71503 ways!

How many ways can you beat the record in this one much longer race?

#+begin_src fennel -n :session d2306 :exports both
(fn lines-to-string [lines]
  (let [time (string.gsub (string.gsub (. lines 1) " *" "") "Time:" "")
        distance (string.gsub (string.gsub (. lines 2) " *" "") "Distance:" "")]
    [(tonumber time)
     (tonumber distance)]))

(fn solve2 [lines]
  (let [input [(lines-to-string lines)]]
    (count-wins (find-wins input))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 71503 test-input)

(solve2 (aoc.string-from "2023/06.inp"))
#+end_src

#+RESULTS:
: 30077773

** DONE Day 7.1

Your all-expenses-paid  trip turns  out to  be a  one-way, five-minute
ride in an airship.  (At least it's a cool airship!)  It drops you off
at the edge of a vast desert and descends back to Island Island.

"Did you bring the parts?"

You turn  around to see an  Elf completely covered in  white clothing,
wearing goggles, and riding a large camel.

"Did you  bring the parts?"   she asks  again, louder this  time.  You
aren't sure  what parts she's looking  for; you're here to  figure out
why the sand stopped.

"The parts!  For the sand,  yes! Come with me;  I will show  you." She
beckons you onto the camel.

After riding a bit across the sands of Desert Island, you can see what
look  like very  large rocks  covering half  of the  horizon. The  Elf
explains that the  rocks are all along the part  of Desert Island that
is  directly  above  Island  Island,   making  it  hard  to  even  get
there. Normally,  they use big machines  to move the rocks  and filter
the  sand, but  the machines  have broken  down because  Desert Island
recently stopped receiving the parts they need to fix the machines.

You've already assumed  it'll be your job to figure  out why the parts
stopped when she asks if you can help. You agree automatically.

Because the journey will take a few  days, she offers to teach you the
game of  Camel Cards. Camel Cards  is sort of similar  to poker except
it's designed to be easier to play while riding a camel.

In Camel  Cards, you get a  list of hands,  and your goal is  to order
them based on the strength of each hand. A hand consists of five cards
labeled one of A, K, Q, J, T, 9,  8, 7, 6, 5, 4, 3, or 2. The relative
strength of each card follows this order, where A is the highest and 2
is the lowest.

Every hand is exactly one type. From strongest to weakest, they are:
- Five of a kind, where all five cards have the same label: AAAAA
- Four of a kind, where four cards have the same label and one card
  has a different label: AA8AA
- Full house, where three cards have the same label, and the remaining
  two cards share a different label: 23332
- Three of a kind, where three cards have the same label, and the
  remaining two cards are each different from any other card in the
  hand: TTT98
- Two pair, where two cards share one label, two other cards share a
  second label, and the remaining card has a third label: 23432
- One pair, where two cards share one label, and the other three cards
  have a different label from the pair and each other: A23A4
- High card, where all cards' labels are distinct: 23456

Hands are  primarily ordered  based on type;  for example,  every full
house is stronger than any three of a kind.

If  two  hands have  the  same  type,  a  second ordering  rule  takes
effect. Start by comparing the first card in each hand. If these cards
are different,  the hand  with the stronger  first card  is considered
stronger. If the first card in each hand have the same label, however,
then move  on to  considering the  second card in  each hand.  If they
differ, the hand with the higher second card wins; otherwise, continue
with the third card in each hand, then the fourth, then the fifth.

So,  33332 and  2AAAA are  both four  of a  kind hands,  but 33332  is
stronger  because its  first card  is stronger.  Similarly, 77888  and
77788 are both  a full house, but 77888 is  stronger because its third
card is stronger (and both hands have the same first and second card).

To  play  Camel  Cards, you  are  given  a  list  of hands  and  their
corresponding bid (your puzzle input). For example:

#+begin_example
32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483
#+end_example

This  example shows  five  hands; each  hand is  followed  by its  bid
amount. Each  hand wins an amount  equal to its bid  multiplied by its
rank, where the weakest hand gets rank 1, the second-weakest hand gets
rank 2,  and so on  up to the strongest  hand. Because there  are five
hands in this example, the strongest hand will have rank 5 and its bid
will be multiplied by 5.

So, the first step is to put the hands in order of strength:
- 32T3K is the only one pair and the other hands are all a stronger
  type, so it gets rank 1.
- KK677 and KTJJT are both two pair. Their first cards both have the
  same label, but the second card of KK677 is stronger (K vs T), so
  KTJJT gets rank 2 and KK677 gets rank 3.
- T55J5 and QQQJA are both three of a kind. QQQJA has a stronger first
  card, so it gets rank 5 and T55J5 gets rank 4.
  
Now, you  can determine  the total  winnings of this  set of  hands by
adding up  the result  of multiplying  each hand's  bid with  its rank
(765 *  1 +  220 * 2  + 28 *  3 +  684 * 4  + 483 *  5). So  the total
winnings in this example are 6440.

Find the rank of every hand in your set. What are the total winnings?

#+begin_src fennel -n :session d2307 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn all-wins [hands]
  (accumulate [sum 0 rank hand (ipairs hands)]
    (+ sum (* rank (. hand :bid)))))

(fn hand2type [hand]
  (case (aoc.string-toarray hand)
    ;; five of a kind
    [a a a a a] :t7
    ;; four of a kind
    [a b b b b] :t6
    [b a b b b] :t6
    [b b a b b] :t6
    [b b b a b] :t6
    [b b b b a] :t6
    ;; full house
    [a a a b b] :t5
    [a a b a b] :t5
    [a b a a b] :t5
    [b a a a b] :t5
    [b a a b a] :t5
    [b a b a a] :t5
    [b b a a a] :t5
    [a b b a a] :t5
    [a a b b a] :t5
    [a b a b a] :t5
    ;; three of a kind
    [b c a a a] :t4
    [b a c a a] :t4
    [b a a c a] :t4
    [b a a a c] :t4
    [a b a a c] :t4
    [a a b a c] :t4
    [a a a b c] :t4
    [a b c a a] :t4
    [a a b c a] :t4
    [a b a c a] :t4
    ;; two pairs
    [a a b b c] :t3
    [a a b c b] :t3
    [a a c b b] :t3
    [a c a b b] :t3
    [c a a b b] :t3
    [a b a b c] :t3
    [a b a c b] :t3
    [a b c a b] :t3
    [a c b a b] :t3
    [c a b a b] :t3
    [a b b a c] :t3
    [a b b c a] :t3
    [a b c b a] :t3
    [a c b b a] :t3
    [c a b b a] :t3
    ;; one pair
    [a a b c d] :t2
    [a b a c d] :t2
    [a b c a d] :t2
    [a b c d a] :t2
    [b a c d a] :t2
    [b c a d a] :t2
    [b c d a a] :t2
    [b a a c d] :t2
    [b c a a d] :t2
    [b a c a d] :t2
    ;; high card
    [a b c d e] :t1))

(fn hand2number [hand]
  (accumulate [sum 0 i x (ipairs (aoc.table-reverse (aoc.string-toarray hand)))]
    (+ sum (* (^ 100 (- i 1))
              (case x
                "A" 14
                "K" 13
                "Q" 12
                "J" 11
                "T" 10
                "9" 9
                "8" 8
                "7" 7
                "6" 6
                "5" 5
                "4" 4
                "3" 3
                "2" 2)))))

(fn test-hand2number []
  (assert (= 1212121114 (hand2number "QQQJA")))
  (assert (= 1414141414 (hand2number "AAAAA")))
  (assert (= 202020202 (hand2number "22222")))
  (assert (= 1313060707 (hand2number "KK677")))
  (assert (= 1310111110 (hand2number "KTJJT"))))

(test-hand2number)

(fn numeric-comp [a b]
  (let [an (hand2number (. a :hand))
        bn (hand2number (. b :hand))]
    (< an bn)))

(fn test-numeric-comp []
  (assert (numeric-comp {:hand "QQQJA"} {:hand "AAAAA"}))
  (assert (not (numeric-comp {:hand "AAAAA"} {:hand "QQQJA"})))
  (assert (numeric-comp {:hand "22222"} {:hand "QQQJA"}))
  (assert (not (numeric-comp {:hand "QQQJA"} {:hand "22222"})))
  (assert (not (numeric-comp {:hand "KK677"} {:hand "KTJJT"}))))

(test-numeric-comp)

(fn table.join [xs ys]
  (table.sort ys numeric-comp)
  (table.move ys 1 (length ys) (+ 1 (length xs)) xs))

(fn all-hands [lines]
  (let [t7 [] t6 [] t5 [] t4 [] t3 [] t2 [] t1 [] allhands []]
    (each [_ line (ipairs lines)]
      (let [[hand bid] (aoc.string-split line " ")]
        (case (hand2type hand)
          "t7" (table.insert t7 {:hand hand :bid (tonumber bid)})
          "t6" (table.insert t6 {:hand hand :bid (tonumber bid)})
          "t5" (table.insert t5 {:hand hand :bid (tonumber bid)})
          "t4" (table.insert t4 {:hand hand :bid (tonumber bid)})
          "t3" (table.insert t3 {:hand hand :bid (tonumber bid)})
          "t2" (table.insert t2 {:hand hand :bid (tonumber bid)})
          "t1" (table.insert t1 {:hand hand :bid (tonumber bid)}))))
    (table.join allhands t1)
    (table.join allhands t2)
    (table.join allhands t3)
    (table.join allhands t4)
    (table.join allhands t5)
    (table.join allhands t6)
    (table.join allhands t7)
    allhands))

(fn solve [lines]
  (let [hands (all-hands lines)]
    (all-wins hands)))

(fn test1 [expected lines]
  (assert (= expected (solve lines))))

(test1 6440
       ["32T3K 765" 
        "T55J5 684"
        "KK677 28"
        "KTJJT 220"
        "QQQJA 483"])

(test1 201
       ["AAATK 1"
        "TTTAA 100"])

(test1 10
       ["23456 1"
        "AAAKK 3"
        "AAAAA 1"])

(test1 6592
       ["2345A 1"
        "Q2KJJ 13"
        "Q2Q2Q 19"
        "T3T3J 17"
        "T3Q33 11"
        "2345J 3"
        "J345A 2"
        "32T3K 5"
        "T55J5 29"
        "KK677 7"
        "KTJJT 34"
        "QQQJA 31"
        "JJJJJ 37"
        "JAAAA 43"
        "AAAAJ 59"
        "AAAAA 61"
        "2AAAA 23"
        "2JJJJ 53"
        "JJJJ2 41"])

(solve (aoc.string-from "2023/07.inp"))
#+end_src

#+RESULTS:
: 251545216

** TODO Day 7.2                                                   :noexport:

To  make things  a little  more  interesting, the  Elf introduces  one
additional rule. Now, J cards are jokers - wildcards that can act like
whatever card would make the hand the strongest type possible.

To balance this, J cards are  now the weakest individual cards, weaker
even than 2. The other cards stay in the same order: A, K, Q, T, 9, 8,
7, 6, 5, 4, 3, 2, J.

J cards  can pretend to  be whatever card is  best for the  purpose of
determining hand type; for example, QJJQ2  is now considered four of a
kind. However, for  the purpose of breaking ties between  two hands of
the same type, J is always treated  as J, not the card it's pretending
to be: JKKK2 is weaker than QQQQ2 because J is weaker than Q.

Now, the above example goes very differently:

#+begin_example
32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483
#+end_example

- 32T3K is still the only one pair; it doesn't contain any jokers, so
  its strength doesn't increase.
- KK677 is now the only two pair, making it the second-weakest hand.
- T55J5, KTJJT, and QQQJA are now all four of a kind! T55J5 gets rank
  3, QQQJA gets rank 4, and KTJJT gets rank 5.
  
With the new joker rule, the total winnings in this example are 5905.

Using  the  new joker  rule,  find  the rank  of  every  hand in  your
set. What are the new total winnings?
** DONE Day 8.1

You're  still riding  a camel  across Desert  Island when  you spot  a
sandstorm  quickly approaching.  When you  turn to  warn the  Elf, she
disappears before your eyes! To be fair, she had just finished warning
you about ghosts a few minutes ago.

One of the camel's pouches is  labeled "maps" - sure enough, it's full
of documents (your puzzle input) about  how to navigate the desert. At
least, you're pretty  sure that's what they are; one  of the documents
contains  a list  of  left/right  instructions, and  the  rest of  the
documents seem to describe some kind of network of labeled nodes.

It  seems like  you're meant  to  use the  left/right instructions  to
navigate the  network. Perhaps if you  have the camel follow  the same
instructions, you can escape the haunted wasteland!

After  examining the  maps for  a bit,  two nodes  stick out:  AAA and
ZZZ. You feel  like AAA is where  you are now, and you  have to follow
the left/right instructions until you reach ZZZ.

This format defines each node of the network individually. For
example:

#+begin_example
RL

AAA = (BBB, CCC)
BBB = (DDD, EEE)
CCC = (ZZZ, GGG)
DDD = (DDD, DDD)
EEE = (EEE, EEE)
GGG = (GGG, GGG)
ZZZ = (ZZZ, ZZZ)
#+end_example

Starting with AAA, you  need to look up the next  element based on the
next left/right instruction in your input. In this example, start with
AAA and go right (R) by choosing  the right element of AAA, CCC. Then,
L  means to  choose the  left element  of CCC,  ZZZ. By  following the
left/right instructions, you reach ZZZ in 2 steps.

Of  course, you  might not  find ZZZ  right away.  If you  run out  of
left/right instructions, repeat the  whole sequence of instructions as
necessary: RL really means RLRLRLRLRLRLRLRL... and so on. For example,
here is a situation that takes 6 steps to reach ZZZ:

#+begin_example
LLR

AAA = (BBB, BBB)
BBB = (AAA, ZZZ)
ZZZ = (ZZZ, ZZZ)
#+end_example

Starting at AAA, follow the left/right instructions. How many steps
are required to reach ZZZ?

#+begin_src fennel -n :session d2308 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-node [line]
  [(string.sub line 1 3)
   (string.sub line 8 10)
   (string.sub line 13 15)])

(fn read-nodes [lines]
  (let [map {}]
    (each [_ line (ipairs lines)]
      (let [[start left right] (read-node line)]
        (tset map start [left right])))
    map))

(fn path-find [map start end path step]
  (if (= end start) step
      (case (string.sub path 1 1)
        "R" (path-find map (. (. map start) 2) end (aoc.string-pushback path) (+ 1 step))
        "L" (path-find map (. (. map start) 1) end (aoc.string-pushback path) (+ 1 step)))))

(fn solve [lines path]
  (let [map (read-nodes lines)]
    (path-find map "AAA" "ZZZ" path 0)))

(fn test1 [expected lines path]
  (assert (= expected (solve lines path))))

(local test-input-1
       ["AAA = (BBB, CCC)"
        "BBB = (DDD, EEE)"
        "CCC = (ZZZ, GGG)"
        "DDD = (DDD, DDD)"
        "EEE = (EEE, EEE)"
        "GGG = (GGG, GGG)"
        "ZZZ = (ZZZ, ZZZ)"])

(test1 2 test-input-1 "RL")

(local test-input-2
       ["AAA = (BBB, BBB)"
        "BBB = (AAA, ZZZ)"
        "ZZZ = (ZZZ, ZZZ)"])

(test1 6 test-input-2 "LLR")

(local path-input
       "LRLLRRRLRRLRRRLRLRRLLRRLRRLRRLRRRLLRRLRRLLLRRLLRRRLRRRLRRRLRLRRRLRRRLRLRLRRLRLRRRLRLRLRRRLLRRRLRLRRLLLRRRLLRRLLLRRRLRRLLRLRLRRRLRRLLRRLRRRLRRRLLRRRLLRRRLRRLRRLRLRRRLLLRRRLRRRLRLRRLRRLRRLRRLRRLRRRLRRRLRRLLRRLRRRLRLLRLLRRLLRRLRRRLRRRLRRRLRRRLRRLRRRLLRRLRRRLRRLRRRLRRLRRLRRLRRLRRLRLRRRR")

(solve (aoc.string-from "2023/08.inp") path-input)
#+end_src

#+RESULTS:
: 20093

** DONE Day 8.2

The sandstorm  is upon you and  you aren't any closer  to escaping the
wasteland.  You had  the  camel follow  the  instructions, but  you've
barely left your  starting position. It's going  to take significantly
more steps to escape!

What if the map isn't for people -  what if the map is for ghosts? Are
ghosts even bound by the laws of spacetime? Only one way to find out.

After examining  the maps a bit  longer, your attention is  drawn to a
curious fact: the number  of nodes with names ending in  A is equal to
the number ending in Z! If you were a ghost, you'd probably just start
at every node that ends with A and follow all of the paths at the same
time until they all simultaneously end up at nodes that end with Z.

For example:
#+begin_example
LR

11A = (11B, XXX)
11B = (XXX, 11Z)
11Z = (11B, XXX)
22A = (22B, XXX)
22B = (22C, 22C)
22C = (22Z, 22Z)
22Z = (22B, 22B)
XXX = (XXX, XXX)
#+end_example

Here, there are two starting nodes, 11A and 22A (because they both end
with  A).  As  you  follow   each  left/right  instruction,  use  that
instruction  to simultaneously  navigate away  from both  nodes you're
currently  on. Repeat  this  process  until all  of  the nodes  you're
currently on end with Z. (If only some of the nodes you're on end with
Z, they act like  any other node and you continue  as normal.) In this
example, you would proceed as follows:
- Step 0: You are at 11A and 22A.
- Step 1: You choose all of the left paths, leading you to 11B and 22B.
- Step 2: You choose all of the right paths, leading you to 11Z and 22C.
- Step 3: You choose all of the left paths, leading you to 11B and 22Z.
- Step 4: You choose all of the right paths, leading you to 11Z and 22B.
- Step 5: You choose all of the left paths, leading you to 11B and 22C.
- Step 6: You choose all of the right paths, leading you to 11Z and 22Z.

So, in this example, you end up  entirely on nodes that end in Z after
6 steps.

Simultaneously start  on every node that  ends with A. How  many steps
does it take before you're only on nodes that end with Z?

#+begin_src fennel -n :session d2308 :exports both
(fn path-to-any [map start end path step]
  (if (aoc.table-contains? end start) step
      (let [newstart (case (string.sub path 1 1)
                       "R" (. (. map start) 2) 
                       "L" (. (. map start) 1))]
        (path-to-any map newstart end (aoc.string-pushback path) (+ 1 step)))))

(fn solve2 [lines path start end]
  (let [map (read-nodes lines)
        paths (lume.map start #(path-to-any map $ end path 0))]
    (lume.reduce paths aoc.math-lcm)))

(fn test2 [expected lines path start end]
  (assert (= expected (solve2 lines path start end))))

(local test-input-p2
       ["11A = (11B, XXX)"
        "11B = (XXX, 11Z)"
        "11Z = (11B, XXX)"
        "22A = (22B, XXX)"
        "22B = (22C, 22C)"
        "22C = (22Z, 22Z)"
        "22Z = (22B, 22B)"
        "XXX = (XXX, XXX)"])

(test2 6 test-input-p2 "LR"
       ["11A" "22A"] ["11Z" "22Z"])

(solve2 (aoc.string-from "2023/08.inp") path-input
        ["VGA" "AAA" "LHA" "RHA" "CVA" "LDA"]
        ["BKZ" "KJZ" "XNZ" "XLZ" "PQZ" "ZZZ"])
#+end_src

#+RESULTS:
: 22103062509257

** DONE Day 9.1
You ride  the camel through the  sandstorm and stop where  the ghost's
maps told  you to stop.  The sandstorm subsequently  subsides, somehow
seeing you standing at an oasis!

The camel  goes to get  some water and you  stretch your neck.  As you
look up, you discover what must  be yet another giant floating island,
this one made of  metal! That must be where the parts  to fix the sand
machines come from.

There's even a hang glider partially buried in the sand here; once the
sun rises and heats  up the sand, you might be able  to use the glider
and the hot air to get all the way up to the metal island!

While you wait for  the sun to rise, you admire  the oasis hidden here
in the middle of Desert Island. It must have a delicate ecosystem; you
might as well take some ecological  readings while you wait. Maybe you
can report any environmental instabilities  you find to someone so the
oasis can be around for the next sandstorm-worn traveler.

You pull out your handy Oasis  And Sand Instability Sensor and analyze
your surroundings. The OASIS produces a  report of many values and how
they are  changing over  time (your  puzzle input).  Each line  in the
report contains the history of a single value. For example:

#+begin_example
0 3 6 9 12 15
1 3 6 10 15 21
10 13 16 21 30 45
#+end_example

To best protect the oasis,  your environmental report should include a
prediction of  the next value  in each history.  To do this,  start by
making  a new  sequence  from  the difference  at  each  step of  your
history.  If that  sequence is  not all  zeroes, repeat  this process,
using the sequence you just generated  as the input sequence. Once all
of the values in your latest  sequence are zeroes, you can extrapolate
what the next value of the original history should be.

In the above dataset, the first history is  0 3 6 9 12 15. Because the
values increase by 3 each step, the first sequence of differences that
you generate will be 3 3 3 3  3. Note that this sequence has one fewer
value than  the input sequence because  at each step it  considers two
numbers from the input. Since these values aren't all zero, repeat the
process: the values differ by 0 at  each step, so the next sequence is
0 0  0 0. This  means you have  enough information to  extrapolate the
history! Visually, these sequences can be arranged like this:

#+begin_example
0   3   6   9  12  15
  3   3   3   3   3
    0   0   0   0
#+end_example

To extrapolate, start by adding a new  zero to the end of your list of
zeroes;  because  the zeroes  represent  differences  between the  two
values above them, this also means there is now a placeholder in every
sequence above it:

#+begin_example
0   3   6   9  12  15   B
  3   3   3   3   3   A
    0   0   0   0   0
#+end_example

You can then start filling in placeholders from the bottom up. A needs
to be  the result of increasing  3 (the value  to its left) by  0 (the
value below it); this means A must be 3:

#+begin_example
0   3   6   9  12  15   B
  3   3   3   3   3   3
    0   0   0   0   0
#+end_example

Finally, you can fill in B, which needs to be the result of increasing
15 (the value to its left) by 3 (the value below it), or 18:

#+begin_example
0   3   6   9  12  15  18
  3   3   3   3   3   3
    0   0   0   0   0
#+end_example

So, the next value of the first history is 18.

Finding  all-zero  differences  for  the second  history  requires  an
additional sequence:
#+begin_example
1   3   6  10  15  21
  2   3   4   5   6
    1   1   1   1
      0   0   0
#+end_example

Then, following the same process as before, work out the next value in
each sequence from the bottom up:
#+begin_example
1   3   6  10  15  21  28
  2   3   4   5   6   7
    1   1   1   1   1
      0   0   0   0
#+end_example

So, the next value of the second history is 28.

The third history requires even more sequences, but its next value can
be found the same way:
#+begin_example
10  13  16  21  30  45  68
   3   3   5   9  15  23
     0   2   4   6   8
       2   2   2   2
         0   0   0
#+end_example

So, the next value of the third history is 68.

If you find  the next value for  each history in this  example and add
them together, you get 114.

Analyze your OASIS report and extrapolate the next value for each
history. What is the sum of these extrapolated values?

#+begin_src fennel -n :session d2309 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn table-zip [t1 t2 f]
  (assert (= (length t1)
             (length t2)))
  (let [result []]
    (for [i 1 (length t1) 1]
      (table.insert result (f (. t1 i) (. t2 i))))
    result))

(fn table.dec [t]
  (let [t1 (aoc.table-range t 2 (length t))
        t2 (aoc.table-range t 1 (- (length t) 1))]
    (table-zip t1 t2 (fn [a b] (- a b)))))

(fn derive [t]
  (var dt t)
  (let [result [dt]]
    (while (not (aoc.table-zero? dt))
      (set dt (table.dec dt))
      (table.insert result dt))
    result))

(fn extrapolate [t]
  (let [result []]
    (each [_ ti (ipairs t)]
      (table.insert result (aoc.last ti)))
    (aoc.table-sum result)))

(fn read-input [lines]
  (let [input []]
    (each [_ line (ipairs lines)]
      (table.insert input (lume.map (aoc.string-split line " ") #(tonumber $))))
    input))

(fn solve [input]
  (let [xs (read-input input)]
    (aoc.table-sum (lume.map xs #(extrapolate (derive $))))))

(fn test [expected input]
  (assert (= expected (solve input))))

(local test-input
       [" 0  3  6  9 12 15"
        " 1  3  6 10 15 21"
        "10 13 16 21 30 45"])

(test 114 test-input)

(solve (aoc.string-from "2023/09.inp"))
#+end_src

#+RESULTS:
: 1702218515

** DONE Day 9.2
Of course, it would be nice to have even more history included in your
report. Surely it's safe to just extrapolate backwards as well, right?

For each history, repeat the  process of finding differences until the
sequence of differences  is entirely zero. Then, rather  than adding a
zero  to the  end and  filling  in the  next values  of each  previous
sequence,  you should  instead add  a zero  to the  beginning of  your
sequence of  zeroes, then fill in  new first values for  each previous
sequence.

In particular, here is what the  third example history looks like when
extrapolating back in time:

#+begin_example
5  10  13  16  21  30  45
  5   3   3   5   9  15
   -2   0   2   4   6
      2   2   2   2
        0   0   0
#+end_example

Adding the new values on the left side of each sequence from bottom to
top eventually reveals the new left-most history value: 5.

Doing this  for the remaining  example data above results  in previous
values  of   -3  for  the   first  history   and  0  for   the  second
history. Adding all three new values together produces 2.

Analyze your OASIS report again,  this time extrapolating the previous
value for each history. What is the sum of these extrapolated values?

#+begin_src fennel -n :session d2309 :exports both
(fn solve2 [lines]
  (let [input (read-input lines)]
    (aoc.table-sum (lume.map input #(extrapolate (derive (aoc.table-reverse $)))))))

(fn test2 [expected lines]
  (assert (= expected (solve2 lines))))

(test2 2 test-input)

(solve2 (aoc.string-from "2023/09.inp"))
#+end_src

#+RESULTS:
: 925

** DONE Day 10.1

You use the hang glider to ride the hot air from Desert Island all the
way up to the floating metal  island. This island is surprisingly cold
and there  definitely aren't any  thermals to  glide on, so  you leave
your hang glider behind.

You  wander around  for a  while,  but you  don't find  any people  or
animals.  However, you  do  occasionally find  signposts labeled  "Hot
Springs" pointing in  a seemingly consistent direction;  maybe you can
find someone at the hot springs  and ask them where the desert-machine
parts are made.

The landscape  here is alien; even  the flowers and trees  are made of
metal. As  you stop to admire  some metal grass, you  notice something
metallic scurry  away in your  peripheral vision  and jump into  a big
pipe! It didn't look  like any animal you've ever seen;  if you want a
better look, you'll need to get ahead of it.

Scanning the area, you discover  that the entire field you're standing
on is densely packed with pipes; it  was hard to tell at first because
they're the  same metallic silver  color as  the "ground". You  make a
quick sketch  of all  of the  surface pipes you  can see  (your puzzle
input).

The pipes are arranged in a two-dimensional grid of tiles:
- | is a vertical pipe connecting north and south.
- - is a horizontal pipe connecting east and west.
- L is a 90-degree bend connecting north and east.
- J is a 90-degree bend connecting north and west.
- 7 is a 90-degree bend connecting south and west.
- F is a 90-degree bend connecting south and east.
- . is ground; there is no pipe in this tile.
- S is the starting position of the animal; there is a pipe on this
  tile, but your sketch doesn't show what shape the pipe has.
  
Based on the acoustics of the animal's scurrying, you're confident the
pipe that contains the animal is one large, continuous loop.

For example, here is a square loop of pipe:

#+begin_example
.....
.F-7.
.|.|.
.L-J.
.....
#+end_example

If  the animal  had entered  this loop  in the  northwest corner,  the
sketch would instead look like this:

#+begin_example
.....
.S-7.
.|.|.
.L-J.
.....
#+end_example

In the above diagram, the S tile  is still a 90-degree F bend: you can
tell because of how the adjacent pipes connect to it.


Unfortunately, there are also many  pipes that aren't connected to the
loop! This sketch shows the same loop as above:

#+begin_example
-L|F7
7S-7|
L|7||
-L-J|
L|-JF
#+end_example

In the  above diagram, you can  still figure out which  pipes form the
main loop: they're the ones connected  to S, pipes those pipes connect
to, pipes those  pipes connect to, and  so on. Every pipe  in the main
loop  connects to  its two  neighbors  (including S,  which will  have
exactly two  pipes connecting to it,  and which is assumed  to connect
back to those two pipes).

Here is a sketch that contains a slightly more complex main loop:

#+begin_example
..F7.
.FJ|.
SJ.L7
|F--J
LJ...
#+end_example

Here's the same example sketch with the extra, non-main-loop pipe
tiles also shown:

#+begin_example
7-F7-
.FJ|7
SJLL7
|F--J
LJ.LJ
#+end_example

If you want to  get out ahead of the animal, you  should find the tile
in the loop  that is farthest from the starting  position. Because the
animal is in the pipe, it doesn't make sense to measure this by direct
distance.  Instead, you  need to  find the  tile that  would take  the
longest number  of steps  along the  loop to  reach from  the starting
point - regardless of which way around the loop the animal went.

In the first example with the square loop:

#+begin_example
.....
.S-7.
.|.|.
.L-J.
.....
#+end_example

You can count the distance each tile in the loop is from the starting
point like this:

#+begin_example
.....
.012.
.1.3.
.234.
.....
#+end_example

In this example, the farthest point from the start is 4 steps away.

Here's the more complex loop again:

#+begin_example
..F7.
.FJ|.
SJ.L7
|F--J
LJ...
#+end_example

Here are the distances for each tile on that loop:

#+begin_example
..45.
.236.
01.78
14567
23...
#+end_example

Find the  single giant loop  starting at S.  How many steps  along the
loop  does it  take to  get from  the starting  position to  the point
farthest from the starting position?

#+begin_src fennel -n :session d2310 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local S2N ["|" "F" "7" "S"])
(local N2S ["|" "L" "J" "S"])
(local E2W ["-" "L" "F" "S"])
(local W2E ["-" "7" "J" "S"])

(fn connected? [t x y dir]
  (case dir
    :north (aoc.table-contains? S2N (?. (?. t (- x 1)) y))
    :east (aoc.table-contains? W2E (?. (?. t x) (+ 1 y)))
    :south (aoc.table-contains? N2S (?. (?. t (+ x 1)) y))
    :west (aoc.table-contains? E2W (?. (?. t x) (- y 1)))))

(fn move [t x y s from]
  (let [pos (. (. t x) y)]
    (if (and (< 0 s) (= "S" pos)) (aoc.int (/ s 2))
        (< (* (length t) (length (. t 1))) s) -1
        (case pos
          "S" (if (connected? t x y :north) (move t (- x 1) y (+ 1 s) :south)
                  (connected? t x y :east) (move t x (+ y 1) (+ 1 s) :west)
                  (connected? t x y :south) (move t (+ x 1) y (+ 1 s) :north)
                  (connected? t x y :west) (move t x (- y 1) (+ 1 s) :east))
          "-" (case from
                :west (if (connected? t x y :east) (move t x (+ y 1) (+ 1 s) :west))
                :east (if (connected? t x y :west) (move t x (- y 1) (+ 1 s) :east)))
          "|" (case from
                :south (if (connected? t x y :north) (move t (- x 1) y (+ 1 s) :south))
                :north (if (connected? t x y :south) (move t (+ x 1) y (+ 1 s) :north)))
          "F" (case from
                :south (if (connected? t x y :east) (move t x (+ y 1) (+ 1 s) :west))
                :east (if (connected? t x y :south) (move t (+ x 1) y (+ 1 s) :north)))
          "L" (case from
                :east (if (connected? t x y :north) (move t (- x 1) y (+ 1 s) :south))
                :north (if (connected? t x y :east) (move t x (+ y 1) (+ 1 s) :west)))
          "7" (case from
                :west (if (connected? t x y :south) (move t (+ x 1) y (+ 1 s) :north))
                :south (if (connected? t x y :west) (move t x (- y 1) (+ 1 s) :east)))
          "J" (case from
                :west (if (connected? t x y :north) (move t (- x 1) y (+ 1 s) :south))
                :north (if (connected? t x y :west) (move t x (- y 1) (+ 1 s) :east)))))))

(fn solve [input sx sy]
  (let [m (aoc.read-matrix input)]
    (move m sx sy 0 :start)))

(fn test [expected input sx sy]
  (assert (= expected (solve input sx sy))))

(local test-input1
       ["-L|F7"
        "7S-7|"
        "L|7||"
        "-L-J|"
        "L|-JF"])

(test 4 test-input1 2 2)

(local test-input2
       ["7-F7-"
        ".FJ|7"
        "SJLL7"
        "|F--J"
        "LJ.LJ"])

(test 8 test-input2 3 1)

(solve (aoc.string-from "2023/10.inp") 64 63)
#+end_src

#+RESULTS:
: 7093

** TODO Day 10.2                                                  :noexport:

You quickly reach the farthest point of the loop, but the animal never
emerges. Maybe its nest is within the area enclosed by the loop?

To determine  whether it's even  worth taking  the time to  search for
such a nest, you should calculate  how many tiles are contained within
the loop. For example:

#+begin_example
...........
.S-------7.
.|F-----7|.
.||.....||.
.||.....||.
.|L-7.F-J|.
.|..|.|..|.
.L--J.L--J.
...........
#+end_example

The above loop encloses merely four tiles  - the two pairs of . in the
southwest and southeast (marked I below). The middle . tiles (marked O
below) are  not in the  loop. Here is the  same loop again  with those
regions marked:

#+begin_example
...........
.S-------7.
.|F-----7|.
.||OOOOO||.
.||OOOOO||.
.|L-7OF-J|.
.|II|O|II|.
.L--JOL--J.
.....O.....
#+end_example

In fact, there doesn't even need to be a full tile path to the outside
for tiles  to count as outside  the loop - squeezing  between pipes is
also allowed! Here, I is still within  the loop and O is still outside
the loop:

#+begin_example
..........
.S------7.
.|F----7|.
.||OOOO||.
.||OOOO||.
.|L-7F-J|.
.|II||II|.
.L--JL--J.
..........
#+end_example

In  both  of  the  above  examples,   4  tiles  are  enclosed  by  the
loop. Here's a larger example:

#+begin_example
.F----7F7F7F7F-7....
.|F--7||||||||FJ....
.||.FJ||||||||L7....
FJL7L7LJLJ||LJ.L-7..
L--J.L7...LJS7F-7L7.
....F-J..F7FJ|L7L7L7
....L7.F7||L7|.L7L7|
.....|FJLJ|FJ|F7|.LJ
....FJL-7.||.||||...
....L---J.LJ.LJLJ...
#+end_example

The above sketch has many random bits  of ground, some of which are in
the loop (I) and some of which are outside it (O):

#+begin_example
OF----7F7F7F7F-7OOOO
O|F--7||||||||FJOOOO
O||OFJ||||||||L7OOOO
FJL7L7LJLJ||LJIL-7OO
L--JOL7IIILJS7F-7L7O
OOOOF-JIIF7FJ|L7L7L7
OOOOL7IF7||L7|IL7L7|
OOOOO|FJLJ|FJ|F7|OLJ
OOOOFJL-7O||O||||OOO
OOOOL---JOLJOLJLJOOO
#+end_example

In this larger example, 8 tiles are enclosed by the loop.

Any tile that isn't part of the  main loop can count as being enclosed
by the loop. Here's another example  with many bits of junk pipe lying
around that aren't connected to the main loop at all:

#+begin_example
FF7FSF7F7F7F7F7F---7
L|LJ||||||||||||F--J
FL-7LJLJ||||||LJL-77
F--JF--7||LJLJ7F7FJ-
L---JF-JLJ.||-FJLJJ7
|F|F-JF---7F7-L7L|7|
|FFJF7L7F-JF7|JL---7
7-L-JL7||F7|L7F-7F7|
L.L7LFJ|||||FJL7||LJ
L7JLJL-JLJLJL--JLJ.L
#+end_example

Here are just the tiles that are enclosed by the loop marked with I:

#+begin_example
FF7FSF7F7F7F7F7F---7
L|LJ||||||||||||F--J
FL-7LJLJ||||||LJL-77
F--JF--7||LJLJIF7FJ-
L---JF-JLJIIIIFJLJJ7
|F|F-JF---7IIIL7L|7|
|FFJF7L7F-JF7IIL---7
7-L-JL7||F7|L7F-7F7|
L.L7LFJ|||||FJL7||LJ
L7JLJL-JLJLJL--JLJ.L
#+end_example

In this  last example, 10 tiles  are enclosed by the  loop.

Figure out whether you have time to search for the nest by calculating
the area within the loop. How many tiles are enclosed by the loop?
** DONE Day 11.1

You continue  following signs  for "Hot  Springs" and  eventually come
across an  observatory. The Elf  within turns  out to be  a researcher
studying cosmic expansion using the giant telescope here.

He doesn't  know anything about  the missing machine parts;  he's only
visiting for this research project.  However, he confirms that the hot
springs are  the next-closest area  likely to have people;  he'll even
take  you  straight there  once  he's  done with  today's  observation
analysis.

Maybe you can help him with the analysis to speed things up?

The researcher  has collected a  bunch of  data and compiled  the data
into  a single  giant image  (your puzzle  input). The  image includes
empty space (.) and galaxies (#). For example:

#+begin_example
...#......
.......#..
#.........
..........
......#...
.#........
.........#
..........
.......#..
#...#.....
#+end_example

The researcher is trying  to figure out the sum of  the lengths of the
shortest  path between  every  pair of  galaxies.  However, there's  a
catch: the universe expanded in the  time it took the light from those
galaxies to reach the observatory.

Due  to something  involving  gravitational effects,  only some  space
expands. In fact, the result is  that any rows or columns that contain
no galaxies should all actually be twice as big.

In the above example, three columns and two rows contain no galaxies:

#+begin_example
   v  v  v
 ...#......
 .......#..
 #.........
>..........<
 ......#...
 .#........
 .........#
>..........<
 .......#..
 #...#.....
   ^  ^  ^
#+end_example

These rows and columns  need to be twice as big;  the result of cosmic
expansion therefore looks like this:

#+begin_example
....#........
.........#...
#............
.............
.............
........#....
.#...........
............#
.............
.............
.........#...
#....#.......
#+end_example


Equipped with this expanded universe,  the shortest path between every
pair of galaxies  can be found. It  can help to assign  every galaxy a
unique number:

#+begin_example
....1........
.........2...
3............
.............
.............
........4....
.5...........
............6
.............
.............
.........7...
8....9.......
#+end_example

In these  9 galaxies, there are  36 pairs. Only count  each pair once;
order within the pair doesn't matter. For each pair, find any shortest
path between  the two galaxies  using only  steps that move  up, down,
left,  or right  exactly one  . or  # at  a time.  (The shortest  path
between two galaxies is allowed to pass through another galaxy.)

For example, here is one of the shortest paths between galaxies 5 and
9:

#+begin_example
....1........
.........2...
3............
.............
.............
........4....
.5...........
.##.........6
..##.........
...##........
....##...7...
8....9.......
#+end_example

This path has length 9 because it takes a minimum of nine steps to get
from galaxy 5 to galaxy 9 (the  eight locations marked # plus the step
onto  galaxy 9  itself). Here  are  some other  example shortest  path
lengths:
- Between galaxy 1 and galaxy 7: 15
- Between galaxy 3 and galaxy 6: 17
- Between galaxy 8 and galaxy 9: 5

In this example, after expanding the universe, the sum of the shortest
path between all 36 pairs of galaxies is 374.

Expand the universe, then find the length of the shortest path between
every pair of galaxies. What is the sum of these lengths?

#+begin_src fennel -n :session d2311 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn distance [a b]
  (let [[x1 y1] a [x2 y2] b]
    (+ (math.abs (- x1 x2)) (math.abs (- y1 y2)))))

(fn find-coords [matrix v]
  (let [result []]
    (for [i 1 (length matrix) 1]
      (for [j 1 (length (. matrix i)) 1]
        (when (= v (. (. matrix i) j))
          (table.insert result [i j]))))
    result))

(fn calculate-distances [xs]
  (let [result []]
    (for [i 1 (length xs) 1]
      (table.insert result 
                    (lume.map (aoc.table-range xs i (length xs)) #(distance (. xs i) $))))
    result))

(fn find-blank-rows [matrix blank]
  (let [result []]
    (each [i row (ipairs matrix)]
      (if (lume.all row #(= $ blank))
          (table.insert result i)))
    (aoc.table-reverse result)))

(fn expand-empty-space [matrix]
  (let [rows (find-blank-rows matrix ".")]
    (each [_ row (ipairs rows)]
      (table.insert matrix row (. matrix row))))
  (let [result (aoc.table-transpose matrix)
        rows (find-blank-rows result ".")]
    (each [_ row (ipairs rows)]
      (table.insert result row (. result row)))
    (aoc.table-transpose result)))

(fn solve [input]
  (let [m (aoc.read-matrix input)
        mm (expand-empty-space m)
        coords (find-coords mm "#")
        dist (calculate-distances coords)]
    (aoc.table-sum dist)))

(fn test [expected input]
  (assert (= expected (solve input))))

(local test-input
       ["...#......"
        ".......#.."
        "#........."
        ".........."
        "......#..."
        ".#........"
        ".........#"
        ".........."
        ".......#.."
        "#...#....."])

(test 374 test-input)

(solve (aoc.string-from "2023/11.inp"))
#+end_src

#+RESULTS:
: 9965032

** TODO Day 11.2                                                  :noexport:

The galaxies  are much older  (and thus  much farther apart)  than the
researcher initially estimated.

Now, instead of  the expansion you did before, make  each empty row or
column one  million times larger.  That is,  each empty row  should be
replaced  with 1000000  empty rows,  and each  empty column  should be
replaced with 1000000 empty columns.

(In the  example above,  if each  empty row or  column were  merely 10
times larger,  the sum  of the  shortest paths  between every  pair of
galaxies would  be 1030. If each  empty row or column  were merely 100
times larger,  the sum  of the  shortest paths  between every  pair of
galaxies would be 8410. However, your universe will need to expand far
beyond these values.)

Starting with the same initial image, expand the universe according to
these new  rules, then find  the length  of the shortest  path between
every pair of galaxies. What is the sum of these lengths?
** TODO Day 12.1                                                  :noexport:

You  finally reach  the hot  springs! You  can see  steam rising  from
secluded areas attached to the primary, ornate building.

As you turn to enter, the researcher  stops you. "Wait - I thought you
were looking for the hot springs, weren't you?" You indicate that this
definitely looks like hot springs to you.

"Oh, sorry, common mistake! This is actually the onsen! The hot
springs are next door."

You  look in  the direction  the researcher  is pointing  and suddenly
notice the massive metal helixes towering overhead. "This way!"

It only  takes you  a few  more steps to  reach the  main gate  of the
massive fenced-off  area containing  the springs.  You go  through the
gate and into a small administrative building.

"Hello! What  brings you to the  hot springs today? Sorry  they're not
very hot right  now; we're having a lava shortage  at the moment." You
ask about the missing machine parts for Desert Island.

"Oh,  all  of Gear  Island  is  currently  offline! Nothing  is  being
manufactured at  the moment, not  until we get  more lava to  heat our
forges.  And  our springs.  The  springs  aren't very  springy  unless
they're hot!"

"Say,  could you  go up  and  see why  the lava  stopped flowing?  The
springs are  too cold for normal  operation, but we should  be able to
find one springy enough to launch you up there!"

There's  just one  problem  - many  of the  springs  have fallen  into
disrepair, so  they're not actually  sure which springs would  even be
safe to use!  Worse yet, their condition records of  which springs are
damaged (your puzzle input) are also damaged! You'll need to help them
repair the damaged records.

In  the  giant field  just  outside,  the  springs are  arranged  into
rows.  For each  row,  the  condition records  show  every spring  and
whether it is operational (.) or damaged  (#). This is the part of the
condition  records that  is itself  damaged; for  some springs,  it is
simply unknown (?) whether the spring is operational or damaged.

However,  the  engineer  that  produced  the  condition  records  also
duplicated some of  this information in a different  format! After the
list of springs for a given row,  the size of each contiguous group of
damaged springs  is listed  in the  order those  groups appear  in the
row.  This list  always accounts  for every  damaged spring,  and each
number is the entire size of its contiguous group (that is, groups are
always separated by at least one operational spring: #### would always
be 4, never 2,2).

So, condition records with no unknown spring conditions might look
like this:

#+begin_example
#.#.### 1,1,3
.#...#....###. 1,1,3
.#.###.#.###### 1,3,1,6
####.#...#... 4,1,1
#....######..#####. 1,6,5
.###.##....# 3,2,1
#+end_example

However,  the condition  records are  partially damaged;  some of  the
springs' conditions are actually unknown (?). For example:

#+begin_example
???.### 1,1,3
.??..??...?##. 1,1,3
?#?#?#?#?#?#?#? 1,3,1,6
????.#...#... 4,1,1
????.######..#####. 1,6,5
?###???????? 3,2,1
#+end_example

Equipped with this information, it is  your job to figure out how many
different arrangements of operational and broken springs fit the given
criteria in each row.

In the first  line (???.### 1,1,3), there is exactly  one way separate
groups  of one,  one, and  three broken  springs (in  that order)  can
appear in  that row: the first  three unknown springs must  be broken,
then operational, then broken (#.#), making the whole row #.#.###.

The second line  is more interesting: .??..??...?##. 1,1,3  could be a
total of four different arrangements. The last ? must always be broken
(to satisfy the  final contiguous group of three  broken springs), and
each ?? must  hide exactly one of the two  broken springs. (Neither ??
could be  both broken springs or  they would form a  single contiguous
group of two; if that were true, the numbers afterward would have been
2,3 instead.)  Since each ??  can either be #.  or .#, there  are four
possible arrangements of springs.

The last line is actually  consistent with ten different arrangements!
Because the  first number is  3, the first and  second ? must  both be
.  (if  either  were #,  the  first  number  would  have to  be  4  or
higher). However, the remaining run  of unknown spring conditions have
many  different ways  they could  hold groups  of two  and one  broken
springs:

#+begin_example
?###???????? 3,2,1
.###.##.#...
.###.##..#..
.###.##...#.
.###.##....#
.###..##.#..
.###..##..#.
.###..##...#
.###...##.#.
.###...##..#
.###....##.#
#+end_example

In this example, the number of possible arrangements for each row is:

- ???.### 1,1,3 - 1 arrangement
- .??..??...?##. 1,1,3 - 4 arrangements
- ?#?#?#?#?#?#?#? 1,3,1,6 - 1 arrangement
- ????.#...#... 4,1,1 - 1 arrangement
- ????.######..#####. 1,6,5 - 4 arrangements
- ?###???????? 3,2,1 - 10 arrangements

Adding  all of  the possible  arrangement counts  together produces  a
total of 21 arrangements.

For each row,  count all of the different  arrangements of operational
and broken  springs that meet the  given criteria. What is  the sum of
those counts?
** TODO Day 12.2                                                  :noexport:

** TODO Day 13.1                                                  :noexport:

With your  help, the  hot springs team  locates an  appropriate spring
which launches you neatly and precisely up to the edge of Lava Island.

There's just one problem: you don't see any lava.

You do  see a lot of  ash and igneous  rock; there are even  what look
like gray mountains scattered around. After a while, you make your way
to a  nearby cluster  of mountains  only to  discover that  the valley
between them is completely full of  large mirrors. Most of the mirrors
seem to  be aligned in  a consistent way;  perhaps you should  head in
that direction?

As you  move through the valley  of mirrors, you find  that several of
them  have  fallen  from  the  large  metal  frames  keeping  them  in
place.  The mirrors  are extremely  flat and  shiny, and  many of  the
fallen mirrors have lodged into the ash at strange angles. Because the
terrain is all one color, it's hard to tell where it's safe to walk or
where you're about to run into a mirror.

You note down  the patterns of ash  (.) and rocks (#) that  you see as
you walk  (your puzzle  input); perhaps  by carefully  analyzing these
patterns, you can figure out where the mirrors are!

For example:
#+begin_example
#.##..##.
..#.##.#.
##......#
##......#
..#.##.#.
..##..##.
#.#.##.#.

#...##..#
#....#..#
..##..###
#####.##.
#####.##.
..##..###
#....#..#
#+end_example

To find  the reflection in  each pattern, you  need to find  a perfect
reflection across either a horizontal  line between two rows or across
a vertical line between two columns.


In the first pattern, the reflection is across a vertical line between
two  columns; arrows  on each  of the  two columns  point at  the line
between the columns:

#+begin_example
123456789
    ><   
#.##..##.
..#.##.#.
##......#
##......#
..#.##.#.
..##..##.
#.#.##.#.
    ><   
123456789
#+end_example

In this pattern,  the line of reflection is the  vertical line between
columns 5  and 6. Because  the vertical line  is not perfectly  in the
middle of the  pattern, part of the pattern (column  1) has nowhere to
reflect onto  and can be ignored;  every other column has  a reflected
column within  the pattern  and must match  exactly: column  2 matches
column 9, column 3 matches 8, 4 matches 7, and 5 matches 6.

The second pattern reflects across a horizontal line instead:

#+begin_example
1 #...##..# 1
2 #....#..# 2
3 ..##..### 3
4v#####.##.v4
5^#####.##.^5
6 ..##..### 6
7 #....#..# 7
#+end_example

This  pattern  reflects across  the  horizontal  line between  rows  4
and 5. Row 1 would reflect with a hypothetical row 8, but since that's
not  in  the pattern,  row  1  doesn't  need  to match  anything.  The
remaining rows match:  row 2 matches row  7, row 3 matches  row 6, and
row 4 matches row 5.

To summarize your  pattern notes, add up the number  of columns to the
left  of each  vertical  line of  reflection; to  that,  also add  100
multiplied  by  the number  of  rows  above  each horizontal  line  of
reflection. In  the above example,  the first pattern's  vertical line
has 5 columns to its left and the second pattern's horizontal line has
4 rows above it, a total of 405.

Find  the  line  of  reflection  in  each  of  the  patterns  in  your
notes. What number do you get after summarizing all of your notes?
** TODO Day 13.2                                                  :noexport:

** DONE Day 14.1

You reach the place where all  of the mirrors were pointing: a massive
parabolic  reflector  dish  attached  to the  side  of  another  large
mountain.

The  dish is  made up  of many  small mirrors,  but while  the mirrors
themselves are  roughly in  the shape of  a parabolic  reflector dish,
each  individual mirror  seems to  be pointing  in slightly  the wrong
direction. If the  dish is meant to focus light,  all it's doing right
now is sending it in a vague direction.

This system  must be  what provides  the energy for  the lava!  If you
focus the reflector dish, maybe you can go where it's pointing and use
the light to fix the lava production.

Upon  closer inspection,  the  individual mirrors  each  appear to  be
connected via  an elaborate  system of  ropes and  pulleys to  a large
metal platform below the dish. The  platform is covered in large rocks
of  various shapes.  Depending on  their position,  the weight  of the
rocks deforms  the platform,  and the shape  of the  platform controls
which ropes move and ultimately the focus of the dish.

In short: if you move the rocks,  you can focus the dish. The platform
even has a control  panel on the side that lets you tilt  it in one of
four directions! The rounded rocks (O)  will roll when the platform is
tilted, while the  cube-shaped rocks (#) will stay in  place. You note
the positions  of all of the  empty spaces (.) and  rocks (your puzzle
input). For example:

#+begin_example
O....#....
O.OO#....#
.....##...
OO.#O....O
.O.....O#.
O.#..O.#.#
..O..#O..O
.......O..
#....###..
#OO..#....
#+end_example

Start by tilting the lever so all of the rocks will slide north as far
as they will go:

#+begin_example
OOOO.#.O..
OO..#....#
OO..O##..O
O..#.OO...
........#.
..#....#.#
..O..#.O.O
..O.......
#....###..
#....#....
#+end_example

You notice that the support beams along the north side of the platform
are  damaged; to  ensure  the platform  doesn't  collapse, you  should
calculate the total load on the north support beams.

The amount of load caused by a single rounded rock (O) is equal to the
number  of rows  from the  rock  to the  south edge  of the  platform,
including  the  row the  rock  is  on.  (Cube-shaped rocks  (#)  don't
contribute to  load.) So, the  amount of load  caused by each  rock in
each row is as follows:

#+begin_example
OOOO.#.O.. 10
OO..#....#  9
OO..O##..O  8
O..#.OO...  7
........#.  6
..#....#.#  5
..O..#.O.O  4
..O.......  3
#....###..  2
#....#....  1
#+end_example

The total  load is the sum  of the load  caused by all of  the rounded
rocks. In this example, the total load is 136.

Tilt the platform so that the rounded rocks all roll north. Afterward,
what is the total load on the north support beams?

#+begin_src fennel -n :session d2314 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn table.swap [t i j direction]
  (let [ij (. (. t i) j)]
    (case direction
      :north (when (< 1 i)
               (let [old (aoc.table-replace t (- i 1) j ij)]
                 (aoc.table-replace t i j old)))
      :south (when (< i (length t))
               (let [old (aoc.table-replace t (+ i 1) j ij)]
                 (aoc.table-replace t i j old)))
      :east (when (< j (length (. t i)))
               (let [old (aoc.table-replace t i (+ j 1) ij)]
                 (aoc.table-replace t i j old)))
      :west (when (< 1 j)
               (let [old (aoc.table-replace t i (- j 1) ij)]
                 (aoc.table-replace t i j old)))))
  t)

(fn math.wsum [xs]
  (let [xx (aoc.table-reverse xs)]
    (accumulate [sum 0 i x (ipairs xx)]
      (+ sum (* i x)))))

(fn table.tonumbers [lines]
  (lume.map lines #(aoc.string-toarray $)))

(fn tilt-north [matrix]
  (let [len1 (length matrix)
        len2 (length (. matrix 1))]
    (for [i (- len1 1) 1 -1]
      (for [j len1 (+ i 1) -1]
        (for [k len2 1 -1]
          (when (and (= "O" (. (. matrix j) k))
                     (= "." (. (. matrix (- j 1)) k)))
            (table.swap matrix j k :north))))))
  matrix)

(fn tilt-south [matrix]
  matrix)

(fn tilt-east [matrix]
  matrix)

(fn tilt-west [matrix]
  matrix)

(fn tilt [matrix direction]
  (case direction
    :north (tilt-north (tilt-north (tilt-north matrix)))
    :south (tilt-south matrix)
    :east (tilt-east matrix)
    :west (tilt-west matrix)
    _ matrix))

(fn weight [xs]
  (var count 0)
  (each [_ x (ipairs xs)]
    (when (= "O" x)
      (set count (+ 1 count))))
  count)

(fn weights [xs]
  (lume.map xs #(weight $)))

(fn solve [lines]
  (let [input (table.tonumbers lines)
        matrix (tilt input :north)]
    (math.wsum (weights matrix))))

(fn test [expected lines]
  (assert (= expected (solve lines))))

(test 136
      ["O....#...."
       "O.OO#....#"
       ".....##..."
       "OO.#O....O"
       ".O.....O#."
       "O.#..O.#.#"
       "..O..#O..O"
       ".......O.."
       "#....###.."
       "#OO..#...."])

(solve (aoc.string-from "2023/14.inp"))
#+end_src

#+RESULTS:
: 113456

** TODO Day 14.2                                                  :noexport:

The parabolic  reflector dish deforms, but  not in a way  that focuses
the beam. To  do that, you'll need  to move the rocks to  the edges of
the platform. Fortunately,  a button on the side of  the control panel
labeled "spin cycle" attempts to do just that!

Each cycle  tilts the platform  four times  so that the  rounded rocks
roll north,  then west, then  south, then  east. After each  tilt, the
rounded rocks roll as far as they can before the platform tilts in the
next  direction. After  one  cycle, the  platform  will have  finished
rolling the rounded rocks in those four directions in that order.

Here's what happens  in the example above after each  of the first few
cycles:

#+begin_example
After 1 cycle:
.....#....
....#...O#
...OO##...
.OO#......
.....OOO#.
.O#...O#.#
....O#....
......OOOO
#...O###..
#..OO#....

After 2 cycles:
.....#....
....#...O#
.....##...
..O#......
.....OOO#.
.O#...O#.#
....O#...O
.......OOO
#..OO###..
#.OOO#...O

After 3 cycles:
.....#....
....#...O#
.....##...
..O#......
.....OOO#.
.O#...O#.#
....O#...O
.......OOO
#...O###.O
#.OOO#...O
#+end_example

This process  should work  if you  leave it  running long  enough, but
you're  still worried  about the  north  support beams.  To make  sure
they'll survive for  a while, you need to calculate  the total load on
the north support beams after 1000000000 cycles.

In the above  example, after 1000000000 cycles, the total  load on the
north support beams is 64.

Run the spin cycle for 1000000000 cycles. Afterward, what is the total
load on the north support beams?
** DONE Day 15.1

The  newly-focused parabolic  reflector  dish is  sending  all of  the
collected light to a  point on the side of yet  another mountain - the
largest mountain  on Lava  Island. As you  approach the  mountain, you
find that the light is being collected by the wall of a large facility
embedded in the mountainside.

You  find  a door  under  a  large  sign  that says  "Lava  Production
Facility" and  next to  a smaller  sign that  says "Danger  - Personal
Protective Equipment required beyond this point".

As you step inside, you are immediately greeted by a somewhat panicked
reindeer wearing  goggles and a  loose-fitting hard hat.  The reindeer
leads you to a  shelf of goggles and hard hats  (you quickly find some
that fit) and then further into the facility. At one point, you pass a
button  with a  faint snout  mark and  the label  "PUSH FOR  HELP". No
wonder you were loaded into that trebuchet so quickly!

You  pass through  a  final set  of doors  surrounded  with even  more
warning signs and into what must be  the room that collects all of the
light  from outside.  As you  admire  the large  assortment of  lenses
available to further  focus the light, the reindeer brings  you a book
titled "Initialization Manual".

"Hello!",  the  book  cheerfully  begins, apparently  unaware  of  the
concerned reindeer  reading over  your shoulder. "This  procedure will
let  you bring  the  Lava  Production Facility  online  - all  without
burning or melting anything unintended!"

"Before you begin, please be prepared  to use the Holiday ASCII String
Helper algorithm (appendix 1A)." You turn to appendix 1A. The reindeer
leans closer with interest.

The HASH algorithm  is a way to  turn any string of  characters into a
single number in  the range 0 to  255. To run the HASH  algorithm on a
string, start with  a current value of 0. Then,  for each character in
the string starting from the beginning:
- Determine the ASCII code for the current character of the string.
- Increase the current value by the ASCII code you just determined.
- Set the current value to itself multiplied by 17.
- Set the current value to the remainder of dividing itself by 256.

After following these steps for each character in the string in order,
the current value is the output of the HASH algorithm.

So, to find the result of running the HASH algorithm on the string HASH:
- The current value starts at 0.
- The first character is H; its ASCII code is 72.
- The current value increases to 72.
- The current value is multiplied by 17 to become 1224.
- The current value becomes 200 (the remainder of 1224 divided by 256).
- The next character is A; its ASCII code is 65.
- The current value increases to 265.
- The current value is multiplied by 17 to become 4505.
- The current value becomes 153 (the remainder of 4505 divided by 256).
- The next character is S; its ASCII code is 83.
- The current value increases to 236.
- The current value is multiplied by 17 to become 4012.
- The current value becomes 172 (the remainder of 4012 divided by 256).
- The next character is H; its ASCII code is 72.
- The current value increases to 244.
- The current value is multiplied by 17 to become 4148.
- The current value becomes 52 (the remainder of 4148 divided by 256).

So, the result of running the HASH algorithm on the string HASH is 52.

The initialization  sequence (your puzzle input)  is a comma-separated
list of  steps to start  the Lava Production Facility.  Ignore newline
characters when  parsing the  initialization sequence. To  verify that
your HASH algorithm is working, the  book offers the sum of the result
of  running the  HASH algorithm  on  each step  in the  initialization
sequence.

For example:

#+begin_example
rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7
#+end_example

This initialization sequence specifies 11 individual steps; the result
of running the HASH algorithm on each of the steps is as follows:

- rn=1 becomes 30.
- cm- becomes 253.
- qp=3 becomes 97.
- cm=2 becomes 47.
- qp- becomes 14.
- pc=4 becomes 180.
- ot=9 becomes 9.
- ab=5 becomes 197.
- pc- becomes 48.
- pc=6 becomes 214.
- ot=7 becomes 231.

In this example, the sum of  these results is 1320. Unfortunately, the
reindeer  has stolen  the  page containing  the expected  verification
number and is currently running around the facility with it excitedly.

Run  the   HASH  algorithm   on  each   step  in   the  initialization
sequence. What is the sum of the results? (The initialization sequence
is one long line; be careful when copy-pasting it.)

#+begin_src fennel -n :session d2315 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn hash [s]
  (var result 0)
  (for [i 1 (length s) 1]
    (set result (% (* 17 (+ result (string.byte s i i))) 256)))
  result)

(fn solve [input]
  (-> (. input 1)
      (aoc.string-split ",")
      (lume.map #(hash $))
      (aoc.table-sum)))

(fn test [expected input]
  (assert (= expected (solve [input]))))

(test 1320 "rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7")

(solve (aoc.string-from "2023/15.inp"))
#+end_src

#+RESULTS:
: 514281

** TODO Day 15.2                                                  :noexport:

You convince  the reindeer to  bring you  the page; the  page confirms
that your HASH algorithm is working.

The  book  goes on  to  describe  a series  of  256  boxes numbered  0
through 255. The boxes are arranged  in a line starting from the point
where light enters the facility. The boxes have holes that allow light
to pass from one box to the next all the way down the line.

#+begin_example
      +-----+  +-----+         +-----+
Light | Box |  | Box |  ...    | Box |
----------------------------------------->
      |  0   | |  1  |  ...    | 255 |
      +-----+  +-----+         +-----+
#+end_example

Inside each  box, there are several  lens slots that will  keep a lens
correctly positioned to focus light  passing through the box. The side
of each box  has a panel that  opens to allow you to  insert or remove
lenses as necessary.

Along  the wall  running  parallel to  the boxes  is  a large  library
containing   lenses  organized   by  focal   length  ranging   from  1
through  9.  The reindeer  also  brings  you  a small  handheld  label
printer.

The  book  goes  on  to  explain  how to  perform  each  step  in  the
initialization sequence, a  process it calls the  Holiday ASCII String
Helper Manual Arrangement Procedure, or HASHMAP for short.

Each step begins with a sequence of letters that indicate the label of
the lens  on which the step  operates. The result of  running the HASH
algorithm on the label indicates the correct box for that step.

The label will  be immediately followed by a  character that indicates
the operation to perform: either an equals sign (=) or a dash (-).

If the operation character  is a dash (-), go to  the relevant box and
remove  the  lens  with the  given  label  if  it  is present  in  the
box. Then, move any remaining lenses as far forward in the box as they
can  go  without changing  their  order,  filling  any space  made  by
removing the  indicated lens. (If  no lens in  that box has  the given
label, nothing happens.)

If the operation character is an equals sign (=), it will be followed
by a number indicating the focal length of the lens that needs to go
into the relevant box; be sure to use the label maker to mark the lens
with the label given in the beginning of the step so you can find it
later. There are two possible situations:
- If there is already a lens in the box with the same label, replace
  the old lens with the new lens: remove the old lens and put the new
  lens in its place, not moving any other lenses in the box.
- If there is not already a lens in the box with the same label, add
  the lens to the box immediately behind any lenses already in the
  box. Don't move any of the other lenses when you do this. If there
  aren't any lenses in the box, the new lens goes all the way to the
  front of the box.  

Here is the contents of every box after each step in the example
initialization sequence above:

#+begin_example
After "rn=1":
Box 0: [rn 1]

After "cm-":
Box 0: [rn 1]

After "qp=3":
Box 0: [rn 1]
Box 1: [qp 3]

After "cm=2":
Box 0: [rn 1] [cm 2]
Box 1: [qp 3]

After "qp-":
Box 0: [rn 1] [cm 2]

After "pc=4":
Box 0: [rn 1] [cm 2]
Box 3: [pc 4]

After "ot=9":
Box 0: [rn 1] [cm 2]
Box 3: [pc 4] [ot 9]

After "ab=5":
Box 0: [rn 1] [cm 2]
Box 3: [pc 4] [ot 9] [ab 5]

After "pc-":
Box 0: [rn 1] [cm 2]
Box 3: [ot 9] [ab 5]

After "pc=6":
Box 0: [rn 1] [cm 2]
Box 3: [ot 9] [ab 5] [pc 6]

After "ot=7":
Box 0: [rn 1] [cm 2]
Box 3: [ot 7] [ab 5] [pc 6]
#+end_example

All 256  boxes are  always present;  only the  boxes that  contain any
lenses are shown  here. Within each box, lenses are  listed from front
to back; each  lens is shown as  its label and focal  length in square
brackets.

To confirm that all of the lenses are installed correctly, add up the
focusing power of all of the lenses. The focusing power of a single
lens is the result of multiplying together:
- One plus the box number of the lens in question.
- The slot number of the lens within the box: 1 for the first lens, 2
  for the second lens, and so on.
- The focal length of the lens.

At the end of the above example, the focusing power of each lens is as
follows:
- rn: 1 (box 0) * 1 (first slot) * 1 (focal length) = 1
- cm: 1 (box 0) * 2 (second slot) * 2 (focal length) = 4
- ot: 4 (box 3) * 1 (first slot) * 7 (focal length) = 28
- ab: 4 (box 3) * 2 (second slot) * 5 (focal length) = 40
- pc: 4 (box 3) * 3 (third slot) * 6 (focal length) = 72

So, the above example ends up with a total focusing power of 145.

With the help  of an over-enthusiastic reindeer in a  hard hat, follow
the  initialization  sequence.  What  is the  focusing  power  of  the
resulting lens configuration?
** TODO Day 16.1                                                  :noexport:

With  the beam  of light  completely focused  somewhere, the  reindeer
leads  you deeper  still into  the Lava  Production Facility.  At some
point, you  realize that the  steel facility walls have  been replaced
with cave, and the doorways are just  cave, and the floor is cave, and
you're pretty sure this is actually just a giant cave.

Finally, as you  approach what must be the heart  of the mountain, you
see a bright light in a cavern  up ahead. There, you discover that the
beam of  light you so  carefully focused  is emerging from  the cavern
wall closest  to the  facility and  pouring all of  its energy  into a
contraption on the opposite side.

Upon  closer  inspection,  the  contraption  appears  to  be  a  flat,
two-dimensional square grid containing empty space (.), mirrors (/ and
\), and splitters (| and -).

The contraption is aligned so that most of the beam bounces around the
grid, but each tile on the grid converts some of the beam's light into
heat to melt the rock in the cavern.

You note the layout of the contraption (your puzzle input). For example:

#+begin_example
.|...\....
|.-.\.....
.....|-...
........|.
..........
.........\
..../.\\..
.-.-/..|..
.|....-|.\
..//.|....
#+end_example

The beam  enters in the top-left  corner from the left  and heading to
the right.  Then, its  behavior depends  on what  it encounters  as it
moves:
- If the  beam encounters empty  space (.),  it continues in  the same
  direction.
- If the beam encounters  a mirror (/ or \), the  beam is reflected 90
  degrees  depending on  the  angle  of the  mirror.  For instance,  a
  rightward-moving  beam that  encounters  a /  mirror would  continue
  upward in  the mirror's column,  while a rightward-moving  beam that
  encounters  a \  mirror would  continue downward  from the  mirror's
  column.
- If the beam  encounters the pointy end  of a splitter (|  or -), the
  beam  passes through  the splitter  as  if the  splitter were  empty
  space. For  instance, a  rightward-moving beam  that encounters  a -
  splitter would continue in the same direction.
- If the  beam encounters the  flat side of a  splitter (| or  -), the
  beam is split into two beams going in each of the two directions the
  splitter's   pointy    ends   are   pointing.   For    instance,   a
  rightward-moving beam that encounters a  | splitter would split into
  two beams: one that continues  upward from the splitter's column and
  one that continues downward from the splitter's column.
  
Beams do  not interact with  other beams; a  tile can have  many beams
passing through it at the same time.  A tile is energized if that tile
has at least one beam pass through it, reflect in it, or split in it.

In the above example, here is how the beam of light bounces around the
contraption:

#+begin_example
>|<<<\....
|v-.\^....
.v...|->>>
.v...v^.|.
.v...v^...
.v...v^..\
.v../2\\..
<->-/vv|..
.|<<<2-|.\
.v//.|.v..
#+end_example

Beams are only shown on empty  tiles; arrows indicate the direction of
the beams. If a tile contains beams moving in multiple directions, the
number  of distinct  directions is  shown  instead. Here  is the  same
diagram but  instead only showing whether  a tile is energized  (#) or
not (.):

#+begin_example
######....
.#...#....
.#...#####
.#...##...
.#...##...
.#...##...
.#..####..
########..
.#######..
.#...#.#..
#+end_example

Ultimately, in this example, 46 tiles become energized.

The light isn't energizing enough tiles  to produce lava; to debug the
contraption,   you   need   to   start  by   analyzing   the   current
situation. With the  beam starting in the top-left  heading right, how
many tiles end up being energized?
** TODO Day 16.2                                                  :noexport:

** TODO Day 17.1                                                  :noexport:

The lava starts  flowing rapidly once the Lava  Production Facility is
operational.   As you  leave,  the reindeer  offers  you a  parachute,
allowing you to quickly reach Gear Island.

As you  descend, your bird's-eye view  of Gear Island reveals  why you
had trouble  finding anyone  on your  way up: half  of Gear  Island is
empty, but the half below you is a giant factory city!

You land near  the gradually-filling pool of lava at  the base of your
new lavafall. Lavaducts will eventually  carry the lava throughout the
city, but  to make use  of it immediately,  Elves are loading  it into
large crucibles on wheels.

The crucibles  are top-heavy  and pushed  by hand.  Unfortunately, the
crucibles become very difficult to steer at high speeds, and so it can
be hard to go in a straight line for very long.

To get Desert  Island the machine parts it needs  as soon as possible,
you'll need  to find the  best way to get  the crucible from  the lava
pool to  the machine parts factory.  To do this, you  need to minimize
heat loss while choosing a route  that doesn't require the crucible to
go in a straight line for too long.

Fortunately, the Elves  here have a map (your puzzle  input) that uses
traffic  patterns,   ambient  temperature,   and  hundreds   of  other
parameters to calculate exactly how much heat loss can be expected for
a crucible entering any particular city block.

For example:

#+begin_example
2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533
#+end_example

Each city block is marked by a single digit that represents the amount
of heat  loss if the crucible  enters that block. The  starting point,
the  lava pool,  is  the  top-left city  block;  the destination,  the
machine parts  factory, is the  bottom-right city block.  (Because you
already start in the top-left block, you don't incur that block's heat
loss unless you leave that block and then return to it.)

Because it  is difficult  to keep  the top-heavy  crucible going  in a
straight line  for very long,  it can move at  most three blocks  in a
single direction  before it must  turn 90  degrees left or  right. The
crucible also can't reverse direction; after entering each city block,
it may only turn left, continue straight, or turn right.

One way to minimize heat loss is this path:

#+begin_example
2>>34^>>>1323
32v>>>35v5623
32552456v>>54
3446585845v52
4546657867v>6
14385987984v4
44578769877v6
36378779796v>
465496798688v
456467998645v
12246868655<v
25465488877v5
43226746555v>
#+end_example

This path never  moves more than three consecutive blocks  in the same
direction and incurs a heat loss of only 102.

Directing  the  crucible from  the  lava  pool  to the  machine  parts
factory, but not moving more than three consecutive blocks in the same
direction, what is the least heat loss it can incur?
** TODO Day 17.2                                                  :noexport:

** TODO Day 18.1                                                  :noexport:

Thanks to your efforts, the machine  parts factory is one of the first
factories up  and running  since the lavafall  came back.  However, to
catch up  with the large backlog  of parts requests, the  factory will
also need a large  supply of lava for a while;  the Elves have already
started creating a large lagoon nearby for this purpose.

However, they aren't sure the lagoon will be big enough; they've asked
you to take a look at the dig plan (your puzzle input). For example:

#+begin_example
R 6 (#70c710)
D 5 (#0dc571)
L 2 (#5713f0)
D 2 (#d2c081)
R 2 (#59c680)
D 2 (#411b91)
L 5 (#8ceee2)
U 2 (#caa173)
L 1 (#1b58a2)
U 2 (#caa171)
R 2 (#7807d2)
U 3 (#a77fa3)
L 2 (#015232)
U 2 (#7a21e3)
#+end_example

The digger starts in a 1 meter  cube hole in the ground. They then dig
the specified  number of meters up  (U), down (D), left  (L), or right
(R), clearing full 1 meter cubes  as they go. The directions are given
as seen from above, so if "up" were north, then "right" would be east,
and so on. Each trench is also  listed with the color that the edge of
the trench should be painted as an RGB hexadecimal color code.

When viewed from above, the above example dig plan would result in the
following  loop of  trench  (#)  having been  dug  out from  otherwise
ground-level terrain (.):

#+begin_example
#######
#.....#
###...#
..#...#
..#...#
###.###
#...#..
##..###
.#....#
.######
#+end_example

At  this  point,   the  trench  could  contain  38   cubic  meters  of
lava. However, this is  just the edge of the lagoon;  the next step is
to dig out the interior so that it is one meter deep as well:

#+begin_example
#######
#######
#######
..#####
..#####
#######
#####..
#######
.######
.######
#+end_example

Now, the lagoon can contain a much more respectable 62 cubic meters of
lava.  While the  interior  is dug  out, the  edges  are also  painted
according to the color codes in the dig plan.

The Elves  are concerned  the lagoon  won't be  large enough;  if they
follow their dig plan, how many cubic meters of lava could it hold?
** TODO Day 18.2                                                  :noexport:

** TODO Day 19.1                                                  :noexport:

The Elves of  Gear Island are thankful  for your help and  send you on
your way. They even have a  hang glider that someone stole from Desert
Island; since you're already going  that direction, it would help them
a lot if you would use it to get down there and return it to them.

As you reach the bottom of  the relentless avalanche of machine parts,
you discover  that they're  already forming  a formidable  heap. Don't
worry, though - a group of Elves is already here organizing the parts,
and they have a system.

To start, each part is rated in each of four categories:
- x: Extremely cool looking
- m: Musical (it makes a noise when you hit it)
- a: Aerodynamic
- s: Shiny

Then,  each part  is  sent through  a series  of  workflows that  will
ultimately accept  or reject the  part. Each  workflow has a  name and
contains a list of rules; each rule specifies a condition and where to
send the  part if the condition  is true. The first  rule that matches
the part being  considered is applied immediately, and  the part moves
on to  the destination described by  the rule. (The last  rule in each
workflow has no condition and always applies if reached.)

Consider the workflow ex{x>10:one,m<20:two,a>30:R,A}. This workflow is
named ex  and contains four rules.  If workflow ex were  considering a
specific part, it would perform the following steps in order:
- Rule "x>10:one": If the part's x is more than 10, send the part to
  the workflow named one.
- Rule "m<20:two": Otherwise, if the part's m is less than 20, send
  the part to the workflow named two.
- Rule "a>30:R": Otherwise, if the part's a is more than 30, the part
  is immediately rejected (R).
- Rule "A": Otherwise, because no other rules matched the part, the
  part is immediately accepted (A).

If a part is sent to  another workflow, it immediately switches to the
start  of that  workflow  instead  and never  returns.  If  a part  is
accepted (sent  to A) or  rejected (sent  to R), the  part immediately
stops any further processing.

The system  works, but it's not  keeping up with the  torrent of weird
metal shapes. The Elves ask if you  can help sort a few parts and give
you  the  list  of  workflows  and  some  part  ratings  (your  puzzle
input). For example:

#+begin_example
px{a<2006:qkq,m>2090:A,rfg}
pv{a>1716:R,A}
lnx{m>1548:A,A}
rfg{s<537:gd,x>2440:R,A}
qs{s>3448:A,lnx}
qkq{x<1416:A,crn}
crn{x>2662:A,R}
in{s<1351:px,qqz}
qqz{s>2770:qs,m<1801:hdj,R}
gd{a>3333:R,R}
hdj{m>838:A,pv}

{x=787,m=2655,a=1222,s=2876}
{x=1679,m=44,a=2067,s=496}
{x=2036,m=264,a=79,s=2244}
{x=2461,m=1339,a=466,s=291}
{x=2127,m=1623,a=2188,s=1013}
#+end_example

The workflows  are listed first,  followed by  a blank line,  then the
ratings of the parts the Elves would like you to sort. All parts begin
in the  workflow named in. In  this example, the five  listed parts go
through the following workflows:

#+begin_example
{x=787,m=2655,a=1222,s=2876}: in -> qqz -> qs -> lnx -> A
{x=1679,m=44,a=2067,s=496}: in -> px -> rfg -> gd -> R
{x=2036,m=264,a=79,s=2244}: in -> qqz -> hdj -> pv -> A
{x=2461,m=1339,a=466,s=291}: in -> px -> qkq -> crn -> R
{x=2127,m=1623,a=2188,s=1013}: in -> px -> rfg -> A
#+end_example

Ultimately, three  parts are accepted.  Adding up the  x, m, a,  and s
rating for  each of the  accepted parts gives  7540 for the  part with
x=787,  4623 for  the part  with x=2036,  and 6951  for the  part with
x=2127. Adding all of the ratings  for all of the accepted parts gives
the sum total of 19114.

Sort through all  of the parts you've  been given; what do  you get if
you add together all  of the rating numbers for all  of the parts that
ultimately get accepted?
** TODO Day 19.2                                                  :noexport:

** TODO Day 20.1                                                  :noexport:

With your help, the  Elves manage to find the right  parts and fix all
of the machines.  Now, they just need  to send the command  to boot up
the machines and get the sand flowing again.

The machines  are far apart and  wired together with long  cables. The
cables  don't  connect  to  the   machines  directly,  but  rather  to
communication modules  attached to  the machines that  perform various
initialization tasks and also act as communication relays.

Modules communicate using pulses. Each pulse is either a high pulse or
a low pulse. When a module sends  a pulse, it sends that type of pulse
to each module in its list of destination modules.

There are several different types of modules:

Flip-flop modules (prefix %) are either  on or off; they are initially
off. If  a flip-flop module receives  a high pulse, it  is ignored and
nothing happens. However, if a  flip-flop module receives a low pulse,
it flips between  on and off. If it  was off, it turns on  and sends a
high pulse. If it was on, it turns off and sends a low pulse.

Conjunction modules  (prefix &) remember  the type of the  most recent
pulse  received  from each  of  their  connected input  modules;  they
initially default  to remembering a low  pulse for each input.  When a
pulse is received, the conjunction module first updates its memory for
that input. Then, if it remembers high pulses for all inputs, it sends
a low pulse; otherwise, it sends a high pulse.

There  is  a single  broadcast  module  (named broadcaster).  When  it
receives a  pulse, it sends the  same pulse to all  of its destination
modules.

Here at Desert  Machine Headquarters, there is a module  with a single
button  on it  called, aptly,  the button  module. When  you push  the
button, a single low pulse is sent directly to the broadcaster module.

After pushing  the button, you  must wait  until all pulses  have been
delivered and  fully handled before  pushing it again. Never  push the
button if modules are still processing pulses.

Pulses are always processed in the order they are sent. So, if a pulse
is sent to modules a, b, and  c, and then module a processes its pulse
and sends more pulses,  the pulses sent to modules b  and c would have
to be handled first.

The module  configuration (your puzzle  input) lists each  module. The
name of  the module is preceded  by a symbol identifying  its type, if
any.  The  name is  then  followed  by an  arrow  and  a list  of  its
destination modules. For example:

#+begin_example
broadcaster -> a, b, c
%a -> b
%b -> c
%c -> inv
&inv -> a
#+end_example

In this  module configuration,  the broadcaster has  three destination
modules named a, b, and c. Each of these modules is a flip-flop module
(as indicated  by the  % prefix). a  outputs to b  which outputs  to c
which outputs to another module named inv. inv is a conjunction module
(as indicated by  the & prefix) which, because it  has only one input,
acts like  an inverter  (it sends  the opposite of  the pulse  type it
receives); it outputs to a.

By pushing the button once, the following pulses are sent:

#+begin_example
button -low-> broadcaster
broadcaster -low-> a
broadcaster -low-> b
broadcaster -low-> c
a -high-> b
b -high-> c
c -high-> inv
inv -low-> a
a -low-> b
b -low-> c
c -low-> inv
inv -high-> a
#+end_example

After this sequence, the flip-flop modules  all end up off, so pushing
the button again repeats the same sequence.

Here's a more interesting example:

#+begin_example
broadcaster -> a
%a -> inv, con
&inv -> b
%b -> con
&con -> output
#+end_example

This  module configuration  includes the  broadcaster, two  flip-flops
(named  a  and   b),  a  single-input  conjunction   module  (inv),  a
multi-input  conjunction module  (con),  and an  untyped module  named
output (for testing purposes).  The multi-input conjunction module con
watches the two flip-flop modules and, if they're both on, sends a low
pulse to the output module.

Here's what happens if you push the button once:

#+begin_example
button -low-> broadcaster
broadcaster -low-> a
a -high-> inv
a -high-> con
inv -low-> b
con -high-> output
b -high-> con
con -low-> output
#+end_example

Both flip-flops  turn on and a  low pulse is sent  to output! However,
now that  both flip-flops are on  and con remembers a  high pulse from
each  of  its two  inputs,  pushing  the  button  a second  time  does
something different:

#+begin_example
button -low-> broadcaster
broadcaster -low-> a
a -low-> inv
a -low-> con
inv -high-> b
con -high-> output
#+end_example

Flip-flop a turns  off! Now, con remembers a low  pulse from module a,
and so it sends only a high pulse to output.

Push the button a third time:

#+begin_example
button -low-> broadcaster
broadcaster -low-> a
a -high-> inv
a -high-> con
inv -low-> b
con -low-> output
b -low-> con
con -high-> output
#+end_example

This time, flip-flop a turns on,  then flip-flop b turns off. However,
before b can turn  off, the pulse sent to con is  handled first, so it
briefly remembers all high pulses for its inputs and sends a low pulse
to output.  After that,  flip-flop b  turns off,  which causes  con to
update its state and send a high pulse to output.

Finally, with a on and b off, push the button a fourth time:

#+begin_example
button -low-> broadcaster
broadcaster -low-> a
a -low-> inv
a -low-> con
inv -high-> b
con -high-> output
#+end_example

This completes  the cycle: a turns  off, causing con to  remember only
low pulses and restoring all modules to their original states.

To get  the cables warmed  up, the Elves  have pushed the  button 1000
times. How many pulses got sent as a result (including the pulses sent
by the button itself)?

In the first example, the same  thing happens every time the button is
pushed: 8 low pulses and 4 high pulses are sent. So, after pushing the
button  1000  times,  8000  low   pulses  and  4000  high  pulses  are
sent. Multiplying these together gives 32000000.

In the second  example, after pushing the button 1000  times, 4250 low
pulses  and 2750  high  pulses are  sent.  Multiplying these  together
gives 11687500.

Consult your module configuration; determine  the number of low pulses
and  high pulses  that would  be sent  after pushing  the button  1000
times, waiting for  all pulses to be fully handled  after each push of
the button. What  do you get if  you multiply the total  number of low
pulses sent by the total number of high pulses sent?
** TODO Day 20.2                                                  :noexport:

** TODO Day 21.1                                                  :noexport:

You manage  to catch the airship  right as it's dropping  someone else
off  on  their  all-expenses-paid  trip to  Desert  Island!   It  even
helpfully drops you off near the gardener and his massive farm.

"You got the sand flowing again! Great  work! Now we just need to wait
until we  have enough  sand to  filter the water  for Snow  Island and
we'll have snow again in no time."

While you  wait, one of the  Elves that works with  the gardener heard
how good  you are  at solving  problems and would  like your  help. He
needs to get his steps in for the  day, and so he'd like to know which
garden plots he can reach with exactly his remaining 64 steps.

He gives  you an up-to-date  map (your  puzzle input) of  his starting
position (S), garden plots (.), and rocks (#). For example:

#+begin_example
...........
.....###.#.
.###.##..#.
..#.#...#..
....#.#....
.##..S####.
.##..#...#.
.......##..
.##.#.####.
.##..##.##.
...........
#+end_example

The Elf  starts at the  starting position (S)  which also counts  as a
garden plot. Then,  he can take one step north,  south, east, or west,
but only  onto tiles that  are garden plots.  This would allow  him to
reach any of the tiles marked O:

#+begin_example
...........
.....###.#.
.###.##..#.
..#.#...#..
....#O#....
.##.OS####.
.##..#...#.
.......##..
.##.#.####.
.##..##.##.
...........
#+end_example

Then, he  takes a  second step.  Since at  this point  he could  be at
either tile  marked O, his  second step would  allow him to  reach any
garden plot that is  one step north, south, east, or  west of any tile
that he could have reached after the first step:

#+begin_example
...........
.....###.#.
.###.##..#.
..#.#O..#..
....#.#....
.##O.O####.
.##.O#...#.
.......##..
.##.#.####.
.##..##.##.
...........
#+end_example

After two  steps, he  could be  at any  of the  tiles marked  O above,
including the  starting position (either by  going north-then-south or
by going west-then-east).

A single third step leads to even more possibilities:

#+begin_example
...........
.....###.#.
.###.##..#.
..#.#.O.#..
...O#O#....
.##.OS####.
.##O.#...#.
....O..##..
.##.#.####.
.##..##.##.
...........
#+end_example

He  will continue  like this  until his  steps for  the day  have been
exhausted. After a total of 6 steps,  he could reach any of the garden
plots marked O:

#+begin_example
...........
.....###.#.
.###.##.O#.
.O#O#O.O#..
O.O.#.#.O..
.##O.O####.
.##.O#O..#.
.O.O.O.##..
.##.#.####.
.##O.##.##.
...........
#+end_example

In this  example, if the  Elf's goal was to  get exactly 6  more steps
today, he could use them to reach any of 16 garden plots.

However, the  Elf actually needs  to get 64  steps today, and  the map
he's handed you is much larger than the example map.

Starting from  the garden plot marked  S on your map,  how many garden
plots could the Elf reach in exactly 64 steps?
** TODO Day 21.2                                                  :noexport:

** TODO Day 22.1                                                  :noexport:

Enough sand has fallen; it can finally filter water for Snow Island.

Well, almost.

The sand has been falling as large compacted bricks of sand, piling up
to form  an impressive stack here  near the edge of  Island Island. In
order to make use of the sand to filter water, some of the bricks will
need  to be  broken  apart -  nay, disintegrated  -  back into  freely
flowing sand.

The stack is tall enough that you'll have to be careful about choosing
which bricks  to disintegrate;  if you  disintegrate the  wrong brick,
large  portions  of  the  stack  could  topple,  which  sounds  pretty
dangerous.

The Elves responsible  for water filtering operations  took a snapshot
of the bricks while they were  still falling (your puzzle input) which
should let  you work out  which bricks  are safe to  disintegrate. For
example:

#+begin_example
1,0,1~1,2,1
0,0,2~2,0,2
0,2,3~2,2,3
0,0,4~0,2,4
2,0,5~2,2,5
0,1,6~2,1,6
1,1,8~1,1,9
#+end_example

Each line of text in the  snapshot represents the position of a single
brick at the time the snapshot was taken. The position is given as two
x,y,z coordinates  - one for  each end of the  brick - separated  by a
tilde (~). Each brick  is made up of a single  straight line of cubes,
and the Elves were even careful to choose a time for the snapshot that
had  all of  the free-falling  bricks at  integer positions  above the
ground, so the  whole snapshot is aligned to  a three-dimensional cube
grid.

A line like 2,2,2~2,2,2  means that both ends of the  brick are at the
same coordinate - in other words, that the brick is a single cube.

Lines like  0,0,10~1,0,10 or 0,0,10~0,1,10 both  represent bricks that
are two cubes  in volume, both oriented horizontally.  The first brick
extends in  the x direction, while  the second brick extends  in the y
direction.

A line like 0,0,1~0,0,10 represents a ten-cube brick which is oriented
vertically. One end  of the brick is the cube  located at 0,0,1, while
the other end of the brick is located directly above it at 0,0,10.

The ground is at z=0 and is perfectly flat; the lowest z value a brick
can  have is  therefore 1.  So, 5,5,1~5,6,1  and 0,2,1~0,2,5  are both
resting on  the ground, but  3,3,2~3,3,3 was  above the ground  at the
time of the snapshot.

Because the  snapshot was taken  while the bricks were  still falling,
some bricks will still be in the air; you'll need to start by figuring
out where they  will end up. Bricks are magically  stabilized, so they
never rotate,  even in weird  situations like where a  long horizontal
brick is only supported on one  end. Two bricks cannot occupy the same
position, so  a falling brick will  come to rest upon  the first other
brick it encounters.

Here is  the same  example again,  this time with  each brick  given a
letter so it can be marked in diagrams:

#+begin_example
1,0,1~1,2,1   <- A
0,0,2~2,0,2   <- B
0,2,3~2,2,3   <- C
0,0,4~0,2,4   <- D
2,0,5~2,2,5   <- E
0,1,6~2,1,6   <- F
1,1,8~1,1,9   <- G
#+end_example

At the time of the snapshot, from the side so the x axis goes left to
right, these bricks are arranged like this:

#+begin_example
 x
012
.G. 9
.G. 8
... 7
FFF 6
..E 5 z
D.. 4
CCC 3
BBB 2
.A. 1
--- 0
#+end_example

Rotating the perspective 90 degrees so the y axis now goes left to
right, the same bricks are arranged like this:

#+begin_example
 y
012
.G. 9
.G. 8
... 7
.F. 6
EEE 5 z
DDD 4
..C 3
B.. 2
AAA 1
--- 0
#+end_example

Once all of the bricks fall downward as far as they can go, the stack
looks like this, where ? means bricks are hidden behind other bricks
at that location:

#+begin_example
 x
012
.G. 6
.G. 5
FFF 4
D.E 3 z
??? 2
.A. 1
--- 0
#+end_example

Again from the side:

#+begin_example
 y
012
.G. 6
.G. 5
.F. 4
??? 3 z
B.C 2
AAA 1
--- 0
#+end_example

Now that all of the bricks have settled, it becomes easier to tell
which bricks are supporting which other bricks:
- Brick A is the only brick supporting bricks B and C.
- Brick B is one of two bricks supporting brick D and brick E.
- Brick C is the other brick supporting brick D and brick E.
- Brick D supports brick F.
- Brick E also supports brick F.
- Brick F supports brick G.
- Brick G isn't supporting any bricks.

Your  first  task   is  to  figure  out  which  bricks   are  safe  to
disintegrate. A brick  can be safely disintegrated  if, after removing
it,  no  other bricks  would  fall  further directly  downward.  Don't
actually disintegrate  any bricks -  just determine what  would happen
if, for each brick, only that  brick were disintegrated. Bricks can be
disintegrated even  if they're completely surrounded  by other bricks;
you can squeeze between bricks if you need to.

In this example, the bricks can be disintegrated as follows:
- Brick A cannot be disintegrated safely; if it were disintegrated,
  bricks B and C would both fall.
- Brick B can be disintegrated; the bricks above it (D and E) would
  still be supported by brick C.
- Brick C can be disintegrated; the bricks above it (D and E) would
  still be supported by brick B.
- Brick D can be disintegrated; the brick above it (F) would still be
  supported by brick E.
- Brick E can be disintegrated; the brick above it (F) would still be
  supported by brick D.
- Brick F cannot be disintegrated; the brick above it (G) would fall.
- Brick G can be disintegrated; it does not support any other bricks.

So, in this example, 5 bricks can be safely disintegrated.

Figure how the blocks will settle  based on the snapshot. Once they've
settled, consider disintegrating a single brick; how many bricks could
be safely chosen as the one to get disintegrated?
** TODO Day 22.2                                                  :noexport:

** TODO Day 23.1                                                  :noexport:

The  Elves  resume water  filtering  operations!   Clean water  starts
flowing over the edge of Island Island.

They offer to  help you go over  the edge of Island  Island, too! Just
hold on  tight to  one end  of this impossibly  long rope  and they'll
lower you  down a safe  distance from  the massive waterfall  you just
created.

As you finally reach Snow Island,  you see that the water isn't really
reaching the ground:  it's being absorbed by the air  itself. It looks
like you'll finally  have a little downtime while  the moisture builds
up  to  snow-producing levels.  Snow  Island  is pretty  scenic,  even
without any snow; why not take a walk?

There's  a  map of  nearby  hiking  trails  (your puzzle  input)  that
indicates paths (.), forest (#), and steep slopes (^, >, v, and <).

For example:

#+begin_example
#.#####################
#.......#########...###
#######.#########.#.###
###.....#.>.>.###.#.###
###v#####.#v#.###.#.###
###.>...#.#.#.....#...#
###v###.#.#.#########.#
###...#.#.#.......#...#
#####.#.#.#######.#.###
#.....#.#.#.......#...#
#.#####.#.#.#########v#
#.#...#...#...###...>.#
#.#.#v#######v###.###v#
#...#.>.#...>.>.#.###.#
#####v#.#.###v#.#.###.#
#.....#...#...#.#.#...#
#.#########.###.#.#.###
#...###...#...#...#.###
###.###.#.###v#####v###
#...#...#.#.>.>.#.>.###
#.###.###.#.###.#.#v###
#.....###...###...#...#
#####################.#
#+end_example

You're currently on the single path tile  in the top row; your goal is
to reach the  single path tile in  the bottom row. Because  of all the
mist from  the waterfall, the  slopes are  probably quite icy;  if you
step  onto a  slope tile,  your  next step  must be  downhill (in  the
direction  the arrow  is pointing).  To make  sure you  have the  most
scenic hike possible, never step onto the same tile twice. What is the
longest hike you can take?

In the example above, the longest hike  you can take is marked with O,
and your starting position is marked S:

#+begin_example
#S#####################
#OOOOOOO#########...###
#######O#########.#.###
###OOOOO#OOO>.###.#.###
###O#####O#O#.###.#.###
###OOOOO#O#O#.....#...#
###v###O#O#O#########.#
###...#O#O#OOOOOOO#...#
#####.#O#O#######O#.###
#.....#O#O#OOOOOOO#...#
#.#####O#O#O#########v#
#.#...#OOO#OOO###OOOOO#
#.#.#v#######O###O###O#
#...#.>.#...>OOO#O###O#
#####v#.#.###v#O#O###O#
#.....#...#...#O#O#OOO#
#.#########.###O#O#O###
#...###...#...#OOO#O###
###.###.#.###v#####O###
#...#...#.#.>.>.#.>O###
#.###.###.#.###.#.#O###
#.....###...###...#OOO#
#####################O#
#+end_example

This hike contains 94 steps. (The  other possible hikes you could have
taken were 90, 86, 82, 82, and 74 steps long.)

Find the longest hike you can take through the hiking trails listed on
your map. How many steps long is the longest hike?
** TODO Day 23.2                                                  :noexport:

** TODO Day 24.1                                                  :noexport:

It  seems  like   something  is  going  wrong   with  the  snow-making
process. Instead of forming snow,  the water that's been absorbed into
the air seems to be forming hail!

Maybe there's something you can do to break up the hailstones?

Due to strong,  probably-magical winds, the hailstones  are all flying
through the air  in perfectly linear trajectories. You make  a note of
each  hailstone's  position  and  velocity (your  puzzle  input).  For
example:

#+begin_example
19, 13, 30 @ -2,  1, -2
18, 19, 22 @ -1, -1, -2
20, 25, 34 @ -2, -2, -4
12, 31, 28 @ -1, -2, -1
20, 19, 15 @  1, -5, -3
#+end_example

Each line of text corresponds to the position and velocity of a single
hailstone. The positions  indicate where the hailstones  are right now
(at time 0). The velocities are  constant and indicate exactly how far
each hailstone will move in one nanosecond.

Each line of text  uses the format px py pz @ vx  vy vz. For instance,
the  hailstone specified  by 20,  19, 15  @ 1,  -5, -3  has initial  X
position 20,  Y position 19, Z  position 15, X velocity  1, Y velocity
-5, and Z velocity -3. After one nanosecond, the hailstone would be at
21, 14, 12.

Perhaps you won't  have to do anything. How likely  are the hailstones
to collide with each other and smash into tiny ice crystals?

To  estimate this,  consider  only the  X  and Y  axes;  ignore the  Z
axis. Looking forward in time, how  many of the hailstones' paths will
intersect within a test area? (The hailstones themselves don't have to
collide,  just test  for  intersections between  the  paths they  will
trace.)

In this  example, look for intersections  that happen with an  X and Y
position each at least  7 and at most 27; in  your actual data, you'll
need  to  check a  much  larger  test  area.  Comparing all  pairs  of
hailstones' future paths produces the following results:

#+begin_example
Hailstone A: 19, 13, 30 @ -2, 1, -2
Hailstone B: 18, 19, 22 @ -1, -1, -2
Hailstones' paths will cross inside the test area (at x=14.333, y=15.333).

Hailstone A: 19, 13, 30 @ -2, 1, -2
Hailstone B: 20, 25, 34 @ -2, -2, -4
Hailstones' paths will cross inside the test area (at x=11.667, y=16.667).

Hailstone A: 19, 13, 30 @ -2, 1, -2
Hailstone B: 12, 31, 28 @ -1, -2, -1
Hailstones' paths will cross outside the test area (at x=6.2, y=19.4).

Hailstone A: 19, 13, 30 @ -2, 1, -2
Hailstone B: 20, 19, 15 @ 1, -5, -3
Hailstones' paths crossed in the past for hailstone A.

Hailstone A: 18, 19, 22 @ -1, -1, -2
Hailstone B: 20, 25, 34 @ -2, -2, -4
Hailstones' paths are parallel; they never intersect.

Hailstone A: 18, 19, 22 @ -1, -1, -2
Hailstone B: 12, 31, 28 @ -1, -2, -1
Hailstones' paths will cross outside the test area (at x=-6, y=-5).

Hailstone A: 18, 19, 22 @ -1, -1, -2
Hailstone B: 20, 19, 15 @ 1, -5, -3
Hailstones' paths crossed in the past for both hailstones.

Hailstone A: 20, 25, 34 @ -2, -2, -4
Hailstone B: 12, 31, 28 @ -1, -2, -1
Hailstones' paths will cross outside the test area (at x=-2, y=3).

Hailstone A: 20, 25, 34 @ -2, -2, -4
Hailstone B: 20, 19, 15 @ 1, -5, -3
Hailstones' paths crossed in the past for hailstone B.

Hailstone A: 12, 31, 28 @ -1, -2, -1
Hailstone B: 20, 19, 15 @ 1, -5, -3
Hailstones' paths crossed in the past for both hailstones.
#+end_example

So,  in this  example, 2  hailstones'  future paths  cross inside  the
boundaries of the test area.

However, you'll need to search a much  larger test area if you want to
see  if any  hailstones might  collide.  Look  for intersections  that
happen with an  X and Y position each at  least 200000000000000 and at
most 400000000000000. Disregard the Z axis entirely.

Considering only  the X  and Y  axes, check  all pairs  of hailstones'
future paths for intersections. How  many of these intersections occur
within the test area?
** TODO Day 24.2                                                  :noexport:

** TODO Day 25.1                                                  :noexport:

Still  somehow without  snow, you  go to  the last  place you  haven't
checked: the center of Snow Island, directly below the waterfall.

Here, someone  has clearly been  trying to fix the  problem. Scattered
everywhere are  hundreds of weather machines,  almanacs, communication
modules, hoof prints, machine parts, mirrors, lenses, and so on.

Somehow,   everything  has   been  wired   together  into   a  massive
snow-producing apparatus, but nothing seems to be running. You check a
tiny  screen on  one  of  the communication  modules:  Error 2023.  It
doesn't say what  Error 2023 means, but it does  have the phone number
for a support line printed on it.

"Hi, you've  reached Weather Machines And  So On, Inc. How  can I help
you?" You explain the situation.

"Error 2023, you  say? Why, that's a power overload  error, of course!
It means you have too many  components plugged in. Try unplugging some
components and--"  You explain that  there are hundreds  of components
here and you're in a bit of a hurry.

"Well, let's  see how bad  it is;  do you see  a big red  reset button
somewhere? It should be on its own module. If you push it, it probably
won't fix anything, but it'll report how overloaded things are." After
a minute or two, you find the  reset button; it's so big that it takes
two hands  just to  get enough  leverage to push  it. Its  screen then
displays:

SYSTEM OVERLOAD!

Connected components would require
power equal to at least 100 stars!

"Wait, how many components did you  say are plugged in? With that much
equipment, you could produce snow  for an entire--" You disconnect the
call.

You have  nowhere near that  many stars  - you need  to find a  way to
disconnect  at least  half of  the  equipment here,  but it's  already
Christmas! You only have time to disconnect three wires.

Fortunately, someone  left a wiring  diagram (your puzzle  input) that
shows how the components are connected. For example:

#+begin_example
jqt: rhn xhk nvd
rsh: frs pzl lsr
xhk: hfx
cmg: qnr nvd lhk bvb
rhn: xhk bvb hfx
bvb: xhk hfx
pzl: lsr hfx nvd
qnr: nvd
ntq: jqt hfx bvb xhk
nvd: lhk
lsr: lhk
rzs: qnr cmg lsr rsh
frs: qnr lhk lsr
#+end_example

Each line shows the  name of a component, a colon, and  then a list of
other  components to  which that  component is  connected. Connections
aren't  directional; abc:  xyz and  xyz: abc  both represent  the same
configuration. Each  connection between two components  is represented
only once,  so some components might  only ever appear on  the left or
right side of a colon.

In this example, if you disconnect  the wire between hfx/pzl, the wire
between bvb/cmg,  and the  wire between nvd/jqt,  you will  divide the
components into two separate, disconnected groups:
- 9 components: cmg, frs, lhk, lsr, nvd, pzl, qnr, rsh, and rzs.
- 6 components: bvb, hfx, jqt, ntq, rhn, and xhk.

Multiplying the sizes of these groups together produces 54.

Find the  three wires you  need to disconnect  in order to  divide the
components into two  separate groups. What do you get  if you multiply
the sizes of these two groups together?
** TODO Day 25.2                                                  :noexport:

** Stats                                                          :noexport:

#+CAPTION: https://adventofcode.com/2023/stats
| 25 |  3 | ▉▉▉                                       |
| 24 |  3 | ▉▉▉                                       |
| 23 |  3 | ▉▉▉                                       |
| 22 |  4 | ▉▉▉▉                                      |
| 21 |  4 | ▉▉▉▉                                      |
| 20 |  4 | ▉▉▉▉                                      |
| 19 |  4 | ▉▉▉▉                                      |
| 18 |  5 | ▉▉▉▉▉                                     |
| 17 |  5 | ▉▉▉▉▉                                     |
| 16 |  6 | ▉▉▉▉▉▉                                    |
| 15 |  7 | ▉▉▉▉▉▉▉                                   |
| 14 |  6 | ▉▉▉▉▉▉                                    |
| 13 |  7 | ▉▉▉▉▉▉▉                                   |
| 12 |  7 | ▉▉▉▉▉▉▉                                   |
| 11 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
| 10 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
|  9 | 12 | ▉▉▉▉▉▉▉▉▉▉▉▉                              |
|  8 | 12 | ▉▉▉▉▉▉▉▉▉▉▉▉                              |
|  7 | 12 | ▉▉▉▉▉▉▉▉▉▉▉▉                              |
|  6 | 15 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                           |
|  5 | 16 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                          |
|  4 | 20 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                      |
|  3 | 21 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                     |
|  2 | 28 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉              |
|  1 | 41 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ |
#+TBLFM: $3='(orgtbl-uc-draw-grid $2 0 41 41)
* 2022 [18/50]
** DONE Day 1.1

Santa's reindeer typically eat regular  reindeer food, but they need a
lot  of magical  energy to  deliver presents  on Christmas.  For that,
their favorite snack  is a special type of star  fruit that only grows
deep  in the  jungle.  The  Elves have  brought  you  on their  annual
expedition to the grove where the fruit grows.

To supply  enough magical energy,  the expedition needs to  retrieve a
minimum of fifty stars by December 25th. Although the Elves assure you
that the grove has  plenty of fruit, you decide to  grab any fruit you
see along the way, just in case.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

The jungle must be too overgrown and difficult to navigate in vehicles
or access  from the air;  the Elves' expedition traditionally  goes on
foot. As your boats approach land, the Elves begin taking inventory of
their supplies. One  important consideration is food  - in particular,
the number of Calories each Elf is carrying (your puzzle input).

The Elves take turns writing down  the number of Calories contained by
the various  meals, snacks,  rations, etc.  that they've  brought with
them, one item  per line. Each Elf separates their  own inventory from
the previous Elf's inventory (if any) by a blank line.

For example, suppose the Elves finish writing their items' Calories
and end up with the following list:

#+begin_example
1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
#+end_example

This list represents the Calories of the food carried by five Elves:

- The first Elf is carrying food with 1000, 2000, and 3000 Calories, a
  total of 6000 Calories.
- The second Elf is carrying one food item with 4000 Calories.
- The third Elf is carrying food with 5000 and 6000 Calories, a total
  of 11000 Calories.
- The fourth Elf is carrying food with 7000, 8000, and 9000 Calories,
  a total of 24000 Calories.
- The fifth Elf is carrying one food item with 10000 Calories.

In case the Elves get hungry and  need extra snacks, they need to know
which Elf  to ask:  they'd like  to know how  many Calories  are being
carried by the  Elf carrying the most Calories. In  the example above,
this is 24000 (carried by the fourth Elf).

Find the  Elf carrying the most  Calories. How many total  Calories is
that Elf carrying?

#+begin_src fennel -n :session d2201 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-input [lines]
  (let [res [[]]]
    (each [_ line (ipairs lines)]
      (let [num (tonumber line)]
        (if num
            (table.insert (. res (length res)) num)
            (table.insert res []))))
    res))

(fn solve [input]
  (let [xs (read-input input)]
    (aoc.table-max
     (lume.map xs aoc.table-sum))))

(local test-input
       ["1000" "2000" "3000" ""
        "4000" ""
        "5000" "6000" ""
        "7000" "8000" "9000" ""
        "10000"])

(fn test1 [expected input]
  (assert (= expected (solve input))))

(test1 24000 test-input)

(solve (aoc.string-from "2022/01.inp"))
#+end_src

#+RESULTS:
: 69310

** DONE Day 1.2

By the time  you calculate the answer to the  Elves' question, they've
already realized that the Elf carrying the most Calories of food might
eventually run out of snacks.

To avoid this unacceptable situation,  the Elves would instead like to
know the  total Calories carried by  the top three Elves  carrying the
most  Calories. That  way, even  if  one of  those Elves  runs out  of
snacks, they still have two backups.

In the  example above, the  top three Elves  are the fourth  Elf (with
24000 Calories),  then the third  Elf (with 11000 Calories),  then the
fifth Elf  (with 10000 Calories). The  sum of the Calories  carried by
these three elves is 45000.

Find the top three Elves carrying the most Calories. How many Calories
are those Elves carrying in total?

#+begin_src fennel -n :session d2201 :exports both
(fn solve2 [input]
  (let [xs (read-input input)
        res (lume.map xs aoc.table-sum)]
    (table.sort res #(> $1 $2))
    (aoc.table-sum (aoc.take res 3))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 45000 test-input)

(solve2 (aoc.string-from "2022/01.inp"))
#+end_src

#+RESULTS:
: 206104


** DONE Day 2.1

The Elves begin to set up camp on the beach. To decide whose tent gets
to  be closest  to  the snack  storage, a  giant  Rock Paper  Scissors
tournament is already in progress.

Rock Paper Scissors is a game  between two players. Each game contains
many rounds; in each round, the players each simultaneously choose one
of Rock,  Paper, or Scissors  using a hand  shape. Then, a  winner for
that round is selected: Rock defeats Scissors, Scissors defeats Paper,
and Paper  defeats Rock. If  both players  choose the same  shape, the
round instead ends in a draw.

Appreciative of  your help yesterday,  one Elf gives you  an encrypted
strategy guide (your puzzle input) that  they say will be sure to help
you win. "The first  column is what your opponent is  going to play: A
for  Rock, B  for  Paper, and  C for  Scissors.  The second  column--"
Suddenly, the Elf is called away to help with someone's tent.

The  second column,  you  reason,  must be  what  you  should play  in
response: X for  Rock, Y for Paper, and Z  for Scissors. Winning every
time would  be suspicious, so  the responses must have  been carefully
chosen.

The winner  of the  whole tournament  is the  player with  the highest
score. Your total score is the sum  of your scores for each round. The
score for a  single round is the  score for the shape  you selected (1
for Rock,  2 for  Paper, and 3  for Scissors) plus  the score  for the
outcome of the round (0 if you lost,  3 if the round was a draw, and 6
if you won).

Since you can't be sure if the Elf is trying to help you or trick you,
you should calculate the score you would get if you were to follow the
strategy guide.

For example, suppose you were given the following strategy guide:
#+begin_example
A Y
B X
C Z
#+end_example

This strategy guide predicts and recommends the following:
- In the  first round,  your opponent  will choose  Rock (A),  and you
  should choose Paper (Y). This ends in  a win for you with a score of
  8 (2 because you chose Paper + 6 because you won).
- In the  second round, your opponent  will choose Paper (B),  and you
  should choose Rock (X). This ends in  a loss for you with a score of
  1 (1 + 0).
- The  third round  is a  draw  with both  players choosing  Scissors,
  giving you a score of 3 + 3 = 6.
  
In this example,  if you were to follow the  strategy guide, you would
get a total score of 15 (8 + 1 + 6).

What would your total score be if everything goes exactly according to
your strategy guide?

#+begin_src fennel -n :session d2202 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-input [lines]
  (let [res []]
    (each [_ line (ipairs lines)]
      (table.insert res (aoc.string-split line " ")))
    res))

(fn score [[i j]]
  (let [rock 1
        paper 2
        scissors 3]
    (case [i j]
      [:A :X] (+ rock 3)
      [:A :Y] (+ paper 6)
      [:A :Z] (+ scissors 0)
      [:B :X] (+ rock 0)
      [:B :Y] (+ paper 3)
      [:B :Z] (+ scissors 6)
      [:C :X] (+ rock 6)
      [:C :Y] (+ paper 0)
      [:C :Z] (+ scissors 3))))

(local test-input ["A Y" "B X" "C Z"])

(fn solve [input]
  (-> input
      (read-input)
      (lume.map #(score $))
      (aoc.table-sum)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 15 test-input)

(solve (aoc.string-from "2022/02.inp"))
#+end_src

#+RESULTS:
: 15572

** DONE Day 2.2

The  Elf finishes  helping  with  the tent  and  sneaks  back over  to
you. "Anyway,  the second column  says how the  round needs to  end: X
means you need to  lose, Y means you need to end the  round in a draw,
and Z means you need to win. Good luck!"

The total score is still calculated in  the same way, but now you need
to figure out what shape to choose so the round ends as indicated. The
example above now goes like this:
- In the first round, your opponent will choose Rock (A), and you need
  the round to end in a draw  (Y), so you also choose Rock. This gives
  you a score of 1 + 3 = 4.
- In the  second round, your opponent  will choose Paper (B),  and you
  choose Rock so you lose (X) with a score of 1 + 0 = 1.
- In the  third round, you  will defeat your opponent's  Scissors with
  Rock for a score of 1 + 6 = 7.
  
Now that  you're correctly  decrypting the  ultra top  secret strategy
guide, you would get a total score of 12.

Following the  Elf's instructions  for the  second column,  what would
your  total score  be if  everything  goes exactly  according to  your
strategy guide?

#+begin_src fennel -n :session d2202 :exports both
(fn score2 [[i j]]
  (let [rock 1 paper 2 scissors 3
        win 6 draw 3 loose 0]
    (case [i j]
      [:A :X] (+ scissors loose)
      [:A :Y] (+ rock draw)
      [:A :Z] (+ paper win)
      [:B :X] (+ rock loose)
      [:B :Y] (+ paper draw)
      [:B :Z] (+ scissors win)
      [:C :X] (+ paper loose)
      [:C :Y] (+ scissors draw)
      [:C :Z] (+ rock win))))

(local input2 ["A Y" "B X" "C Z"])

(fn solve2 [input]
  (-> input
      (read-input)
      (lume.map #(score2 $))
      (aoc.table-sum)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 12 input2)

(solve2 (aoc.string-from "2022/02.inp"))
#+end_src

#+RESULTS:
: 16098

** DONE Day 3.1

One Elf  has the important  job of loading  all of the  rucksacks with
supplies for the jungle journey.  Unfortunately, that Elf didn't quite
follow the  packing instructions, and  so a few  items now need  to be
rearranged.

Each rucksack  has two large compartments.  All items of a  given type
are meant to go into exactly one of the two compartments. The Elf that
did the packing  failed to follow this rule for  exactly one item type
per rucksack.

The Elves  have made  a list  of all  of the  items currently  in each
rucksack  (your puzzle  input), but  they need  your help  finding the
errors.  Every  item type  is  identified  by  a single  lowercase  or
uppercase letter (that is, a and A refer to different types of items).

The list of  items for each rucksack  is given as characters  all on a
single line. A  given rucksack always has the same  number of items in
each of  its two  compartments, so  the first  half of  the characters
represent items in the first compartment, while the second half of the
characters represent items in the second compartment.

For example, suppose you have the following list of contents from six
rucksacks:
#+begin_example
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
#+end_example

- The  first  rucksack  contains the  items  vJrwpWtwJgWrhcsFMMfFFhFp,
  which means  its first compartment contains  the items vJrwpWtwJgWr,
  while the  second compartment  contains the items  hcsFMMfFFhFp. The
  only item type that appears in both compartments is lowercase p.
- The  second  rucksack's  compartments contain  jqHRNqRjqzjGDLGL  and
  rsFMfFZSrLrFZsSL.  The   only  item   type  that  appears   in  both
  compartments is uppercase L.
- The third  rucksack's compartments contain PmmdzqPrV  and vPwwTWBwg;
  the only common item type is uppercase P.
- The fourth rucksack's compartments only share item type v.
- The fifth rucksack's compartments only share item type t.
- The sixth rucksack's compartments only share item type s.

To  help  prioritize  item  rearrangement,  every  item  type  can  be
converted to a priority:
- Lowercase item types a through z have priorities 1 through 26.
- Uppercase item types A through Z have priorities 27 through 52.

In the  above example, the priority  of the item type  that appears in
both compartments of each rucksack is 16  (p), 38 (L), 42 (P), 22 (v),
20 (t), and 19 (s); the sum of these is 157.

Find  the  item  type  that  appears  in  both  compartments  of  each
rucksack. What is the sum of the priorities of those item types?

#+begin_src fennel -n :session d2203 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn items-to-codes [line]
  (let [score {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9
               :j 10 :k 11 :l 12 :m 13 :n 14 :o 15 :p 16 :q 17
               :r 18 :s 19 :t 20 :u 21 :v 22 :w 23 :x 24 :y 25
               :z 26 :A 27 :B 28 :C 29 :D 30 :E 31 :F 32 :G 33
               :H 34 :I 35 :J 36 :K 37 :L 38 :M 39 :N 40 :O 41
               :P 42 :Q 43 :R 44 :S 45 :T 46 :U 47 :V 48 :W 49
               :X 50 :Y 51 :Z 52}]
    (lume.map (aoc.string-toarray line) #(. score $))))

(fn priorities [line]
  (let [in2 (items-to-codes line)
        len (length in2)
        in3 (aoc.table-range in2 1 (aoc.int/ len 2))
        in4 (aoc.table-range in2 (+ 1 (aoc.int/ len 2)) len)]
    (lume.unique (lume.filter in3 (fn [e] (aoc.table-contains? in4 e))))))

(local test-input
       ["vJrwpWtwJgWrhcsFMMfFFhFp"
        "jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL"
        "PmmdzqPrVvPwwTWBwg"
        "wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn"
        "ttgJtRGJQctTZtZT"
        "CrZsJsPPZsGzwwsLwLmpwMDw"])

(fn solve [input]
  (aoc.table-sum (lume.map input #(priorities $))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 157 test-input)

(solve (aoc.string-from "2022/03.inp"))
#+end_src

#+RESULTS:
: 8085

** DONE Day 3.2

As you finish  identifying the misplaced items, the Elves  come to you
with another issue.

For safety,  the Elves  are divided  into groups  of three.  Every Elf
carries a  badge that identifies  their group. For  efficiency, within
each group of three Elves, the badge  is the only item type carried by
all three Elves. That is, if a  group's badge is item type B, then all
three Elves will have item type  B somewhere in their rucksack, and at
most two of the Elves will be carrying any other item type.

The  problem  is  that  someone  forgot to  put  this  year's  updated
authenticity  sticker on  the badges.  All of  the badges  need to  be
pulled out  of the rucksacks so  the new authenticity stickers  can be
attached.

Additionally, nobody  wrote down which  item type corresponds  to each
group's badges. The only way to tell  which item type is the right one
is by finding the one item type that is common between all three Elves
in each group.

Every set of  three lines in your list corresponds  to a single group,
but each group can have a different  badge item type. So, in the above
example, the first group's rucksacks are the first three lines:
#+begin_example
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
#+end_example

And the second group's rucksacks are the next three lines:
#+begin_example
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
#+end_example

In  the first  group, the  only item  type that  appears in  all three
rucksacks is  lowercase r; this  must be  their badges. In  the second
group, their badge item type must be Z.

Priorities for these items must still be found to organize the sticker
attachment efforts: here,  they are 18 (r) for the  first group and 52
(Z) for the second group. The sum of these is 70.

Find the  item type that corresponds  to the badges of  each three-Elf
group. What is the sum of the priorities of those item types?

#+begin_src fennel -n :session d2203 :exports both
(fn priorities2 [l1 l2 l3]
  (let [c1 (items-to-codes l1)
        c2 (items-to-codes l2)
        c3 (items-to-codes l3)
        common (lume.filter c2 (fn [e] (aoc.table-contains? c3 e)))]
    (lume.unique (lume.filter c1 (fn [e] (aoc.table-contains? common e))))))

(fn solve2 [input]
  (aoc.table-sum
   (lume.map (aoc.table-group-by input 3)
             #(priorities2 (aoc.table-unpack $)))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 70 test-input)

(solve2 (aoc.string-from "2022/03.inp"))
#+end_src

#+RESULTS:
: 2515

** DONE Day 4.1

Space needs  to be cleared  before the  last supplies can  be unloaded
from the  ships, and so  several Elves have  been assigned the  job of
cleaning  up sections  of the  camp.  Every  section has  a unique  ID
number, and each Elf is assigned a range of section IDs.

However, as some  of the Elves compare their  section assignments with
each other, they've  noticed that many of the  assignments overlap. To
try to quickly  find overlaps and reduce duplicated  effort, the Elves
pair up and make  a big list of the section  assignments for each pair
(your puzzle input).

For example, consider the following list of section assignment pairs:
#+begin_example
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
#+end_example

For the first few pairs, this list means:
- Within the first pair of Elves,  the first Elf was assigned sections
  2-4  (sections 2,  3,  and 4),  while the  second  Elf was  assigned
  sections 6-8 (sections 6, 7, 8).
- The Elves in the second pair were each assigned two sections.
- The Elves in  the third pair were each assigned  three sections: one
  got sections 5, 6, and 7, while the other also got 7, plus 8 and 9.
  
This example list  uses single-digit section IDs to make  it easier to
draw; your actual  list might contain larger  numbers. Visually, these
pairs of section assignments look like this:
#+begin_example
.234.....  2-4
.....678.  6-8

.23......  2-3
...45....  4-5

....567..  5-7
......789  7-9

.2345678.  2-8
..34567..  3-7

.....6...  6-6
...456...  4-6

.23456...  2-6
...45678.  4-8
#+end_example

Some of  the pairs have  noticed that  one of their  assignments fully
contains the  other. For example, 2-8  fully contains 3-7, and  6-6 is
fully contained by  4-6. In pairs where one  assignment fully contains
the other, one Elf in the  pair would be exclusively cleaning sections
their partner will already be cleaning, so these seem like the most in
need of reconsideration. In this example, there are 2 such pairs.

In how many assignment pairs does one range fully contain the other?

#+begin_src fennel -n :session d2204 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn find-subrange [line]
  (let [[elf1 elf2] (aoc.string-split line ",")
        [f1 t1] (aoc.string-split elf1 "-")
        [f2 t2] (aoc.string-split elf2 "-")]
    (or (and (<= (aoc.int f1) (aoc.int f2)) (>= (aoc.int t1) (aoc.int t2)))
        (and (>= (aoc.int f1) (aoc.int f2)) (<= (aoc.int t1) (aoc.int t2))))))

(local test-input
       ["2-4,6-8"
        "2-3,4-5"
        "5-7,7-9"
        "2-8,3-7"
        "6-6,4-6"
        "2-6,4-8"])

(fn solve [input]
  (-> input
      (lume.map find-subrange)
      (lume.count #(not= false $))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 2 test-input)

(solve (aoc.string-from "2022/04.inp"))
#+end_src

#+RESULTS:
: 536

** DONE Day 4.2
It  seems  like  there  is  still   quite  a  bit  of  duplicate  work
planned. Instead,  the Elves would  like to  know the number  of pairs
that overlap at all.

In the above example, the first  two pairs (2-4,6-8 and 2-3,4-5) don't
overlap, while  the remaining  four pairs (5-7,7-9,  2-8,3-7, 6-6,4-6,
and 2-6,4-8) do overlap:
- 5-7,7-9 overlaps in a single section, 7.
- 2-8,3-7 overlaps all of the sections 3 through 7.
- 6-6,4-6 overlaps in a single section, 6.
- 2-6,4-8 overlaps in sections 4, 5, and 6.

So,  in  this example,  the  number  of overlapping  assignment  pairs
is 4. In how many assignment pairs do the ranges overlap?

#+begin_src fennel -n :session d2204 :exports both
(fn overlapping-pairs [line]
  (let [[elf1 elf2] (aoc.string-split line ",")
        [f1 t1] (aoc.string-split elf1 "-")
        [f2 t2] (aoc.string-split elf2 "-")]
    (or (and (<= (aoc.int f1) (aoc.int f2)) (>= (aoc.int t1) (aoc.int f2)))
        (and (<= (aoc.int f1) (aoc.int t2)) (>= (aoc.int t1) (aoc.int t2)))
        (and (<= (aoc.int f2) (aoc.int f1)) (>= (aoc.int t2) (aoc.int f1)))
        (and (<= (aoc.int f2) (aoc.int t1)) (>= (aoc.int t2) (aoc.int t1))))))

(fn solve2 [input]
  (-> input
      (lume.map overlapping-pairs)
      (lume.count #(not= false $))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 4 test-input)

(solve2 (aoc.string-from "2022/04.inp"))
#+end_src

#+RESULTS:
: 845

** DONE Day 5.1

The expedition  can depart  as soon  as the  final supplies  have been
unloaded  from the  ships. Supplies  are  stored in  stacks of  marked
crates, but  because the needed  supplies are buried under  many other
crates, the crates need to be rearranged.

The ship  has a  giant cargo  crane capable  of moving  crates between
stacks. To  ensure none of  the crates get  crushed or fall  over, the
crane operator  will rearrange them  in a series  of carefully-planned
steps. After the crates are rearranged,  the desired crates will be at
the top of each stack.

The  Elves don't  want to  interrupt  the crane  operator during  this
delicate procedure, but they forgot to ask her which crate will end up
where, and they want to be ready to unload them as soon as possible so
they can embark.

They do, however, have a drawing of the starting stacks of crates and
the rearrangement procedure (your puzzle input). For example:
#+begin_example
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
#+end_example

In this  example, there are three  stacks of crates. Stack  1 contains
two crates: crate Z  is on the bottom, and crate N is  on top. Stack 2
contains three crates;  from bottom to top, they are  crates M, C, and
D. Finally, stack 3 contains a single crate, P.

Then,  the rearrangement  procedure  is  given. In  each  step of  the
procedure, a quantity of crates is moved from one stack to a different
stack. In  the first  step of the  above rearrangement  procedure, one
crate  is  moved   from  stack  2  to  stack  1,   resulting  in  this
configuration:
#+begin_example
[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
#+end_example

In  the  second  step,  three  crates   are  moved  from  stack  1  to
stack 3.  Crates are moved  one at  a time, so  the first crate  to be
moved (D) ends up below the second and third crates:

#+begin_example
        [Z]
        [N]
    [C] [D]
    [M] [P]
 1   2   3
#+end_example

Then, both crates are moved from stack 2 to stack 1. Again, because
crates are moved one at a time, crate C ends up below crate M:
#+begin_example
        [Z]
        [N]
[M]     [D]
[C]     [P]
 1   2   3
#+end_example

Finally, one crate is moved from stack 1 to stack 2:
#+begin_example
        [Z]
        [N]
        [D]
[C] [M] [P]
 1   2   3
#+end_example

The Elves  just need to know  which crate will  end up on top  of each
stack; in this example, the top crates are C in stack 1, M in stack 2,
and Z in  stack 3, so you  should combine these together  and give the
Elves the message CMZ.

After the rearrangement procedure completes, what crate ends up on top
of each stack?

#+begin_src fennel -n :session d2205 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(macro times [t body1 & rest-body]
  `(fcollect [i# 1 ,t 1]
     (do ,body1 ,(unpack rest-body))))

(fn test-input []
  (let [crates [["N" "Z"] ["D" "C" "M"] ["P"]]
        moves [[1 2 1] [3 1 3] [2 2 1] [1 1 2]]]
    (each [_ [n f t] (ipairs moves)]
      (times n (aoc.table-move 1 (. crates f) (. crates t))))
    (assert (= "CMZ"
               (aoc.table-tostring (. (aoc.table-transpose crates) 1))))))

(test-input)

(fn scan-crates [lines]
  (let [in (lume.map (aoc.table-range lines 1 8) #(aoc.string-toarray $))
        loc [2 6 10 14 18 22 26 30 34]
        res []]
    (each [i v (ipairs loc)]
      (table.insert res i
                    (lume.filter
                     [(. (. in 1) v) (. (. in 2) v) (. (. in 3) v)
                      (. (. in 4) v) (. (. in 5) v) (. (. in 6) v)
                      (. (. in 7) v) (. (. in 8) v)]
                     #(not= $ " "))))
    res))

(fn scan-moves [lines]
  (lume.map (aoc.table-range lines 11 (length lines))
            #(aoc.string-tonumarray $)))

(fn solve [lines]
  (let [crates (scan-crates lines)
        moves (scan-moves lines)]
    (each [_ [n f t] (ipairs moves)]
      (times n (aoc.table-move 1 (. crates f) (. crates t))))
    (aoc.table-tostring (. (aoc.table-transpose crates) 1))))

(solve (aoc.string-from "2022/05.inp"))
#+end_src

#+RESULTS:
: GFTNRBZPF

** DONE Day 5.2
As you  watch the  crane operator expertly  rearrange the  crates, you
notice the process isn't following your prediction.

Some mud was  covering the writing on  the side of the  crane, and you
quickly  wipe it  away. The  crane isn't  a CrateMover  9000 -  it's a
CrateMover 9001.

The CrateMover 9001 is notable for many new and exciting features: air
conditioning, leather seats,  an extra cup holder, and  the ability to
pick up and move multiple crates at once.

Again  considering the  example above,  the crates  begin in  the same
configuration:
#+begin_example
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 
#+end_example

Moving a  single crate  from stack 2  to stack 1  behaves the  same as
before:
#+begin_example
[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
#+end_example

However, the  action of moving  three crates from  stack 1 to  stack 3
means that those three moved crates  stay in the same order, resulting
in this new configuration:
#+begin_example
        [D]
        [N]
    [C] [Z]
    [M] [P]
 1   2   3
#+end_example

Next, as both  crates are moved from  stack 2 to stack  1, they retain
their order as well:
#+begin_example
        [D]
        [N]
[C]     [Z]
[M]     [P]
 1   2   3
#+end_example

Finally, a single  crate is still moved  from stack 1 to  stack 2, but
now it's crate C that gets moved:
#+begin_example
        [D]
        [N]
        [Z]
[M] [C] [P]
 1   2   3
#+end_example

In this example,  the CrateMover 9001 has put the  crates in a totally
different order: MCD.

Before the  rearrangement process finishes, update  your simulation so
that the Elves know where they should  stand to be ready to unload the
final  supplies. After  the  rearrangement  procedure completes,  what
crate ends up on top of each stack?

#+begin_src fennel -n :session d2205 :exports both
(fn test-input-p2 []
  (let [crates [["N" "Z"] ["D" "C" "M"] ["P"]]
        moves [[1 2 1] [3 1 3] [2 2 1] [1 1 2]]]
    (each [_ [n f t] (ipairs moves)]
      (aoc.table-move 1 (. crates f) (. crates t) n))
    (assert (= "MCD"
               (aoc.table-tostring (. (aoc.table-transpose crates) 1))))))

(test-input-p2)

(fn solve2 [lines]
  (let [crates (scan-crates lines)
        moves (scan-moves lines)]
    (each [_ [n f t] (ipairs moves)]
      (aoc.table-move 1 (. crates f) (. crates t) n))
    (aoc.table-tostring (. (aoc.table-transpose crates) 1))))

(solve2 (aoc.string-from "2022/05.inp"))
#+end_src

#+RESULTS:
: VRQWPDSGP

** DONE Day 6.1
The preparations are finally complete; you and the Elves leave camp on
foot and begin to make your way toward the star fruit grove.

As you move through the dense  undergrowth, one of the Elves gives you
a handheld  device. He says that  it has many fancy  features, but the
most important one to set up right now is the communication system.

However, because  he's heard  you have significant  experience dealing
with signal-based systems, he convinced  the other Elves that it would
be okay  to give you their  one malfunctioning device -  surely you'll
have no problem fixing it.

As if inspired by comedic timing, the device emits a few colorful
sparks.

To be able to communicate with the  Elves, the device needs to lock on
to their signal. The signal is a series of seemingly-random characters
that the device receives one at a time.

To fix the  communication system, you need to add  a subroutine to the
device that detects a start-of-packet marker in the datastream. In the
protocol being used  by the Elves, the start of  a packet is indicated
by a sequence of four characters that are all different.

The device will send your  subroutine a datastream buffer (your puzzle
input); your subroutine needs to identify the first position where the
four     most     recently     received    characters     were     all
different. Specifically, it  needs to report the  number of characters
from  the  beginning of  the  buffer  to the  end  of  the first  such
four-character marker.

For example, suppose you receive the following datastream buffer:

#+begin_example
mjqjpqmgbljsphdztnvjfqwrcgsmlb
#+end_example

After  the first  three  characters (mjq)  have  been received,  there
haven't been  enough characters received  yet to find the  marker. The
first  time a  marker could  occur is  after the  fourth character  is
received, making  the most recent  four characters mjqj. Because  j is
repeated, this isn't a marker.

The  first  time a  marker  appears  is  after the  seventh  character
arrives. Once  it does,  the last four  characters received  are jpqm,
which are all  different. In this case, your  subroutine should report
the  value 7,  because the  first start-of-packet  marker is  complete
after 7 characters have been processed.

Here are a few more examples:

- bvwbjplbgvbhsrlpgdmjqwftvncz: first marker after character 5
- nppdvjthqldpwncqszvftbrmjlhg: first marker after character 6
- nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg: first marker after character 10
- zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw: first marker after character 11

How  many   characters  need   to  be   processed  before   the  first
start-of-packet marker is detected?

#+begin_src fennel -n :session d2206 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn find-packet-marker [pos stream]
  (case (aoc.table-range stream (- pos 3) pos)
    (where [a b c d] (and (not= a b) (not= a c) (not= a d)
                          (not= b c) (not= b d) (not= c d))) pos
    [_a _b _c _d] (find-packet-marker (+ 1 pos) stream)))

(fn solve [input]
  (find-packet-marker 4 (aoc.string-toarray (. input 1))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 7 ["mjqjpqmgbljsphdztnvjfqwrcgsmlb"])
(test 5 ["bvwbjplbgvbhsrlpgdmjqwftvncz"])
(test 6 ["nppdvjthqldpwncqszvftbrmjlhg"])
(test 10 ["nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg"])
(test 11 ["zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw"])

(solve (aoc.string-from "2022/06.inp"))
#+end_src

#+RESULTS:
: 1538

** DONE Day 6.2
Your device's communication system is correctly detecting packets, but
still isn't working. It looks like it also needs to look for messages.

A  start-of-message  marker is  just  like  a start-of-packet  marker,
except it consists of 14 distinct characters rather than 4.

Here are the first positions of start-of-message markers for all of
the above examples:
- mjqjpqmgbljsphdztnvjfqwrcgsmlb: first marker after character 19
- bvwbjplbgvbhsrlpgdmjqwftvncz: first marker after character 23
- nppdvjthqldpwncqszvftbrmjlhg: first marker after character 23
- nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg: first marker after character 29
- zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw: first marker after character 26

How  many   characters  need   to  be   processed  before   the  first
start-of-message marker is detected?

#+begin_src fennel -n :session d2206 :exports both
(fn find-message-marker [pos stream]
  (let [start-message (aoc.table-range stream (- pos 13) pos)]
    (if (= (length start-message)
           (length (lume.unique start-message))) pos
           (find-message-marker (+ 1 pos) stream))))

(fn solve2 [input]
  (find-message-marker 14 (aoc.string-toarray (. input 1))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 19 ["mjqjpqmgbljsphdztnvjfqwrcgsmlb"])
(test2 23 ["bvwbjplbgvbhsrlpgdmjqwftvncz"])
(test2 23 ["nppdvjthqldpwncqszvftbrmjlhg"])
(test2 29 ["nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg"])
(test2 26 ["zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw"])

(solve2 (aoc.string-from "2022/06.inp"))
#+end_src

#+RESULTS:
: 2315


** DONE Day 7.1
You  can hear  birds  chirping  and raindrops  hitting  leaves as  the
expedition  proceeds.  Occasionally,  you  can even  hear much  louder
sounds in the distance; how big do the animals get out here, anyway?

The device  the Elves gave  you has problems  with more than  just its
communication system. You try to run a system update:

#+begin_example
$ system-update --please --pretty-please-with-sugar-on-top
Error: No space left on device
#+end_example

Perhaps you can delete some files to make space for the update?

You browse around the filesystem to  assess the situation and save the
resulting terminal output (your puzzle input). For example:

#+begin_example
$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k
#+end_example

The  filesystem  consists  of  a   tree  of  files  (plain  data)  and
directories  (which  can contain  other  directories  or files).   The
outermost  directory  is  called  /.   You  can  navigate  around  the
filesystem, moving into or out of directories and listing the contents
of the directory you're currently in.

Within the terminal  output, lines that begin with $  are commands you
executed, very much like some modern computers:
- cd  means change  directory.  This changes  which  directory is  the
  current directory, but the specific result depends on the argument:
  - cd x moves in one level: it looks in the current directory for the
    directory named x and makes it the current directory.
  - cd .. moves out one level: it finds the directory that contains
    the current directory, then makes that directory the current
    directory.
  - cd / switches the current directory to the outermost directory, /.
- ls  means list.  It  prints out  all of  the  files and  directories
  immediately contained by the current directory:
  - 123 abc means that the current directory contains a file named abc
    with size 123.
  - dir xyz means that the current directory contains a directory named xyz.

Given the commands and output in  the example above, you can determine
that the filesystem looks visually like this:

#+begin_example
- / (dir)
  - a (dir)
    - e (dir)
      - i (file, size=584)
    - f (file, size=29116)
    - g (file, size=2557)
    - h.lst (file, size=62596)
  - b.txt (file, size=14848514)
  - c.dat (file, size=8504156)
  - d (dir)
    - j (file, size=4060174)
    - d.log (file, size=8033020)
    - d.ext (file, size=5626152)
    - k (file, size=7214296)
#+end_example

Here, there are four directories: / (the outermost directory), a and d
(which  are in  /), and  e  (which is  in a).  These directories  also
contain files of various sizes.

Since the  disk is full,  your first step  should probably be  to find
directories that  are good  candidates for deletion.  To do  this, you
need to determine the total size  of each directory. The total size of
a directory is the sum of the sizes of the files it contains, directly
or  indirectly. (Directories  themselves do  not count  as having  any
intrinsic size.)

The total sizes of the directories above can be found as follows:
- The total size of directory e is 584 because it contains a single
  file i of size 584 and no other directories.
- The directory a has total size 94853 because it contains files f
  (size 29116), g (size 2557), and h.lst (size 62596), plus file i
  indirectly (a contains e which contains i).
- Directory d has total size 24933642.
- As the outermost directory, / contains every file. Its total size is
  48381165, the sum of the size of every file.
  
To begin,  find all of  the directories with a  total size of  at most
100000, then  calculate the sum of  their total sizes. In  the example
above, these directories are a and e;  the sum of their total sizes is
95437 (94853 + 584). (As in this example, this process can count files
more than once!)

Find all of the directories with a total size of at most 100000. What
is the sum of the total sizes of those directories?

#+begin_src fennel -n :session d2207 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn push [xs x]
  (table.insert xs x)
  xs)

(fn pop [xs]
  (table.remove xs (length xs))
  xs)

(fn ncdu [fs pwd s]
  (let [name (table.concat pwd)
        size (tonumber s)]
    (tset fs name
          (+ (or (. fs name) 0) size)))
  (while (not= 0 (length (do (table.remove pwd) pwd)))
    (ncdu fs pwd s)))

(fn read [lines]
  (let [fs {}
        pwd []]
    (each [_ line (ipairs lines)]
      (let [tokens (aoc.string-split line " ")]
        (case tokens
          ["$" "cd" ".."] (pop pwd)
          ["$" "cd" "/"] (push pwd "/")
          ["$" "cd" x] (push pwd (.. x "/"))
          ["$" "ls"] nil
          ["dir" d] nil
          [s n] (ncdu fs (aoc.table-clone pwd) s))))
    fs))

(local test-input
       ["$ cd /"
        "$ ls"
        "dir a"
        "14848514 b.txt"
        "8504156 c.dat"
        "dir d"
        "$ cd a"
        "$ ls"
        "dir e"
        "29116 f"
        "2557 g"
        "62596 h.lst"
        "$ cd e"
        "$ ls"
        "584 i"
        "$ cd .."
        "$ cd .."
        "$ cd d"
        "$ ls"
        "4060174 j"
        "8033020 d.log"
        "5626152 d.ext"
        "7214296 k"])

(fn size [fs s]
  (lume.reduce
   (lume.filter fs
                (fn [x] (<= x s)))
   (fn [a x] (+ a x))))

(fn path [fs p]
  (let [keys (lume.filter (lume.keys fs)
                          (fn [k] (aoc.string-starts-with k p)))]
    (aoc.fold (lume.map keys #(. fs $)))))

(fn solve [input]
  (let [fs (read input)]
    (size fs 100000)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 95437 test-input)

(solve (aoc.string-from "2022/07.inp"))
#+end_src

#+RESULTS:
: 1501149

** DONE Day 7.2
Now, you're ready to choose a directory to delete.

The total disk  space available to the filesystem is  70000000. To run
the update,  you need unused space  of at least 30000000.  You need to
find a directory you can delete that  will free up enough space to run
the update.

In the example  above, the total size of the  outermost directory (and
thus the total amount of used  space) is 48381165; this means that the
size of the unused space must currently be 21618835, which isn't quite
the  30000000 required  by  the update.  Therefore,  the update  still
requires a directory with total size of at least 8381165 to be deleted
before it can run.

To achieve this, you have the following options:
- Delete directory e, which would increase unused space by 584.
- Delete directory a, which would increase unused space by 94853.
- Delete directory d, which would increase unused space by 24933642.
- Delete directory /, which would increase unused space by 48381165.

Directories e and  a are both too small; deleting  them would not free
up enough  space. However, directories  d and  / are both  big enough!
Between  these,  choose  the  smallest:  d,  increasing  unused  space
by 24933642.

Find the  smallest directory  that, if deleted,  would free  up enough
space on the filesystem  to run the update. What is  the total size of
that directory?

#+begin_src fennel -n :session d2207 :exports both
(fn solve2 [input]
  (let [fs (read input)
        required 30000000
        total 70000000
        available (- total (. fs "/"))
        minimum (- required available)]
    (aoc.table-min
     (lume.map
      (lume.filter
       (lume.keys fs)
       (fn [x] (>= (. fs x) minimum)))
      (fn [x] (. fs x))))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 24933642 test-input)

(solve2 (aoc.string-from "2022/07.inp"))
#+end_src

#+RESULTS:
: 10096985

** DONE Day 8.1
The expedition comes across a peculiar patch of tall trees all planted
carefully  in a  grid. The  Elves explain  that a  previous expedition
planted these trees as a reforestation effort. Now, they're curious if
this would be a good location for a tree house.

First, determine  whether there is  enough tree  cover here to  keep a
tree house hidden. To  do this, you need to count  the number of trees
that are visible  from outside the grid when looking  directly along a
row or column.

The Elves have already launched a quadcopter to generate a map with
the height of each tree (your puzzle input). For example:

#+begin_example
30373
25512
65332
33549
35390
#+end_example

Each tree is represented as a  single digit whose value is its height,
where 0 is the shortest and 9 is the tallest.

A tree is visible if all of the  other trees between it and an edge of
the grid are shorter  than it. Only consider trees in  the same row or
column; that  is, only look  up, down, left,  or right from  any given
tree.

All of the trees around the edge  of the grid are visible - since they
are already on the edge, there are no trees to block the view. In this
example, that only leaves the interior nine trees to consider:
- The top-left 5  is visible from the left and  top. (It isn't visible
  from the right  or bottom since other  trees of height 5  are in the
  way.)
- The top-middle 5 is visible from the top and right.
- The top-right  1 is  not visible  from any direction;  for it  to be
  visible, there  would need to only  be trees of height  0 between it
  and an edge.
- The left-middle 5 is visible, but only from the right.
- The  center 3  is  not visible  from  any direction;  for  it to  be
  visible,  there would  need to  be only  trees of  at most  height 2
  between it and an edge.
- The right-middle 3 is visible from the right.
- In the bottom row, the middle 5 is visible, but the 3 and 4 are not.
  
With  16 trees  visible  on the  edge  and another  5  visible in  the
interior, a total of 21 trees are visible in this arrangement.

Consider your map; how many trees are visible from outside the grid?

#+begin_src fennel -n :session d2208 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn find-visible-trees [m]
  (let [res []
        M (aoc.table-transpose m)
        leni (length m)]
    (for [i 1 leni]
      (let [xi (. m i)
            lenj (length xi)]
        (for [j 1 lenj]
          (let [xj (. xi j)
                XI (. M j)
                ltxj (fn [e] (< e xj))]
            (when (or (= 1 i) (= 1 j) (= leni i) (= lenj j)
                      (lume.all (aoc.table-range xi 1 (- j 1)) ltxj)
                      (lume.all (aoc.table-range xi (+ 1 j) lenj) ltxj)
                      (lume.all (aoc.table-range XI 1 (- i 1)) ltxj)
                      (lume.all (aoc.table-range XI (+ 1 i) leni) ltxj))
              (table.insert res (..  i "," j)))))))
    res))

(fn solve [input]
  (let [matrix (aoc.read-matrix input true)
        res (find-visible-trees matrix)]
    (length res)))

(fn test [expected input]
  (assert (= expected (solve input))))

(local test-input
       ["30373"
        "25512"
        "65332"
        "33549"
        "35390"])

(test 21 test-input)

(solve (aoc.string-from "2022/08.inp"))
#+end_src

#+RESULTS:
: 1835

** DONE Day 8.2

Content with the  amount of tree cover available, the  Elves just need
to know the best spot to build their tree house: they would like to be
able to see a lot of trees.

To measure  the viewing  distance from  a given  tree, look  up, down,
left, and right  from that tree; stop  if you reach an edge  or at the
first  tree that  is the  same height  or taller  than the  tree under
consideration. (If a  tree is right on  the edge, at least  one of its
viewing distances will be zero.)

The Elves  don't care about distant  trees taller than those  found by
the rules  above; the proposed tree  house has large eaves  to keep it
dry,  so they  wouldn't be  able  to see  higher than  the tree  house
anyway.

In the example above, consider the middle 5 in the second row:
#+begin_example
30373
25512
65332
33549
35390
#+end_example

- Looking up, its view is not blocked; it can see 1 tree (of height
  3).
- Looking left, its view is blocked immediately; it can see only 1
  tree (of height 5, right next to it).
- Looking right, its view is not blocked; it can see 2 trees.
- Looking down, its view is blocked eventually; it can see 2 trees
  (one of height 3, then the tree of height 5 that blocks its view).
  
A tree's  scenic score  is found by  multiplying together  its viewing
distance in  each of  the four  directions. For this  tree, this  is 4
(found by multiplying 1 * 1 * 2 * 2).

However, you can do even better: consider  the tree of height 5 in the
middle of the fourth row:

#+begin_example
30373
25512
65332
33549
35390
#+end_example

- Looking up, its view is blocked at 2 trees (by another tree with a
  height of 5).
- Looking left, its view is not blocked; it can see 2 trees.
- Looking down, its view is also not blocked; it can see 1 tree.
- Looking right, its view is blocked at 2 trees (by a massive tree of
  height 9).
  
This tree's scenic score is 8 (2 * 2  * 1 * 2); this is the ideal spot
for the tree house.

Consider  each tree  on your  map. What  is the  highest scenic  score
possible for any tree?

#+begin_src fennel -n :session d2208 :exports both
(fn count-trees [xs e]
  (var res 0)
  (for [i 1 (length xs) &until (<= e (. xs i))]
    (set res i))
  (if (< res (length xs)) (+ 1 res)
      res))

(fn find-scenic-score [m]
  (let [res []
        M (aoc.table-transpose m)
        leni (length m)]
    (for [i 1 leni]
      (let [xi (. m i)
            lenj (length xi)]
        (for [j 1 lenj]
          (let [xj (. xi j)
                XI (. M j)
                down (aoc.table-range XI (+ i 1) leni)
                up (aoc.table-reverse (aoc.table-range XI 1 (- i 1)))
                left (aoc.table-reverse (aoc.table-range xi 1 (- j 1)))
                right (aoc.table-range xi (+ j 1) lenj)]
            (let [score (* (count-trees down xj)
                           (count-trees up xj)
                           (count-trees left xj)
                           (count-trees right xj))]
              (when (< 0 score)
                (table.insert res score)))))))
    (aoc.table-max res)))

(fn solve2 [input]
  (let [matrix (aoc.read-matrix input true)]
    (find-scenic-score matrix)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 8 test-input)

(solve2 (aoc.string-from "2022/08.inp"))
#+end_src

#+RESULTS:
: 263670

** DONE Day 9.1

This rope bridge creaks as you walk  along it. You aren't sure how old
it is, or whether it can even support your weight.

It seems  to support the Elves  just fine, though. The  bridge spans a
gorge which was carved out by the massive river far below you.

You step carefully; as you do, the ropes stretch and twist. You decide
to  distract yourself  by modeling  rope physics;  maybe you  can even
figure out where not to step.

Consider a rope with a knot at each end; these knots mark the head and
the tail of the rope. If the head moves far enough away from the tail,
the tail is pulled toward the head.

Due to nebulous reasoning involving Planck lengths, you should be able
to model the  positions of the knots on a  two-dimensional grid. Then,
by following a hypothetical series  of motions (your puzzle input) for
the head, you can determine how the tail will move.

Due  to the  aforementioned Planck  lengths,  the rope  must be  quite
short; in  fact, the  head (H)  and tail (T)  must always  be touching
(diagonally adjacent and even overlapping both count as touching):

#+begin_example
....
.TH.
....

....
.H..
..T.
....

...
.H. (H covers T)
...
#+end_example

If the head is  ever two steps directly up, down,  left, or right from
the tail,  the tail must  also move one step  in that direction  so it
remains close enough:

#+begin_example
.....    .....    .....
.TH.. -> .T.H. -> ..TH.
.....    .....    .....

...    ...    ...
.T.    .T.    ...
.H. -> ... -> .T.
...    .H.    .H.
...    ...    ...
#+end_example

Otherwise, if the head and tail aren't touching and aren't in the same
row or column, the tail always moves one step diagonally to keep up:

#+begin_example
.....    .....    .....
.....    ..H..    ..H..
..H.. -> ..... -> ..T..
.T...    .T...    .....
.....    .....    .....

.....    .....    .....
.....    .....    .....
..H.. -> ...H. -> ..TH.
.T...    .T...    .....
.....    .....    .....
#+end_example

You just need  to work out where  the tail goes as the  head follows a
series of motions. Assume the head and the tail both start at the same
position, overlapping.

For example:

#+begin_example
R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
#+end_example

This series of  motions moves the head right four  steps, then up four
steps, then  left three steps,  then down one  step, and so  on. After
each step, you'll need to update the  position of the tail if the step
means the  head is no  longer adjacent  to the tail.   Visually, these
motions occur as follows (s marks the starting position as a reference
point):

#+begin_example
== Initial State ==

......
......
......
......
H.....  (H covers T, s)

== R 4 ==

......
......
......
......
TH....  (T covers s)

......
......
......
......
sTH...

......
......
......
......
s.TH..

......
......
......
......
s..TH.

== U 4 ==

......
......
......
....H.
s..T..

......
......
....H.
....T.
s.....

......
....H.
....T.
......
s.....

....H.
....T.
......
......
s.....

== L 3 ==

...H..
....T.
......
......
s.....

..HT..
......
......
......
s.....

.HT...
......
......
......
s.....

== D 1 ==

..T...
.H....
......
......
s.....

== R 4 ==

..T...
..H...
......
......
s.....

..T...
...H..
......
......
s.....

......
...TH.
......
......
s.....

......
....TH
......
......
s.....

== D 1 ==

......
....T.
.....H
......
s.....

== L 5 ==

......
....T.
....H.
......
s.....

......
....T.
...H..
......
s.....

......
......
..HT..
......
s.....

......
......
.HT...
......
s.....

......
......
HT....
......
s.....

== R 2 ==

......
......
.H....  (H covers T)
......
s.....

......
......
.TH...
......
s.....
#+end_example

After simulating the  rope, you can count up all  of the positions the
tail  visited at  least  once.  In this  diagram,  s  again marks  the
starting  position (which  the tail  also visited)  and #  marks other
positions the tail visited:

#+begin_example
..##..
...##.
.####.
....#.
s###..
#+end_example

So, there are 13 positions the tail visited at least once.

Simulate  your  complete hypothetical  series  of  motions.  How  many
positions does the tail of the rope visit at least once?

#+begin_src fennel -n :session d2209 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(macro times [t body1 & rest-body]
  `(fcollect [i# 1 ,t 1]
     (do ,body1 ,(unpack rest-body))))

(fn move [{:x Sx :y Sy} [Hx Hy]]
  [(+ Sx Hx) (+ Sy Hy)])

(fn make-move [lines]
  (let [cur {:x 0 :y 0}
        res [[0 0]]]
    (each [_ line (ipairs lines)]
      (let [pos (move cur line)]
        (table.insert res pos)
        (tset cur :x (. pos 1))
        (tset cur :y (. pos 2))))
    res))

(fn read-input [lines]
  (let [path []]
    (each [_ line (ipairs lines)]
      (case (aoc.string-split line " ")
        ["R" dx] (let [ndx (tonumber dx)]
                   (times ndx (table.insert path [1 0])))
        ["U" dy] (let [ndy (tonumber dy)]
                   (times ndy (table.insert path [0 1])))
        ["D" Dy] (let [nDy (tonumber Dy)]
                   (times nDy (table.insert path [0 -1])))
        ["L" Dx] (let [nDx (tonumber Dx)]
                   (times nDx (table.insert path [-1 0])))))
    path))

(fn match-move [moves]
  (let [t {:x 0 :y 0}
        res []]
    (each [_ h (ipairs moves)]
      (when (< 2 (aoc.dist2rd h t))
        (do
          (table.insert res [(. t :x) (. t :y)])
          (tset t :x (+ (. t :x) (math.max -1 (math.min 1 (- (. h 1) (. t :x))))))
          (tset t :y (+ (. t :y) (math.max -1 (math.min 1 (- (. h 2) (. t :y)))))))))
    (table.insert res [(. t :x) (. t :y)])
    res))

(fn solve [input]
  (-> input
      (read-input)
      (make-move)
      (match-move)
      (aoc.table-unique)
      (length)))

(fn test [expected input]
  (assert (= expected (solve input))))

(local test-input
       ["R 4"
        "U 4"
        "L 3"
        "D 1"
        "R 4"
        "D 1"
        "L 5"
        "R 2"])

(test 13 test-input)

(solve (aoc.string-from "2022/09.inp"))
#+end_src

#+RESULTS:
: 6367

** DONE Day 9.2

A rope  snaps! Suddenly, the  river is getting  a lot closer  than you
remember. The bridge is still there,  but some of the ropes that broke
are now whipping toward you as you fall through the air!

The ropes are moving too quickly to  grab; you only have a few seconds
to choose how to arch your  body to avoid being hit. Fortunately, your
simulation can be extended to support longer ropes.

Rather than two knots, you now  must simulate a rope consisting of ten
knots. One knot is  still the head of the rope  and moves according to
the series  of motions. Each  knot further  down the rope  follows the
knot in front of it using the same rules as before.

Using the  same series of motions  as the above example,  but with the
knots marked H, 1, 2, ..., 9, the motions now occur as follows:

#+begin_example
== Initial State ==

......
......
......
......
H.....  (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s)

== R 4 ==

......
......
......
......
1H....  (1 covers 2, 3, 4, 5, 6, 7, 8, 9, s)

......
......
......
......
21H...  (2 covers 3, 4, 5, 6, 7, 8, 9, s)

......
......
......
......
321H..  (3 covers 4, 5, 6, 7, 8, 9, s)

......
......
......
......
4321H.  (4 covers 5, 6, 7, 8, 9, s)

== U 4 ==

......
......
......
....H.
4321..  (4 covers 5, 6, 7, 8, 9, s)

......
......
....H.
.4321.
5.....  (5 covers 6, 7, 8, 9, s)

......
....H.
....1.
.432..
5.....  (5 covers 6, 7, 8, 9, s)

....H.
....1.
..432.
.5....
6.....  (6 covers 7, 8, 9, s)

== L 3 ==

...H..
....1.
..432.
.5....
6.....  (6 covers 7, 8, 9, s)

..H1..
...2..
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

.H1...
...2..
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

== D 1 ==

..1...
.H.2..
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

== R 4 ==

..1...
..H2..
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

..1...
...H..  (H covers 2)
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

......
...1H.  (1 covers 2)
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

......
...21H
..43..
.5....
6.....  (6 covers 7, 8, 9, s)

== D 1 ==

......
...21.
..43.H
.5....
6.....  (6 covers 7, 8, 9, s)

== L 5 ==

......
...21.
..43H.
.5....
6.....  (6 covers 7, 8, 9, s)

......
...21.
..4H..  (H covers 3)
.5....
6.....  (6 covers 7, 8, 9, s)

......
...2..
..H1..  (H covers 4; 1 covers 3)
.5....
6.....  (6 covers 7, 8, 9, s)

......
...2..
.H13..  (1 covers 4)
.5....
6.....  (6 covers 7, 8, 9, s)

......
......
H123..  (2 covers 4)
.5....
6.....  (6 covers 7, 8, 9, s)

== R 2 ==

......
......
.H23..  (H covers 1; 2 covers 4)
.5....
6.....  (6 covers 7, 8, 9, s)

......
......
.1H3..  (H covers 2, 4)
.5....
6.....  (6 covers 7, 8, 9, s)
#+end_example

Now,  you  need to  keep  track  of the  positions  the  new tail,  9,
visits. In this example, the tail never moves, and so it only visits 1
position. However, be careful: more  types of motion are possible than
before, so you  might want to visually compare your  simulated rope to
the one above.

Here's a larger example:

#+begin_example
R 5
U 8
L 8
D 3
R 17
D 10
L 25
U 20
#+end_example

These motions occur as follows (individual steps are not shown):

#+begin_example
== Initial State ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........H..............  (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s)
..........................
..........................
..........................
..........................
..........................

== R 5 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........54321H.........  (5 covers 6, 7, 8, 9, s)
..........................
..........................
..........................
..........................
..........................

== U 8 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
................H.........
................1.........
................2.........
................3.........
...............54.........
..............6...........
.............7............
............8.............
...........9..............  (9 covers s)
..........................
..........................
..........................
..........................
..........................

== L 8 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
........H1234.............
............5.............
............6.............
............7.............
............8.............
............9.............
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== D 3 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
.........2345.............
........1...6.............
........H...7.............
............8.............
............9.............
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== R 17 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
................987654321H
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== D 10 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........s.........98765
.........................4
.........................3
.........................2
.........................1
.........................H

== L 25 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
H123456789................

== U 20 ==

H.........................
1.........................
2.........................
3.........................
4.........................
5.........................
6.........................
7.........................
8.........................
9.........................
..........................
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................
#+end_example

Now, the tail (9) visits 36 positions (including s) at least once:

#+begin_example
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
#.........................
#.............###.........
#............#...#........
.#..........#.....#.......
..#..........#.....#......
...#........#.......#.....
....#......s.........#....
.....#..............#.....
......#............#......
.......#..........#.......
........#........#........
.........########.........
#+end_example

Simulate your complete series of motions on a larger rope with ten
knots. How many positions does the tail of the rope visit at least
once?

#+begin_src fennel -n :session d2209 :exports both
(fn solve2 [input]
  (let [moves (read-input input)
        head (make-move moves)
        T1 (match-move head)
        T2 (match-move T1)
        T3 (match-move T2)
        T4 (match-move T3)
        T5 (match-move T4)
        T6 (match-move T5)
        T7 (match-move T6)
        T8 (match-move T7)]
    (length (aoc.table-unique (match-move T8)))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(local test2-input
       ["R 5"
        "U 8"
        "L 8"
        "D 3"
        "R 17"
        "D 10"
        "L 25"
        "U 20"])

(test2 36 test2-input)

(solve2 (aoc.string-from "2022/09.inp"))
#+end_src

#+RESULTS:
: 2536

** TODO Day 10.1                                                  :noexport:

You avoid the ropes, plunge into the river, and swim to shore.

The Elves yell something about meeting  back up with them upriver, but
the river is too loud to tell exactly what they're saying. They finish
crossing the bridge and disappear from view.

Situations like  this must  be why the  Elves prioritized  getting the
communication system on your handheld  device working. You pull it out
of your pack, but the amount of water slowly draining from a big crack
in its screen tells you it probably won't be of much immediate use.

Unless, that is,  you can design a replacement for  the device's video
system! It seems to be some kind of cathode-ray tube screen and simple
CPU that are both driven by a precise clock circuit. The clock circuit
ticks at a constant rate; each tick is called a cycle.

Start by figuring out the signal being  sent by the CPU. The CPU has a
single register,  X, which starts with  the value 1. It  supports only
two instructions:
- addx V takes two cycles to complete. After two cycles, the X
  register is increased by the value V. (V can be negative.)
- noop takes one cycle to complete. It has no other effect.

The CPU uses  these instructions in a program (your  puzzle input) to,
somehow, tell the screen what to draw.

Consider the following small program:

#+begin_example
noop
addx 3
addx -5
#+end_example

Execution of this program proceeds as follows:
- At  the  start of  the  first  cycle,  the noop  instruction  begins
  execution. During  the first cycle, X  is 1. After the  first cycle,
  the noop instruction finishes execution, doing nothing.
- At the  start of  the second  cycle, the  addx 3  instruction begins
  execution. During the second cycle, X is still 1.
- During the  third cycle, X  is still 1.  After the third  cycle, the
  addx 3 instruction finishes execution, setting X to 4.
- At the  start of the  fourth cycle,  the addx -5  instruction begins
  execution. During the fourth cycle, X is still 4.
- During the  fifth cycle, X  is still 4.  After the fifth  cycle, the
  addx -5 instruction finishes execution, setting X to -1.
  
Maybe  you can  learn  something by  looking  at the  value  of the  X
register throughout  execution. For now, consider  the signal strength
(the cycle  number multiplied by the  value of the X  register) during
the 20th  cycle and every  40 cycles after  that (that is,  during the
20th, 60th, 100th, 140th, 180th, and 220th cycles).

For example, consider this larger program:

#+begin_example
addx 15
addx -11
addx 6
addx -3
addx 5
addx -1
addx -8
addx 13
addx 4
noop
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx -35
addx 1
addx 24
addx -19
addx 1
addx 16
addx -11
noop
noop
addx 21
addx -15
noop
noop
addx -3
addx 9
addx 1
addx -3
addx 8
addx 1
addx 5
noop
noop
noop
noop
noop
addx -36
noop
addx 1
addx 7
noop
noop
noop
addx 2
addx 6
noop
noop
noop
noop
noop
addx 1
noop
noop
addx 7
addx 1
noop
addx -13
addx 13
addx 7
noop
addx 1
addx -33
noop
noop
noop
addx 2
noop
noop
noop
addx 8
noop
addx -1
addx 2
addx 1
noop
addx 17
addx -9
addx 1
addx 1
addx -3
addx 11
noop
noop
addx 1
noop
addx 1
noop
noop
addx -13
addx -19
addx 1
addx 3
addx 26
addx -30
addx 12
addx -1
addx 3
addx 1
noop
noop
noop
addx -9
addx 18
addx 1
addx 2
noop
noop
addx 9
noop
noop
noop
addx -1
addx 2
addx -37
addx 1
addx 3
noop
addx 15
addx -21
addx 22
addx -6
addx 1
noop
addx 2
addx 1
noop
addx -10
noop
noop
addx 20
addx 1
addx 2
addx 2
addx -6
addx -11
noop
noop
noop
#+end_example

The interesting signal strengths can be determined as follows:
- During the  20th cycle, register X  has the value 21,  so the signal
  strength is 20 *  21 = 420. (The 20th cycle occurs  in the middle of
  the  second addx  -1, so  the value  of register  X is  the starting
  value, 1, plus  all of the other  addx values up to that  point: 1 +
  15 - 11 + 6 - 3 + 5 - 1 - 8 + 13 + 4 = 21.)
- During the  60th cycle, register X  has the value 19,  so the signal
  strength is 60 * 19 = 1140.
- During the 100th  cycle, register X has the value  18, so the signal
  strength is 100 * 18 = 1800.
- During the 140th  cycle, register X has the value  21, so the signal
  strength is 140 * 21 = 2940.
- During the 180th  cycle, register X has the value  16, so the signal
  strength is 180 * 16 = 2880.
- During the 220th  cycle, register X has the value  18, so the signal
  strength is 220 * 18 = 3960.
  
The sum of these signal strengths is 13140.

Find the signal  strength during the 20th, 60th,  100th, 140th, 180th,
and 220th cycles. What is the sum of these six signal strengths?
** TODO Day 10.2                                                  :noexport:

** TODO Day 11.1                                                  :noexport:

As you finally start making your way upriver, you realize your pack is
much lighter than you remember. Just  then, one of the items from your
pack goes  flying overhead.  Monkeys  are playing Keep Away  with your
missing things!

To get  your stuff  back, you  need to  be able  to predict  where the
monkeys will  throw your  items. After  some careful  observation, you
realize the  monkeys operate based on  how worried you are  about each
item.

You  take some  notes (your  puzzle input)  on the  items each  monkey
currently has,  how worried  you are  about those  items, and  how the
monkey makes decisions based on your worry level. For example:

#+begin_example
Monkey 0:
  Starting items: 79, 98
  Operation: new = old * 19
  Test: divisible by 23
    If true: throw to monkey 2
    If false: throw to monkey 3

Monkey 1:
  Starting items: 54, 65, 75, 74
  Operation: new = old + 6
  Test: divisible by 19
    If true: throw to monkey 2
    If false: throw to monkey 0

Monkey 2:
  Starting items: 79, 60, 97
  Operation: new = old * old
  Test: divisible by 13
    If true: throw to monkey 1
    If false: throw to monkey 3

Monkey 3:
  Starting items: 74
  Operation: new = old + 3
  Test: divisible by 17
    If true: throw to monkey 0
    If false: throw to monkey 1
#+end_example

Each monkey has several attributes:
- Starting items  lists your worry level  for each item the  monkey is
  currently holding in the order they will be inspected.
- Operation shows how your worry level changes as that monkey inspects
  an item.  (An operation  like new =  old * 5  means that  your worry
  level after  the monkey  inspected the item  is five  times whatever
  your worry level was before inspection.)
  - Test shows how the monkey uses your worry level to decide where to
    throw an item next.
    - If true shows what happens with an item if the Test was true.
    - If false shows what happens with an item if the Test was false.

After each  monkey inspects  an item  but before  it tests  your worry
level, your relief that the monkey's inspection didn't damage the item
causes your worry level to be divided by three and rounded down to the
nearest integer.

The  monkeys take  turns inspecting  and throwing  items. On  a single
monkey's turn, it  inspects and throws all of the  items it is holding
one at  a time  and in  the order  listed. Monkey  0 goes  first, then
monkey 1, and so on until each monkey has had one turn. The process of
each monkey taking a single turn is called a round.

When a monkey throws  an item to another monkey, the  item goes on the
end of the recipient monkey's list.  A monkey that starts a round with
no items could  end up inspecting and throwing many  items by the time
its turn comes around. If a monkey is holding no items at the start of
its turn, its turn ends.

In the above example, the first round proceeds as follows:

#+begin_example
Monkey 0:
  Monkey inspects an item with a worry level of 79.
    Worry level is multiplied by 19 to 1501.
    Monkey gets bored with item. Worry level is divided by 3 to 500.
    Current worry level is not divisible by 23.
    Item with worry level 500 is thrown to monkey 3.
  Monkey inspects an item with a worry level of 98.
    Worry level is multiplied by 19 to 1862.
    Monkey gets bored with item. Worry level is divided by 3 to 620.
    Current worry level is not divisible by 23.
    Item with worry level 620 is thrown to monkey 3.
Monkey 1:
  Monkey inspects an item with a worry level of 54.
    Worry level increases by 6 to 60.
    Monkey gets bored with item. Worry level is divided by 3 to 20.
    Current worry level is not divisible by 19.
    Item with worry level 20 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 65.
    Worry level increases by 6 to 71.
    Monkey gets bored with item. Worry level is divided by 3 to 23.
    Current worry level is not divisible by 19.
    Item with worry level 23 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 75.
    Worry level increases by 6 to 81.
    Monkey gets bored with item. Worry level is divided by 3 to 27.
    Current worry level is not divisible by 19.
    Item with worry level 27 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 74.
    Worry level increases by 6 to 80.
    Monkey gets bored with item. Worry level is divided by 3 to 26.
    Current worry level is not divisible by 19.
    Item with worry level 26 is thrown to monkey 0.
Monkey 2:
  Monkey inspects an item with a worry level of 79.
    Worry level is multiplied by itself to 6241.
    Monkey gets bored with item. Worry level is divided by 3 to 2080.
    Current worry level is divisible by 13.
    Item with worry level 2080 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 60.
    Worry level is multiplied by itself to 3600.
    Monkey gets bored with item. Worry level is divided by 3 to 1200.
    Current worry level is not divisible by 13.
    Item with worry level 1200 is thrown to monkey 3.
  Monkey inspects an item with a worry level of 97.
    Worry level is multiplied by itself to 9409.
    Monkey gets bored with item. Worry level is divided by 3 to 3136.
    Current worry level is not divisible by 13.
    Item with worry level 3136 is thrown to monkey 3.
Monkey 3:
  Monkey inspects an item with a worry level of 74.
    Worry level increases by 3 to 77.
    Monkey gets bored with item. Worry level is divided by 3 to 25.
    Current worry level is not divisible by 17.
    Item with worry level 25 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 500.
    Worry level increases by 3 to 503.
    Monkey gets bored with item. Worry level is divided by 3 to 167.
    Current worry level is not divisible by 17.
    Item with worry level 167 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 620.
    Worry level increases by 3 to 623.
    Monkey gets bored with item. Worry level is divided by 3 to 207.
    Current worry level is not divisible by 17.
    Item with worry level 207 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 1200.
    Worry level increases by 3 to 1203.
    Monkey gets bored with item. Worry level is divided by 3 to 401.
    Current worry level is not divisible by 17.
    Item with worry level 401 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 3136.
    Worry level increases by 3 to 3139.
    Monkey gets bored with item. Worry level is divided by 3 to 1046.
    Current worry level is not divisible by 17.
    Item with worry level 1046 is thrown to monkey 1.
#+end_example

After round 1, the monkeys are holding items with these worry levels:
#+begin_example
Monkey 0: 20, 23, 27, 26
Monkey 1: 2080, 25, 167, 207, 401, 1046
Monkey 2: 
Monkey 3: 
#+end_example

Monkeys 2 and 3 aren't holding any items at the end of the round; they
both inspected  items during the round  and threw them all  before the
round ended.

This process continues for a few more rounds:

After round 2, the monkeys are holding items with these worry levels:
#+begin_example
Monkey 0: 695, 10, 71, 135, 350
Monkey 1: 43, 49, 58, 55, 362
Monkey 2: 
Monkey 3: 
#+end_example

After round 3, the monkeys are holding items with these worry levels:
#+begin_example
Monkey 0: 16, 18, 21, 20, 122
Monkey 1: 1468, 22, 150, 286, 739
Monkey 2: 
Monkey 3: 
#+end_example

After round 4, the monkeys are holding items with these worry levels:
#+begin_example
Monkey 0: 491, 9, 52, 97, 248, 34
Monkey 1: 39, 45, 43, 258
Monkey 2: 
Monkey 3: 
#+end_example

After round 5, the monkeys are holding items with these worry levels:
#+begin_example
Monkey 0: 15, 17, 16, 88, 1037
Monkey 1: 20, 110, 205, 524, 72
Monkey 2: 
Monkey 3: 
#+end_example


After round 6, the monkeys are holding items with these worry levels:
#+begin_example
Monkey 0: 8, 70, 176, 26, 34
Monkey 1: 481, 32, 36, 186, 2190
Monkey 2: 
Monkey 3: 
#+end_example

After round 7, the monkeys are holding items with these worry levels:
#+begin_example
Monkey 0: 162, 12, 14, 64, 732, 17
Monkey 1: 148, 372, 55, 72
Monkey 2: 
Monkey 3: 
#+end_example

After round 8, the monkeys are holding items with these worry levels:
#+begin_example
Monkey 0: 51, 126, 20, 26, 136
Monkey 1: 343, 26, 30, 1546, 36
Monkey 2: 
Monkey 3: 
#+end_example

After round 9, the monkeys are holding items with these worry levels:
#+begin_example
Monkey 0: 116, 10, 12, 517, 14
Monkey 1: 108, 267, 43, 55, 288
Monkey 2: 
Monkey 3: 
#+end_example

After round 10, the monkeys are holding items with these worry levels:
#+begin_example
Monkey 0: 91, 16, 20, 98
Monkey 1: 481, 245, 22, 26, 1092, 30
Monkey 2: 
Monkey 3: 

...

#+end_example

After round 15, the monkeys are holding items with these worry levels:

#+begin_example
Monkey 0: 83, 44, 8, 184, 9, 20, 26, 102
Monkey 1: 110, 36
Monkey 2: 
Monkey 3: 

...

#+end_example

After round 20, the monkeys are holding items with these worry levels:

#+begin_example
Monkey 0: 10, 12, 14, 26, 34
Monkey 1: 245, 93, 53, 199, 115
Monkey 2: 
Monkey 3: 
#+end_example

Chasing all of the monkeys at once is impossible; you're going to have
to  focus on  the two  most active  monkeys if  you want  any hope  of
getting your stuff  back. Count the total number of  times each monkey
inspects items over 20 rounds:

#+begin_example
Monkey 0 inspected items 101 times.
Monkey 1 inspected items 95 times.
Monkey 2 inspected items 7 times.
Monkey 3 inspected items 105 times.
#+end_example

In this example,  the two most active monkeys inspected  items 101 and
105 times. The level of monkey business in this situation can be found
by multiplying these together: 10605.

Figure out  which monkeys  to chase  by counting  how many  items they
inspect over 20 rounds. What is  the level of monkey business after 20
rounds of stuff-slinging simian shenanigans?
** TODO Day 11.2                                                  :noexport:

** TODO Day 12.1                                                  :noexport:

You try contacting the Elves using your handheld device, but the river
you're following must be too low to get a decent signal.

You  ask the  device for  a heightmap  of the  surrounding area  (your
puzzle input).  The heightmap shows  the local area from  above broken
into a grid;  the elevation of each  square of the grid is  given by a
single lowercase  letter, where a  is the  lowest elevation, b  is the
next-lowest, and so on up to the highest elevation, z.

Also included on the heightmap are marks for your current position (S)
and the  location that should  get the  best signal (E).  Your current
position (S)  has elevation a,  and the  location that should  get the
best signal (E) has elevation z.

You'd like to reach E, but to save  energy, you should do it in as few
steps as possible.  During each step, you can move  exactly one square
up, down,  left, or right. To  avoid needing to get  out your climbing
gear,  the elevation  of the  destination square  can be  at most  one
higher than  the elevation of  your current  square; that is,  if your
current elevation  is m,  you could  step to elevation  n, but  not to
elevation o.  (This also means  that the elevation of  the destination
square can be much lower than the elevation of your current square.)

For example:
#+begin_example
Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
#+end_example

Here,  you  start in  the  top-left  corner;  your  goal is  near  the
middle. You could start by moving down or right, but eventually you'll
need to head  toward the e at  the bottom. From there,  you can spiral
around to the goal:

#+begin_example
v..v<<<<
>v.vv<<^
.>vv>E^^
..v>>>^^
..>>>>>^
#+end_example

In the above diagram, the symbols indicate whether the path exits each
square moving up  (^), down (v), left (<), or  right (>). The location
that should  get the  best signal  is still E,  and .  marks unvisited
squares.

This path reaches the goal in 31 steps, the fewest possible.

What is the  fewest steps required to move from  your current position
to the location that should get the best signal?
** TODO Day 12.2                                                  :noexport:

** TODO Day 13.1                                                  :noexport:

You climb  the hill and again  try contacting the Elves.  However, you
instead receive a signal you weren't expecting: a distress signal.

Your handheld device  must still not be working  properly; the packets
from the  distress signal  got decoded  out of  order. You'll  need to
re-order the  list of received  packets (your puzzle input)  to decode
the message.

Your list consists of pairs of packets; pairs are separated by a blank
line. You need to identify how many  pairs of packets are in the right
order.

For example:

#+begin_example
[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[ [8,7,6] ]

[[4,4],4,4]
[[4,4],4,4,4]

[7,7,7,7]
[7,7,7]

[]
[3]

[[[]]]
[[]]

[1,[2,[3,[4,[5,6,7]]]],8,9]
[1,[2,[3,[4,[5,6,0]]]],8,9]
#+end_example

Packet data consists  of lists and integers. Each list  starts with [,
ends with ], and contains  zero or more comma-separated values (either
integers or other lists). Each packet  is always a list and appears on
its own line.

When comparing  two values,  the first  value is  called left  and the
second value is called right. Then:
- If both values are integers, the lower integer should come first. If
  the left integer is lower than  the right integer, the inputs are in
  the  right order.  If  the left  integer is  higher  than the  right
  integer,  the inputs  are not  in  the right  order. Otherwise,  the
  inputs are the same integer; continue  checking the next part of the
  input.
- If both values are lists, compare the first value of each list, then
  the second  value, and  so on. If  the left list  runs out  of items
  first, the inputs are in the right order. If the right list runs out
  of items first, the inputs are not  in the right order. If the lists
  are the  same length and  no comparison  makes a decision  about the
  order, continue checking the next part of the input.
- If exactly  one value is an  integer, convert the integer  to a list
  which  contains that  integer  as  its only  value,  then retry  the
  comparison. For  example, if  comparing [0,0,0]  and 2,  convert the
  right value to  [2] (a list containing 2); the  result is then found
  by instead comparing [0,0,0] and [2].
  
Using these rules, you can determine which of the pairs in the example
are in the right order:
#+begin_example
== Pair 1 ==
- Compare [1,1,3,1,1] vs [1,1,5,1,1]
  - Compare 1 vs 1
  - Compare 1 vs 1
  - Compare 3 vs 5
    - Left side is smaller, so inputs are in the right order

== Pair 2 ==
- Compare [[1],[2,3,4]] vs [[1],4]
  - Compare [1] vs [1]
    - Compare 1 vs 1
  - Compare [2,3,4] vs 4
    - Mixed types; convert right to [4] and retry comparison
    - Compare [2,3,4] vs [4]
      - Compare 2 vs 4
        - Left side is smaller, so inputs are in the right order

== Pair 3 ==
- Compare [9] vs [ [8,7,6] ]
  - Compare 9 vs [8,7,6]
    - Mixed types; convert left to [9] and retry comparison
    - Compare [9] vs [8,7,6]
      - Compare 9 vs 8
        - Right side is smaller, so inputs are not in the right order

== Pair 4 ==
- Compare [[4,4],4,4] vs [[4,4],4,4,4]
  - Compare [4,4] vs [4,4]
    - Compare 4 vs 4
    - Compare 4 vs 4
  - Compare 4 vs 4
  - Compare 4 vs 4
  - Left side ran out of items, so inputs are in the right order

== Pair 5 ==
- Compare [7,7,7,7] vs [7,7,7]
  - Compare 7 vs 7
  - Compare 7 vs 7
  - Compare 7 vs 7
  - Right side ran out of items, so inputs are not in the right order

== Pair 6 ==
- Compare [] vs [3]
  - Left side ran out of items, so inputs are in the right order

== Pair 7 ==
- Compare [[[]]] vs [[]]
  - Compare [[]] vs []
    - Right side ran out of items, so inputs are not in the right order

== Pair 8 ==
- Compare [1,[2,[3,[4,[5,6,7]]]],8,9] vs [1,[2,[3,[4,[5,6,0]]]],8,9]
  - Compare 1 vs 1
  - Compare [2,[3,[4,[5,6,7]]]] vs [2,[3,[4,[5,6,0]]]]
    - Compare 2 vs 2
    - Compare [3,[4,[5,6,7]]] vs [3,[4,[5,6,0]]]
      - Compare 3 vs 3
      - Compare [4,[5,6,7]] vs [4,[5,6,0]]
        - Compare 4 vs 4
        - Compare [5,6,7] vs [5,6,0]
          - Compare 5 vs 5
          - Compare 6 vs 6
          - Compare 7 vs 0
            - Right side is smaller, so inputs are not in the right order

#+end_example

What are the indices of the pairs that are already in the right order?
(The first pair has index 1, the  second pair has index 2, and so on.)
In the above example, the pairs in the right order are 1, 2, 4, and 6;
the sum of these indices is 13.

Determine which pairs of packets are  already in the right order. What
is the sum of the indices of those pairs?

** TODO Day 13.2                                                  :noexport:

** TODO Day 14.1                                                  :noexport:

The distress  signal leads  you to a  giant waterfall!  Actually, hang
on - the signal seems like  it's coming from the waterfall itself, and
that doesn't make any sense. However, you do notice a little path that
leads behind the waterfall.

Correction: the  distress signal leads  you behind a  giant waterfall!
There seems to be a large  cave system here, and the signal definitely
leads further inside.

As you begin to make your  way deeper underground, you feel the ground
rumble for a  moment. Sand begins pouring into the  cave! If you don't
quickly figure out  where the sand is going, you  could quickly become
trapped!

Fortunately,  your  familiarity with  analyzing  the  path of  falling
material will come in handy  here. You scan a two-dimensional vertical
slice of the  cave above you (your puzzle input)  and discover that it
is mostly air with structures made of rock.

Your scan traces the path of each solid rock structure and reports the
x,y coordinates  that form the shape  of the path, where  x represents
distance  to the  right  and  y represents  distance  down. Each  path
appears as a single  line of text in your scan.  After the first point
of each path, each point indicates the end of a straight horizontal or
vertical line to be drawn from the previous point. For example:

#+begin_example
498,4 -> 498,6 -> 496,6
503,4 -> 502,4 -> 502,9 -> 494,9
#+end_example

This  scan means  that there  are two  paths of  rock; the  first path
consists of two straight lines, and  the second path consists of three
straight lines.  (Specifically, the first  path consists of a  line of
rock from  498,4 through  498,6 and  another line  of rock  from 498,6
through 496,6.)

The sand is pouring into the cave from point 500,0.

Drawing rock as #, air as ., and the source of the sand as +, this
becomes:

#+begin_example

  4     5  5
  9     0  0
  4     0  3
0 ......+...
1 ..........
2 ..........
3 ..........
4 ....#...##
5 ....#...#.
6 ..###...#.
7 ........#.
8 ........#.
9 #########.
#+end_example

Sand is produced one unit at a time,  and the next unit of sand is not
produced until the previous unit of sand comes to rest. A unit of sand
is large enough to fill one tile of air in your scan.

A unit  of sand always  falls down one step  if possible. If  the tile
immediately  below is  blocked (by  rock or  sand), the  unit of  sand
attempts to instead move diagonally one  step down and to the left. If
that  tile is  blocked,  the unit  of sand  attempts  to instead  move
diagonally one step  down and to the right. Sand  keeps moving as long
as  it is  able to  do so,  at  each step  trying to  move down,  then
down-left,  then down-right.  If all  three possible  destinations are
blocked, the unit of sand comes to  rest and no longer moves, at which
point the next unit of sand is created back at the source.

So, drawing sand  that has come to  rest as o, the first  unit of sand
simply falls straight down and then stops:

#+begin_example
......+...
..........
..........
..........
....#...##
....#...#.
..###...#.
........#.
......o.#.
#########.
#+end_example

The second unit  of sand then falls straight down,  lands on the first
one, and then comes to rest to its left:

#+begin_example
......+...
..........
..........
..........
....#...##
....#...#.
..###...#.
........#.
.....oo.#.
#########.
#+end_example

After a total of five units of sand have come to rest, they form this
pattern:

#+begin_example
......+...
..........
..........
..........
....#...##
....#...#.
..###...#.
......o.#.
....oooo#.
#########.
#+end_example

After a total of 22 units of sand:

#+begin_example
......+...
..........
......o...
.....ooo..
....#ooo##
....#ooo#.
..###ooo#.
....oooo#.
...ooooo#.
#########.
#+end_example

Finally, only two more units of sand can possibly come to rest:

#+begin_example
......+...
..........
......o...
.....ooo..
....#ooo##
...o#ooo#.
..###ooo#.
....oooo#.
.o.ooooo#.
#########.
#+end_example

Once all 24 units of sand shown above have come to rest, all further
sand flows out the bottom, falling into the endless void. Just for
fun, the path any new sand takes before falling forever is shown here
with ~:

#+begin_example
.......+...
.......~...
......~o...
.....~ooo..
....~#ooo##
...~o#ooo#.
..~###ooo#.
..~..oooo#.
.~o.ooooo#.
~#########.
~..........
~..........
~..........
#+end_example

Using your  scan, simulate the  falling sand.  How many units  of sand
come to rest before sand starts flowing into the abyss below?
** TODO Day 14.2                                                  :noexport:

** TODO Day 15.1                                                  :noexport:

You feel the ground rumble again as the distress signal leads you to a
large network of  subterranean tunnels. You don't have  time to search
them  all,  but  you don't  need  to:  your  pack  contains a  set  of
deployable sensors  that you imagine  were originally built  to locate
lost Elves.

The  sensors aren't  very  powerful, but  that's  okay; your  handheld
device  indicates  that you're  close  enough  to  the source  of  the
distress signal to use them. You  pull the emergency sensor system out
of your pack, hit the big button on top, and the sensors zoom off down
the tunnels.

Once a sensor finds  a spot it thinks will give it  a good reading, it
attaches  itself to  a  hard  surface and  begins  monitoring for  the
nearest  signal source  beacon. Sensors  and beacons  always exist  at
integer  coordinates.  Each sensor  knows  its  own position  and  can
determine the  position of  a beacon  precisely; however,  sensors can
only lock on  to the one beacon  closest to the sensor  as measured by
the Manhattan  distance. (There is never  a tie where two  beacons are
the same distance to a sensor.)

It doesn't  take long for the  sensors to report back  their positions
and closest beacons (your puzzle input). For example:

#+begin_example
Sensor at x=2, y=18: closest beacon is at x=-2, y=15
Sensor at x=9, y=16: closest beacon is at x=10, y=16
Sensor at x=13, y=2: closest beacon is at x=15, y=3
Sensor at x=12, y=14: closest beacon is at x=10, y=16
Sensor at x=10, y=20: closest beacon is at x=10, y=16
Sensor at x=14, y=17: closest beacon is at x=10, y=16
Sensor at x=8, y=7: closest beacon is at x=2, y=10
Sensor at x=2, y=0: closest beacon is at x=2, y=10
Sensor at x=0, y=11: closest beacon is at x=2, y=10
Sensor at x=20, y=14: closest beacon is at x=25, y=17
Sensor at x=17, y=20: closest beacon is at x=21, y=22
Sensor at x=16, y=7: closest beacon is at x=15, y=3
Sensor at x=14, y=3: closest beacon is at x=15, y=3
Sensor at x=20, y=1: closest beacon is at x=15, y=3
#+end_example

So,  consider the  sensor at  2,18;  the closest  beacon to  it is  at
-2,15. For the sensor at 9,16, the closest beacon to it is at 10,16.

Drawing  sensors as  S  and beacons  as B,  the  above arrangement  of
sensors and beacons looks like this:

#+begin_example
               1    1    2    2
     0    5    0    5    0    5
 0 ....S.......................
 1 ......................S.....
 2 ...............S............
 3 ................SB..........
 4 ............................
 5 ............................
 6 ............................
 7 ..........S.......S.........
 8 ............................
 9 ............................
10 ....B.......................
11 ..S.........................
12 ............................
13 ............................
14 ..............S.......S.....
15 B...........................
16 ...........SB...............
17 ................S..........B
18 ....S.......................
19 ............................
20 ............S......S........
21 ............................
22 .......................B....
#+end_example

This isn't necessarily a comprehensive map of all beacons in the area,
though. Because each  sensor only identifies its closest  beacon, if a
sensor detects  a beacon,  you know  there are  no other  beacons that
close or closer to that sensor. There could still be beacons that just
happen to not be the closest beacon to any sensor. Consider the sensor
at 8,7:

#+begin_example
               1    1    2    2
     0    5    0    5    0    5
-2 ..........#.................
-1 .........###................
 0 ....S...#####...............
 1 .......#######........S.....
 2 ......#########S............
 3 .....###########SB..........
 4 ....#############...........
 5 ...###############..........
 6 ..#################.........
 7 .#########S#######S#........
 8 ..#################.........
 9 ...###############..........
10 ....B############...........
11 ..S..###########............
12 ......#########.............
13 .......#######..............
14 ........#####.S.......S.....
15 B........###................
16 ..........#SB...............
17 ................S..........B
18 ....S.......................
19 ............................
20 ............S......S........
21 ............................
22 .......................B....
#+end_example

This sensor's closest beacon is at 2,10,  and so you know there are no
beacons that close or closer (in any positions marked #).

None of the detected beacons seem to be producing the distress signal,
so you'll need to work out where the distress beacon is by working out
where it isn't. For now, keep  things simple by counting the positions
where a beacon cannot possibly be along just a single row.

So, suppose you have an arrangement of beacons and sensors like in the
example above and, just in the row where y=10, you'd like to count the
number of positions a beacon  cannot possibly exist. The coverage from
all sensors near that row looks like this:

#+begin_example
                 1    1    2    2
       0    5    0    5    0    5
 9 ...#########################...
10 ..####B######################..
11 .###S#############.###########.
#+end_example

In this example, in the row where y=10, there are 26 positions where a
beacon cannot be present.

Consult the  report from  the sensors  you just  deployed. In  the row
where y=2000000, how many positions cannot contain a beacon?
** TODO Day 15.2                                                  :noexport:

** TODO Day 16.1                                                  :noexport:

The sensors  have led you  to the origin  of the distress  signal: yet
another  handheld   device,  just   like  the   one  the   Elves  gave
you. However, you  don't see any Elves around; instead,  the device is
surrounded by elephants! They must  have gotten lost in these tunnels,
and one  of the elephants  apparently figured out  how to turn  on the
distress signal.

The ground rumbles  again, much stronger this time. What  kind of cave
is this,  exactly? You  scan the  cave with  your handheld  device; it
reports mostly  igneous rock,  some ash,  pockets of  pressurized gas,
magma... this isn't just a cave, it's a volcano!

You  need to  get  the elephants  out of  here,  quickly. Your  device
estimates that you  have 30 minutes before the volcano  erupts, so you
don't have time to go back out the way you came in.

You scan  the cave for other  options and discover a  network of pipes
and pressure-release  valves. You  aren't sure how  such a  system got
into  a volcano,  but you  don't have  time to  complain; your  device
produces a report (your puzzle input)  of each valve's flow rate if it
were opened (in pressure per minute)  and the tunnels you could use to
move between the valves.

There's even a  valve in the room you and  the elephants are currently
standing in  labeled AA. You estimate  it will take you  one minute to
open a single valve and one minute to follow any tunnel from one valve
to another. What is the most pressure you could release?

For example, suppose you had the following scan output:

#+begin_example
Valve AA has flow rate=0; tunnels lead to valves DD, II, BB
Valve BB has flow rate=13; tunnels lead to valves CC, AA
Valve CC has flow rate=2; tunnels lead to valves DD, BB
Valve DD has flow rate=20; tunnels lead to valves CC, AA, EE
Valve EE has flow rate=3; tunnels lead to valves FF, DD
Valve FF has flow rate=0; tunnels lead to valves EE, GG
Valve GG has flow rate=0; tunnels lead to valves FF, HH
Valve HH has flow rate=22; tunnel leads to valve GG
Valve II has flow rate=0; tunnels lead to valves AA, JJ
Valve JJ has flow rate=21; tunnel leads to valve II
#+end_example

All of the valves begin closed. You  start at valve AA, but it must be
damaged or  jammed or  something: its  flow rate is  0, so  there's no
point in  opening it. However,  you could  spend one minute  moving to
valve  BB  and another  minute  opening  it;  doing so  would  release
pressure during the remaining 28 minutes at a flow rate of 13, a total
eventual pressure release of 28 * 13 = 364. Then, you could spend your
third minute  moving to valve  CC and  your fourth minute  opening it,
providing an additional  26 minutes of eventual pressure  release at a
flow rate of 2, or 52 total pressure released by valve CC.

Making your way through the tunnels like this, you could probably open
many   or  all   of  the   valves  by   the  time   30  minutes   have
elapsed. However, you need to release as much pressure as possible, so
you'll need to be methodical. Instead, consider this approach:

#+begin_example

== Minute 1 ==
No valves are open.
You move to valve DD.

== Minute 2 ==
No valves are open.
You open valve DD.

== Minute 3 ==
Valve DD is open, releasing 20 pressure.
You move to valve CC.

== Minute 4 ==
Valve DD is open, releasing 20 pressure.
You move to valve BB.

== Minute 5 ==
Valve DD is open, releasing 20 pressure.
You open valve BB.

== Minute 6 ==
Valves BB and DD are open, releasing 33 pressure.
You move to valve AA.

== Minute 7 ==
Valves BB and DD are open, releasing 33 pressure.
You move to valve II.

== Minute 8 ==
Valves BB and DD are open, releasing 33 pressure.
You move to valve JJ.

== Minute 9 ==
Valves BB and DD are open, releasing 33 pressure.
You open valve JJ.

== Minute 10 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve II.

== Minute 11 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve AA.

== Minute 12 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve DD.

== Minute 13 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve EE.

== Minute 14 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve FF.

== Minute 15 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve GG.

== Minute 16 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve HH.

== Minute 17 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You open valve HH.

== Minute 18 ==
Valves BB, DD, HH, and JJ are open, releasing 76 pressure.
You move to valve GG.

== Minute 19 ==
Valves BB, DD, HH, and JJ are open, releasing 76 pressure.
You move to valve FF.

== Minute 20 ==
Valves BB, DD, HH, and JJ are open, releasing 76 pressure.
You move to valve EE.

== Minute 21 ==
Valves BB, DD, HH, and JJ are open, releasing 76 pressure.
You open valve EE.

== Minute 22 ==
Valves BB, DD, EE, HH, and JJ are open, releasing 79 pressure.
You move to valve DD.

== Minute 23 ==
Valves BB, DD, EE, HH, and JJ are open, releasing 79 pressure.
You move to valve CC.

== Minute 24 ==
Valves BB, DD, EE, HH, and JJ are open, releasing 79 pressure.
You open valve CC.

== Minute 25 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.

== Minute 26 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.

== Minute 27 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.

== Minute 28 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.

== Minute 29 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.

== Minute 30 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.
#+end_example

This approach lets you release the most pressure possible in 30
minutes with this valve layout, 1651.

Work out the steps to release the most pressure in 30 minutes. What is
the most pressure you can release?
** TODO Day 16.2                                                  :noexport:

** TODO Day 17.1                                                  :noexport:

Your handheld device has located an alternative exit from the cave for
you and the elephants. The ground is rumbling almost continuously now,
but the strange valves bought  you some time.  It's definitely getting
warmer in here, though.

The tunnels eventually  open into a very tall,  narrow chamber. Large,
oddly-shaped rocks are falling into the chamber from above, presumably
due to all  the rumbling. If you  can't work out where  the rocks will
fall next, you might be crushed!

The five types of rocks have the following peculiar shapes, where # is
rock and . is empty space:

#+begin_example
####

.#.
###
.#.

..#
..#
###

#
#
#
#

##
##
#+end_example

The rocks fall in the order shown above: first the - shape, then the +
shape, and so on. Once the end  of the list is reached, the same order
repeats: the - shape falls first, sixth, 11th, 16th, etc.

The rocks don't spin, but they do get pushed around by jets of hot gas
coming out  of the walls themselves.  A quick scan reveals  the effect
the jets of hot  gas will have on the rocks as  they fall (your puzzle
input).

For example, suppose this was the jet pattern in your cave:

#+begin_example
>>><<><>><<<>><>>><<<>>><<<><<<>><>><<>>
#+end_example

In jet patterns, <  means a push to the left, while >  means a push to
the right. The  pattern above means that the jets  will push a falling
rock right, then right, then right,  then left, then left, then right,
and so on. If the end of the list is reached, it repeats.

The  tall, vertical  chamber is  exactly seven  units wide.  Each rock
appears so that its left edge is two units away from the left wall and
its bottom edge is three units above  the highest rock in the room (or
the floor, if there isn't one).

After a rock  appears, it alternates between being pushed  by a jet of
hot gas one unit (in the direction indicated by the next symbol in the
jet pattern)  and then falling  one unit  down. If any  movement would
cause any part of the rock to move into the walls, floor, or a stopped
rock,  the movement  instead does  not occur.  If a  downward movement
would  have  caused a  falling  rock  to move  into  the  floor or  an
already-fallen rock, the falling rock stops where it is (having landed
on something) and a new rock immediately begins falling.

Drawing falling rocks with @ and stopped rocks with #, the jet pattern
in the example above manifests as follows:

The first rock begins falling:

#+begin_example
|..@@@@.|
|.......|
|.......|
|.......|
+-------+
#+end_example

Jet of gas pushes rock right:

#+begin_example
|...@@@@|
|.......|
|.......|
|.......|
+-------+
#+end_example

Rock falls 1 unit:

#+begin_example
|...@@@@|
|.......|
|.......|
+-------+
#+end_example

Jet of gas pushes rock right, but nothing happens:

#+begin_example
|...@@@@|
|.......|
|.......|
+-------+
#+end_example

Rock falls 1 unit:

#+begin_example
|...@@@@|
|.......|
+-------+
#+end_example

Jet of gas pushes rock right, but nothing happens:

#+begin_example
|...@@@@|
|.......|
+-------+
#+end_example

Rock falls 1 unit:

#+begin_example
|...@@@@|
+-------+
#+end_example

Jet of gas pushes rock left:

#+begin_example
|..@@@@.|
+-------+
#+end_example

Rock falls 1 unit, causing it to come to rest:

#+begin_example
|..####.|
+-------+
#+end_example

A new rock begins falling:

#+begin_example
|...@...|
|..@@@..|
|...@...|
|.......|
|.......|
|.......|
|..####.|
+-------+
#+end_example

Jet of gas pushes rock left:

#+begin_example
|..@....|
|.@@@...|
|..@....|
|.......|
|.......|
|.......|
|..####.|
+-------+
#+end_example

Rock falls 1 unit:

#+begin_example
|..@....|
|.@@@...|
|..@....|
|.......|
|.......|
|..####.|
+-------+
#+end_example

Jet of gas pushes rock right:

#+begin_example
|...@...|
|..@@@..|
|...@...|
|.......|
|.......|
|..####.|
+-------+
#+end_example

Rock falls 1 unit:

#+begin_example
|...@...|
|..@@@..|
|...@...|
|.......|
|..####.|
+-------+
#+end_example

Jet of gas pushes rock left:
#+begin_example
|..@....|
|.@@@...|
|..@....|
|.......|
|..####.|
+-------+
#+end_example

Rock falls 1 unit:

#+begin_example
|..@....|
|.@@@...|
|..@....|
|..####.|
+-------+
#+end_example

Jet of gas pushes rock right:

#+begin_example
|...@...|
|..@@@..|
|...@...|
|..####.|
+-------+
#+end_example

Rock falls 1 unit, causing it to come to rest:

#+begin_example
|...#...|
|..###..|
|...#...|
|..####.|
+-------+
#+end_example

A new rock begins falling:

#+begin_example
|....@..|
|....@..|
|..@@@..|
|.......|
|.......|
|.......|
|...#...|
|..###..|
|...#...|
|..####.|
+-------+
#+end_example

The moment each of the next few rocks begins falling, you would see
this:

#+begin_example
|..@....|
|..@....|
|..@....|
|..@....|
|.......|
|.......|
|.......|
|..#....|
|..#....|
|####...|
|..###..|
|...#...|
|..####.|
+-------+

|..@@...|
|..@@...|
|.......|
|.......|
|.......|
|....#..|
|..#.#..|
|..#.#..|
|#####..|
|..###..|
|...#...|
|..####.|
+-------+

|..@@@@.|
|.......|
|.......|
|.......|
|....##.|
|....##.|
|....#..|
|..#.#..|
|..#.#..|
|#####..|
|..###..|
|...#...|
|..####.|
+-------+

|...@...|
|..@@@..|
|...@...|
|.......|
|.......|
|.......|
|.####..|
|....##.|
|....##.|
|....#..|
|..#.#..|
|..#.#..|
|#####..|
|..###..|
|...#...|
|..####.|
+-------+

|....@..|
|....@..|
|..@@@..|
|.......|
|.......|
|.......|
|..#....|
|.###...|
|..#....|
|.####..|
|....##.|
|....##.|
|....#..|
|..#.#..|
|..#.#..|
|#####..|
|..###..|
|...#...|
|..####.|
+-------+

|..@....|
|..@....|
|..@....|
|..@....|
|.......|
|.......|
|.......|
|.....#.|
|.....#.|
|..####.|
|.###...|
|..#....|
|.####..|
|....##.|
|....##.|
|....#..|
|..#.#..|
|..#.#..|
|#####..|
|..###..|
|...#...|
|..####.|
+-------+

|..@@...|
|..@@...|
|.......|
|.......|
|.......|
|....#..|
|....#..|
|....##.|
|....##.|
|..####.|
|.###...|
|..#....|
|.####..|
|....##.|
|....##.|
|....#..|
|..#.#..|
|..#.#..|
|#####..|
|..###..|
|...#...|
|..####.|
+-------+

|..@@@@.|
|.......|
|.......|
|.......|
|....#..|
|....#..|
|....##.|
|##..##.|
|######.|
|.###...|
|..#....|
|.####..|
|....##.|
|....##.|
|....#..|
|..#.#..|
|..#.#..|
|#####..|
|..###..|
|...#...|
|..####.|
+-------+
#+end_example

To prove  to the elephants your  simulation is accurate, they  want to
know how  tall the tower will  get after 2022 rocks  have stopped (but
before the 2023rd rock begins falling).  In this example, the tower of
rocks will be 3068 units tall.

How many units tall  will the tower of rocks be  after 2022 rocks have
stopped falling?
** TODO Day 17.2                                                  :noexport:

** TODO Day 18.1                                                  :noexport:

You and the elephants finally reach fresh air. You've emerged near the
base  of  a  large  volcano   that  seems  to  be  actively  erupting!
Fortunately, the lava seems to be flowing away from you and toward the
ocean.

Bits of lava are still being  ejected toward you, so you're sheltering
in the cavern exit a little longer.  Outside the cave, you can see the
lava landing in a pond and hear it loudly hissing as it solidifies.

Depending on the specific compounds in  the lava and speed at which it
cools, it might be forming obsidian!  The cooling rate should be based
on the surface area of the lava  droplets, so you take a quick scan of
a droplet as it flies past you (your puzzle input).

Because of how  quickly the lava is moving, the  scan isn't very good;
its resolution  is quite  low and,  as a  result, it  approximates the
shape of the lava droplet with 1x1x1 cubes on a 3D grid, each given as
its x,y,z position.

To approximate  the surface area,  count the  number of sides  of each
cube that are  not immediately connected to another cube.  So, if your
scan were  only two  adjacent cubes  like 1,1,1  and 2,1,1,  each cube
would  have a  single side  covered and  five sides  exposed, a  total
surface area of 10 sides.

Here's a larger example:

#+begin_example
2,2,2
1,2,2
3,2,2
2,1,2
2,3,2
2,2,1
2,2,3
2,2,4
2,2,6
1,2,5
3,2,5
2,1,5
2,3,5
#+end_example

In the  above example,  after counting  up all  the sides  that aren't
connected to another cube, the total surface area is 64.

What is the surface area of your scanned lava droplet?
** TODO Day 18.2                                                  :noexport:

** TODO Day 19.1                                                  :noexport:

Your scans show that the lava did indeed form obsidian!

The wind  has changed direction  enough to stop sending  lava droplets
toward you,  so you and  the elephants exit the  cave. As you  do, you
notice a collection  of geodes around the pond. Perhaps  you could use
the obsidian to create some geode-cracking robots and break them open?

To  collect the  obsidian from  the bottom  of the  pond, you'll  need
waterproof  obsidian-collecting  robots.   Fortunately,  there  is  an
abundant  amount  of  clay  nearby  that you  can  use  to  make  them
waterproof.

In   order  to   harvest   the  clay,   you'll  need   special-purpose
clay-collecting robots.  To make any  type of robot, you'll  need ore,
which is also plentiful but in the opposite direction from the clay.

Collecting    ore   requires    ore-collecting    robots   with    big
drills. Fortunately, you have exactly one ore-collecting robot in your
pack that you can use to kickstart the whole operation.

Each robot  can collect  1 of  its resource type  per minute.  It also
takes one  minute for the  robot factory (also conveniently  from your
pack)  to  construct any  type  of  robot,  although it  consumes  the
necessary resources available when construction begins.

The  robot factory  has many  blueprints (your  puzzle input)  you can
choose from, but once you've configured it with a blueprint, you can't
change it. You'll need to work out which blueprint is best.

For example:

#+begin_example
Blueprint 1:
  Each ore robot costs 4 ore.
  Each clay robot costs 2 ore.
  Each obsidian robot costs 3 ore and 14 clay.
  Each geode robot costs 2 ore and 7 obsidian.

Blueprint 2:
  Each ore robot costs 2 ore.
  Each clay robot costs 3 ore.
  Each obsidian robot costs 3 ore and 8 clay.
  Each geode robot costs 3 ore and 12 obsidian.
#+end_example

(Blueprints  have been  line-wrapped  here for  legibility. The  robot
factory's actual  assortment of blueprints are  provided one blueprint
per line.)

The elephants are  starting to look hungry, so you  shouldn't take too
long; you need to figure out which blueprint would maximize the number
of opened  geodes after  24 minutes  by figuring  out which  robots to
build and when to build them.

Using blueprint 1  in the example above, the largest  number of geodes
you could open in 24 minutes is 9. One way to achieve that is:

#+begin_example
== Minute 1 ==
1 ore-collecting robot collects 1 ore; you now have 1 ore.

== Minute 2 ==
1 ore-collecting robot collects 1 ore; you now have 2 ore.

== Minute 3 ==
Spend 2 ore to start building a clay-collecting robot.
1 ore-collecting robot collects 1 ore; you now have 1 ore.
The new clay-collecting robot is ready; you now have 1 of them.

== Minute 4 ==
1 ore-collecting robot collects 1 ore; you now have 2 ore.
1 clay-collecting robot collects 1 clay; you now have 1 clay.

== Minute 5 ==
Spend 2 ore to start building a clay-collecting robot.
1 ore-collecting robot collects 1 ore; you now have 1 ore.
1 clay-collecting robot collects 1 clay; you now have 2 clay.
The new clay-collecting robot is ready; you now have 2 of them.

== Minute 6 ==
1 ore-collecting robot collects 1 ore; you now have 2 ore.
2 clay-collecting robots collect 2 clay; you now have 4 clay.

== Minute 7 ==
Spend 2 ore to start building a clay-collecting robot.
1 ore-collecting robot collects 1 ore; you now have 1 ore.
2 clay-collecting robots collect 2 clay; you now have 6 clay.
The new clay-collecting robot is ready; you now have 3 of them.

== Minute 8 ==
1 ore-collecting robot collects 1 ore; you now have 2 ore.
3 clay-collecting robots collect 3 clay; you now have 9 clay.

== Minute 9 ==
1 ore-collecting robot collects 1 ore; you now have 3 ore.
3 clay-collecting robots collect 3 clay; you now have 12 clay.

== Minute 10 ==
1 ore-collecting robot collects 1 ore; you now have 4 ore.
3 clay-collecting robots collect 3 clay; you now have 15 clay.

== Minute 11 ==
Spend 3 ore and 14 clay to start building an obsidian-collecting robot.
1 ore-collecting robot collects 1 ore; you now have 2 ore.
3 clay-collecting robots collect 3 clay; you now have 4 clay.
The new obsidian-collecting robot is ready; you now have 1 of them.

== Minute 12 ==
Spend 2 ore to start building a clay-collecting robot.
1 ore-collecting robot collects 1 ore; you now have 1 ore.
3 clay-collecting robots collect 3 clay; you now have 7 clay.
1 obsidian-collecting robot collects 1 obsidian; you now have 1 obsidian.
The new clay-collecting robot is ready; you now have 4 of them.

== Minute 13 ==
1 ore-collecting robot collects 1 ore; you now have 2 ore.
4 clay-collecting robots collect 4 clay; you now have 11 clay.
1 obsidian-collecting robot collects 1 obsidian; you now have 2 obsidian.

== Minute 14 ==
1 ore-collecting robot collects 1 ore; you now have 3 ore.
4 clay-collecting robots collect 4 clay; you now have 15 clay.
1 obsidian-collecting robot collects 1 obsidian; you now have 3 obsidian.

== Minute 15 ==
Spend 3 ore and 14 clay to start building an obsidian-collecting robot.
1 ore-collecting robot collects 1 ore; you now have 1 ore.
4 clay-collecting robots collect 4 clay; you now have 5 clay.
1 obsidian-collecting robot collects 1 obsidian; you now have 4 obsidian.
The new obsidian-collecting robot is ready; you now have 2 of them.

== Minute 16 ==
1 ore-collecting robot collects 1 ore; you now have 2 ore.
4 clay-collecting robots collect 4 clay; you now have 9 clay.
2 obsidian-collecting robots collect 2 obsidian; you now have 6 obsidian.

== Minute 17 ==
1 ore-collecting robot collects 1 ore; you now have 3 ore.
4 clay-collecting robots collect 4 clay; you now have 13 clay.
2 obsidian-collecting robots collect 2 obsidian; you now have 8 obsidian.

== Minute 18 ==
Spend 2 ore and 7 obsidian to start building a geode-cracking robot.
1 ore-collecting robot collects 1 ore; you now have 2 ore.
4 clay-collecting robots collect 4 clay; you now have 17 clay.
2 obsidian-collecting robots collect 2 obsidian; you now have 3 obsidian.
The new geode-cracking robot is ready; you now have 1 of them.

== Minute 19 ==
1 ore-collecting robot collects 1 ore; you now have 3 ore.
4 clay-collecting robots collect 4 clay; you now have 21 clay.
2 obsidian-collecting robots collect 2 obsidian; you now have 5 obsidian.
1 geode-cracking robot cracks 1 geode; you now have 1 open geode.

== Minute 20 ==
1 ore-collecting robot collects 1 ore; you now have 4 ore.
4 clay-collecting robots collect 4 clay; you now have 25 clay.
2 obsidian-collecting robots collect 2 obsidian; you now have 7 obsidian.
1 geode-cracking robot cracks 1 geode; you now have 2 open geodes.

== Minute 21 ==
Spend 2 ore and 7 obsidian to start building a geode-cracking robot.
1 ore-collecting robot collects 1 ore; you now have 3 ore.
4 clay-collecting robots collect 4 clay; you now have 29 clay.
2 obsidian-collecting robots collect 2 obsidian; you now have 2 obsidian.
1 geode-cracking robot cracks 1 geode; you now have 3 open geodes.
The new geode-cracking robot is ready; you now have 2 of them.

== Minute 22 ==
1 ore-collecting robot collects 1 ore; you now have 4 ore.
4 clay-collecting robots collect 4 clay; you now have 33 clay.
2 obsidian-collecting robots collect 2 obsidian; you now have 4 obsidian.
2 geode-cracking robots crack 2 geodes; you now have 5 open geodes.

== Minute 23 ==
1 ore-collecting robot collects 1 ore; you now have 5 ore.
4 clay-collecting robots collect 4 clay; you now have 37 clay.
2 obsidian-collecting robots collect 2 obsidian; you now have 6 obsidian.
2 geode-cracking robots crack 2 geodes; you now have 7 open geodes.

== Minute 24 ==
1 ore-collecting robot collects 1 ore; you now have 6 ore.
4 clay-collecting robots collect 4 clay; you now have 41 clay.
2 obsidian-collecting robots collect 2 obsidian; you now have 8 obsidian.
2 geode-cracking robots crack 2 geodes; you now have 9 open geodes.
#+end_example

However, by using blueprint 2 in the example above, you could do even
better: the largest number of geodes you could open in 24 minutes
is 12.

Determine  the quality  level of  each blueprint  by multiplying  that
blueprint's ID  number with the largest  number of geodes that  can be
opened in 24 minutes using that  blueprint. In this example, the first
blueprint  has ID  1  and can  open  9 geodes,  so  its quality  level
is 9.  The second blueprint has  ID 2 and  can open 12 geodes,  so its
quality level is 24. Finally, if you  add up the quality levels of all
of the blueprints in the list, you get 33.

Determine the quality level of each blueprint using the largest number
of geodes it could  produce in 24 minutes. What do you  get if you add
up the quality level of all of the blueprints in your list?
** TODO Day 19.2                                                  :noexport:

** TODO Day 20.1                                                  :noexport:

It's finally  time to meet  back up with the  Elves.  When you  try to
contact them, however, you get no reply. Perhaps you're out of range?

You know they're headed to the grove where the star fruit grows, so if
you can figure out  where that is, you should be able  to meet back up
with them.

Fortunately, your handheld device has  a file (your puzzle input) that
contains  the   grove's  coordinates!   Unfortunately,  the   file  is
encrypted - just in case the device were to fall into the wrong hands.

Maybe you can decrypt it?

When you were still back at the camp, you overheard some Elves talking
about  coordinate  file encryption.  The  main  operation involved  in
decrypting the file is called mixing.

The encrypted file  is a list of  numbers. To mix the  file, move each
number forward or backward in the  file a number of positions equal to
the value of the number being moved. The list is circular, so moving a
number off one end  of the list wraps back around to  the other end as
if the ends were connected.

For example, to move the 1 in a sequence like 4, 5, 6, 1, 7, 8, 9, the
1 moves one position forward: 4, 5, 6, 7, 1, 8, 9. To move the -2 in a
sequence  like 4,  -2, 5,  6,  7, 8,  9,  the -2  moves two  positions
backward, wrapping around: 4, 5, 6, 7, 8, -2, 9.

The numbers should be moved in the order they originally appear in the
encrypted file. Numbers moving around during the mixing process do not
change the order in which the numbers are moved.

Consider this encrypted file:
#+begin_example
1
2
-3
3
-2
0
4
#+end_example

Mixing this file proceeds as follows:
#+begin_example
Initial arrangement:
1, 2, -3, 3, -2, 0, 4

1 moves between 2 and -3:
2, 1, -3, 3, -2, 0, 4

2 moves between -3 and 3:
1, -3, 2, 3, -2, 0, 4

-3 moves between -2 and 0:
1, 2, 3, -2, -3, 0, 4

3 moves between 0 and 4:
1, 2, -2, -3, 0, 3, 4

-2 moves between 4 and 1:
1, 2, -3, 0, 3, 4, -2

0 does not move:
1, 2, -3, 0, 3, 4, -2

4 moves between -3 and 0:
1, 2, -3, 4, 0, 3, -2
#+end_example

Then, the  grove coordinates can  be found  by looking at  the 1000th,
2000th, and 3000th numbers after the value 0, wrapping around the list
as necessary.  In  the above example, the 1000th number  after 0 is 4,
the  2000th  is  -3,  and  the 3000th  is  2;  adding  these  together
produces 3.

Mix your  encrypted file exactly  once. What is  the sum of  the three
numbers that form the grove coordinates?
** TODO Day 20.2                                                  :noexport:

** TODO Day 21.1                                                  :noexport:

The monkeys  are back! You're  worried they're  going to try  to steal
your stuff again, but it seems  like they're just holding their ground
and making various monkey noises at you.

Eventually, one of  the elephants realizes you don't  speak monkey and
comes over to  interpret. As it turns out, they  overheard you talking
about trying to  find the grove; they  can show you a  shortcut if you
answer their riddle.

Each monkey  is given a  job: either to yell  a specific number  or to
yell the result of a math operation. All of the number-yelling monkeys
know their number from the  start; however, the math operation monkeys
need to  wait for two  other monkeys to yell  a number, and  those two
other monkeys might also be waiting on other monkeys.

Your job  is to work  out the number the  monkey named root  will yell
before the monkeys figure it out themselves.

For example:

#+begin_example
root: pppw + sjmn
dbpl: 5
cczh: sllz + lgvd
zczc: 2
ptdq: humn - dvpt
dvpt: 3
lfqf: 4
humn: 5
ljgn: 2
sjmn: drzm * dbpl
sllz: 4
pppw: cczh / lfqf
lgvd: ljgn * ptdq
drzm: hmdt - zczc
hmdt: 32
#+end_example

Each line contains the name of a monkey, a colon, and then the job of
that monkey:
- A lone number means the monkey's job is simply to yell that number.
- A job like aaaa  + bbbb means the monkey waits  for monkeys aaaa and
  bbbb to yell each of their numbers; the monkey then yells the sum of
  those two numbers.
- aaaa - bbbb means the monkey yells aaaa's number minus bbbb's
  number.
- Job aaaa * bbbb will yell aaaa's number multiplied by bbbb's number.
- Job aaaa / bbbb will yell aaaa's number divided by bbbb's number.

So, in the above example, monkey drzm has to wait for monkeys hmdt and
zczc to yell their numbers. Fortunately,  both hmdt and zczc have jobs
that  involve  simply  yelling  a  single  number,  so  they  do  this
immediately: 32 and 2. Monkey drzm can then yell its number by finding
32 minus 2: 30.

Then, monkey sjmn  has one of its numbers (30,  from monkey drzm), and
already has its other number, 5, from dbpl. This allows it to yell its
own number by finding 30 multiplied by 5: 150.

This process continues until root yells a number: 152.

However,   your   actual    situation   involves   considerably   more
monkeys. What number will the monkey named root yell?
** TODO Day 21.2                                                  :noexport:

** TODO Day 22.1                                                  :noexport:

The  monkeys  take  you  on  a surprisingly  easy  trail  through  the
jungle. They're even going in roughly the right direction according to
your handheld device's Grove Positioning System.

As you  walk, the  monkeys explain  that the grove  is protected  by a
force field.  To pass  through the  force field, you  have to  enter a
password;   doing  so   involves  tracing   a  specific   path  on   a
strangely-shaped board.

At least, you're pretty sure that's what you have to do; the elephants
aren't exactly fluent in monkey.

The  monkeys give  you notes  that they  took when  they last  saw the
password entered (your puzzle input).

For example:
#+begin_example
        ...#
        .#..
        #...
        ....
...#.......#
........#...
..#....#....
..........#.
        ...#....
        .....#..
        .#......
        ......#.

10R5L5R10L4R5L5
#+end_example

The first  half of the monkeys'  notes is a  map of the board.   It is
comprised of a set of open tiles  (on which you can move, drawn .) and
solid walls (tiles which you cannot enter, drawn #).

The  second half  is a  description of  the path  you must  follow. It
consists of alternating numbers and letters:
- A number indicates the number of  tiles to move in the direction you
  are facing.  If you  run into  a wall, you  stop moving  forward and
  continue with the next instruction.
- A  letter indicates  whether to  turn  90 degrees  clockwise (R)  or
  counterclockwise (L).  Turning happens in-place; it  does not change
  your current tile.
  
So, a path  like 10R5 means "go forward 10  tiles, then turn clockwise
90 degrees, then go forward 5 tiles".

You  begin the  path in  the  leftmost open  tile  of the  top row  of
tiles. Initially, you are facing to the right (from the perspective of
how the map is drawn).

If a  movement instruction  would take  you off of  the map,  you wrap
around to the  other side of the  board. In other words,  if your next
tile is  off of the  board, you should  instead look in  the direction
opposite of your current  facing as far as you can  until you find the
opposite edge of the board, then reappear there.

For example,  if you are  at A  and facing to  the right, the  tile in
front of you is marked B; if you are at C and facing down, the tile in
front of you is marked D:

#+begin_example
        ...#
        .#..
        #...
        ....
...#.D.....#
........#...
B.#....#...A
.....C....#.
        ...#....
        .....#..
        .#......
        ......#.
#+end_example

It is possible for the next tile (after wrapping around) to be a wall;
this  still counts  as there  being a  wall in  front of  you, and  so
movement  stops before  you actually  wrap to  the other  side of  the
board.

By drawing  the last  facing you had  with an arrow  on each  tile you
visit, the full path taken by the above example looks like this:

#+begin_example
        >>v#    
        .#v.    
        #.v.    
        ..v.    
...#...v..v#    
>>>v...>#.>>    
..#v...#....    
...>>>>v..#.    
        ...#....
        .....#..
        .#......
        ......#.
#+end_example

To finish  providing the  password to this  strange input  device, you
need to  determine numbers for your  final row, column, and  facing as
your  final position  appears  from the  perspective  of the  original
map. Rows  start from 1 at  the top and count  downward; columns start
from 1 at the left and count  rightward. (In the above example, row 1,
column 1 refers to the empty space  with no tile on it in the top-left
corner.) Facing is  0 for right (>),  1 for down (v), 2  for left (<),
and 3 for up (^). The final password is the sum of 1000 times the row,
4 times the column, and the facing.

In the above example,  the final row is 6, the final  column is 8, and
the final facing  is 0. So, the final password  is 1000 * 6 + 4  * 8 +
0: 6032.

Follow  the path  given  in  the monkeys'  notes.  What  is the  final
password?
** TODO Day 22.2                                                  :noexport:

** TODO Day 23.1                                                  :noexport:

You enter a large  crater of gray dirt where the  grove is supposed to
be. All  around you, plants  you imagine were  expected to be  full of
fruit are  instead withered  and broken.  A large  group of  Elves has
formed in the middle of the grove.

"...but this volcano has been dormant for months. Without ash, the
fruit can't grow!"

You look up to see a massive, snow-capped mountain towering above you.

"It's not  like there  are other active  volcanoes here;  we've looked
everywhere."

"But  our  scanners  show  active  magma  flows;  clearly  it's  going
somewhere."

They finally  notice you at  the edge of  the grove, your  pack almost
overflowing from the random star  fruit you've been collecting. Behind
you, elephants and monkeys explore the grove, looking concerned. Then,
the Elves recognize  the ash cloud slowly spreading  above your recent
detour.

"Why do you--" "How is--" "Did you just--"

Before any  of them can form  a complete question, another  Elf speaks
up: "Okay, new plan. We have almost enough fruit already, and ash from
the  plume should  spread here  eventually.  If  we quickly  plant new
seedlings now,  we can still make  it to the extraction  point. Spread
out!"

The Elves each  reach into their pack  and pull out a  tiny plant. The
plants rely  on important  nutrients from  the ash,  so they  can't be
planted too close together.

There isn't enough time to let the Elves figure out where to plant the
seedlings themselves; you  quickly scan the grove  (your puzzle input)
and note their positions.

For example:

#+begin_example
....#..
..###.#
#...#.#
.#...##
#.###..
##.#.##
.#..#..
#+end_example

The scan  shows Elves #  and empty ground  .; outside your  scan, more
empty  ground extends  a long  way in  every direction.   The scan  is
oriented  so that  north is  up; orthogonal  directions are  written N
(north), S (south), W (west),  and E (east), while diagonal directions
are written NE, NW, SE, SW.

The Elves  follow a  time-consuming process to  figure out  where they
should  each go;  you can  speed  up this  process considerably.   The
process consists of some number of rounds during which Elves alternate
between considering where to move and actually moving.

During the  first half  of each  round, each  Elf considers  the eight
positions adjacent to themself. If no  other Elves are in one of those
eight  positions,   the  Elf   does  not   do  anything   during  this
round. Otherwise,  the Elf  looks in  each of  four directions  in the
following  order and  proposes  moving  one step  in  the first  valid
direction:
- If there is no Elf in the N, NE, or NW adjacent positions, the Elf
  proposes moving north one step.
- If there is no Elf in the S, SE, or SW adjacent positions, the Elf
  proposes moving south one step.
- If there is no Elf in the W, NW, or SW adjacent positions, the Elf
  proposes moving west one step.
- If there is no Elf in the E, NE, or SE adjacent positions, the Elf
  proposes moving east one step.
  
After each Elf has had a chance  to propose a move, the second half of
the round can begin. Simultaneously,  each Elf moves to their proposed
destination tile if  they were the only Elf to  propose moving to that
position. If  two or more Elves  propose moving to the  same position,
none of those Elves move.

Finally,  at the  end  of the  round, the  first  direction the  Elves
considered is moved to the end of the list of directions. For example,
during the second  round, the Elves would try proposing  a move to the
south first, then west, then east, then north. On the third round, the
Elves would first consider west, then east, then north, then south.

As a smaller example, consider just these five Elves:

#+begin_example
.....
..##.
..#..
.....
..##.
.....
#+end_example

The  northernmost two  Elves and  southernmost two  Elves all  propose
moving  north, while  the middle  Elf cannot  move north  and proposes
moving  south. The  middle Elf  proposes the  same destination  as the
southwest Elf, so neither of them move, but the other three do:

#+begin_example
..##.
.....
..#..
...#.
..#..
.....
#+end_example

Next, the northernmost two Elves  and the southernmost Elf all propose
moving south. Of  the remaining middle two Elves, the  west one cannot
move south  and proposes moving west,  while the east one  cannot move
south or  west and  proposes moving  east. All  five Elves  succeed in
moving to their proposed positions:

#+begin_example
.....
..##.
.#...
....#
.....
..#..
#+end_example

Finally, the southernmost two Elves choose  not to move at all. Of the
remaining three Elves, the west one proposes moving west, the east one
proposes moving  east, and the  middle one proposes moving  north; all
three succeed in moving:

#+begin_example
..#..
....#
#....
....#
.....
..#..
#+end_example

At this point, no Elves need to move, and so the process ends.

The larger example above proceeds as follows:

#+begin_example
== Initial State ==
..............
..............
.......#......
.....###.#....
...#...#.#....
....#...##....
...#.###......
...##.#.##....
....#..#......
..............
..............
..............

== End of Round 1 ==
..............
.......#......
.....#...#....
...#..#.#.....
.......#..#...
....#.#.##....
..#..#.#......
..#.#.#.##....
..............
....#..#......
..............
..............

== End of Round 2 ==
..............
.......#......
....#.....#...
...#..#.#.....
.......#...#..
...#..#.#.....
.#...#.#.#....
..............
..#.#.#.##....
....#..#......
..............
..............

== End of Round 3 ==
..............
.......#......
.....#....#...
..#..#...#....
.......#...#..
...#..#.#.....
.#..#.....#...
.......##.....
..##.#....#...
...#..........
.......#......
..............

== End of Round 4 ==
..............
.......#......
......#....#..
..#...##......
...#.....#.#..
.........#....
.#...###..#...
..#......#....
....##....#...
....#.........
.......#......
..............

== End of Round 5 ==
.......#......
..............
..#..#.....#..
.........#....
......##...#..
.#.#.####.....
...........#..
....##..#.....
..#...........
..........#...
....#..#......
..............
#+end_example

After a few more rounds...
#+begin_example
== End of Round 10 ==
.......#......
...........#..
..#.#..#......
......#.......
...#.....#..#.
.#......##....
.....##.......
..#........#..
....#.#..#....
..............
....#..#..#...
..............
#+end_example

To make sure they're on the right track, the Elves like to check after
round  10 that  they're making  good progress  toward covering  enough
ground. To do  this, count the number of empty  ground tiles contained
by the smallest  rectangle that contains every Elf. (The  edges of the
rectangle should  be aligned to  the N/S/E/W directions; the  Elves do
not have the patience to calculate arbitrary rectangles.) In the above
example, that rectangle is:

#+begin_example
......#.....
..........#.
.#.#..#.....
.....#......
..#.....#..#
#......##...
....##......
.#........#.
...#.#..#...
............
...#..#..#..
#+end_example

In this region, the number of empty ground tiles is 110.

Simulate  the Elves'  process  and find  the  smallest rectangle  that
contains the Elves  after 10 rounds. How many empty  ground tiles does
that rectangle contain?
** TODO Day 23.2                                                  :noexport:

** TODO Day 24.1                                                  :noexport:

With  everything  replanted for  next  year  (and with  elephants  and
monkeys to tend the grove), you and the Elves leave for the extraction
point.

Partway up  the mountain that shields  the grove is a  flat, open area
that  serves as  the extraction  point.  It's  a bit  of a  climb, but
nothing the expedition can't handle.

At  least, that  would  normally be  true; now  that  the mountain  is
covered in snow, things have become  more difficult than the Elves are
used to.

As the expedition reaches a valley that must be traversed to reach the
extraction site,  you find  that strong,  turbulent winds  are pushing
small blizzards of  snow and sharp ice around the  valley. It's a good
thing everyone packed  warm clothes! To make it  across safely, you'll
need to find a way to avoid them.

Fortunately, it's  easy to see  all of this  from the entrance  to the
valley, so you make a map of the valley and the blizzards (your puzzle
input). For example:

#+begin_example
#.#####
#.....#
#>....#
#.....#
#...v.#
#.....#
#####.#
#+end_example

The  walls  of  the  valley  are   drawn  as  #;  everything  else  is
ground. Clear ground - where there is currently no blizzard - is drawn
as ..  Otherwise,  blizzards are drawn with an  arrow indicating their
direction of motion: up (^), down (v), left (<), or right (>).

The above  map includes two  blizzards, one  moving right (>)  and one
moving down  (v). In one minute,  each blizzard moves one  position in
the direction it is pointing:

#+begin_example
#.#####
#.....#
#.>...#
#.....#
#.....#
#...v.#
#####.#
#+end_example

Due to conservation of blizzard energy, as a blizzard reaches the wall
of the valley, a new blizzard forms on the opposite side of the valley
moving  in  the  same  direction. After  another  minute,  the  bottom
downward-moving blizzard has been  replaced with a new downward-moving
blizzard at the top of the valley instead:

#+begin_example
#.#####
#...v.#
#..>..#
#.....#
#.....#
#.....#
#####.#
#+end_example

Because blizzards are made of tiny snowflakes, they pass right through
each other.  After another  minute, both blizzards  temporarily occupy
the same position, marked 2:

#+begin_example
#.#####
#.....#
#...2.#
#.....#
#.....#
#.....#
#####.#
#+end_example

After another minute, the situation resolves itself, giving each
blizzard back its personal space:

#+begin_example
#.#####
#.....#
#....>#
#...v.#
#.....#
#.....#
#####.#
#+end_example

Finally, after  yet another  minute, the rightward-facing  blizzard on
the right  is replaced  with a  new one  on the  left facing  the same
direction:

#+begin_example
#.#####
#.....#
#>....#
#.....#
#...v.#
#.....#
#####.#
#+end_example

This process repeats at least as long as you are observing it, but
probably forever.

Here is a more complex example:

#+begin_example
#.######
#>>.<^<#
#.<..<<#
#>v.><>#
#<^v^^>#
######.#
#+end_example

Your expedition  begins in the only  non-wall position in the  top row
and needs  to reach the only  non-wall position in the  bottom row. On
each minute, you can move up, down, left, or right, or you can wait in
place. You and the blizzards  act simultaneously, and you cannot share
a position with a blizzard.

In the above  example, the fastest way to reach  your goal requires 18
steps. Drawing the position of the expedition as E, one way to achieve
this is:

#+begin_example

Initial state:
#E######
#>>.<^<#
#.<..<<#
#>v.><>#
#<^v^^>#
######.#

Minute 1, move down:
#.######
#E>3.<.#
#<..<<.#
#>2.22.#
#>v..^<#
######.#

Minute 2, move down:
#.######
#.2>2..#
#E^22^<#
#.>2.^>#
#.>..<.#
######.#

Minute 3, wait:
#.######
#<^<22.#
#E2<.2.#
#><2>..#
#..><..#
######.#

Minute 4, move up:
#.######
#E<..22#
#<<.<..#
#<2.>>.#
#.^22^.#
######.#

Minute 5, move right:
#.######
#2Ev.<>#
#<.<..<#
#.^>^22#
#.2..2.#
######.#

Minute 6, move right:
#.######
#>2E<.<#
#.2v^2<#
#>..>2>#
#<....>#
######.#

Minute 7, move down:
#.######
#.22^2.#
#<vE<2.#
#>>v<>.#
#>....<#
######.#

Minute 8, move left:
#.######
#.<>2^.#
#.E<<.<#
#.22..>#
#.2v^2.#
######.#

Minute 9, move up:
#.######
#<E2>>.#
#.<<.<.#
#>2>2^.#
#.v><^.#
######.#

Minute 10, move right:
#.######
#.2E.>2#
#<2v2^.#
#<>.>2.#
#..<>..#
######.#

Minute 11, wait:
#.######
#2^E^2>#
#<v<.^<#
#..2.>2#
#.<..>.#
######.#

Minute 12, move down:
#.######
#>>.<^<#
#.<E.<<#
#>v.><>#
#<^v^^>#
######.#

Minute 13, move down:
#.######
#.>3.<.#
#<..<<.#
#>2E22.#
#>v..^<#
######.#

Minute 14, move right:
#.######
#.2>2..#
#.^22^<#
#.>2E^>#
#.>..<.#
######.#

Minute 15, move right:
#.######
#<^<22.#
#.2<.2.#
#><2>E.#
#..><..#
######.#

Minute 16, move right:
#.######
#.<..22#
#<<.<..#
#<2.>>E#
#.^22^.#
######.#

Minute 17, move down:
#.######
#2.v.<>#
#<.<..<#
#.^>^22#
#.2..2E#
######.#

Minute 18, move down:
#.######
#>2.<.<#
#.2v^2<#
#>..>2>#
#<....>#
######E#
#+end_example

What is the fewest number of minutes required to avoid the blizzards
and reach the goal?
** TODO Day 24.2                                                  :noexport:

** TODO Day 25.1                                                  :noexport:

As the expedition finally reaches  the extraction point, several large
hot air balloons drift down to meet you. Crews quickly start unloading
the equipment  the balloons brought:  many hot air balloon  kits, some
fuel tanks, and a fuel heating machine.

The fuel heating  machine is a new addition to  the process. When this
mountain was a  volcano, the ambient temperature  was more reasonable;
now, it's so cold that the fuel won't work at all without being warmed
up first.

The  Elves, seemingly  in  an attempt  to make  the  new machine  feel
welcome,  have already  attached a  pair  of googly  eyes and  started
calling it "Bob".

To heat the fuel, Bob needs to know the total amount of fuel that will
be processed ahead  of time so it can correctly  calibrate heat output
and flow rate. This amount is  simply the sum of the fuel requirements
of all of  the hot air balloons, and those  fuel requirements are even
listed clearly on the side of each hot air balloon's burner.

You assume the  Elves will have no trouble adding  up some numbers and
are about to go  back to figuring out which balloon  is yours when you
get  a tap  on the  shoulder.  Apparently, the  fuel requirements  use
numbers written  in a format  the Elves don't  recognize; predictably,
they'd like your help deciphering them.

You make a  list of all of the fuel  requirements (your puzzle input),
but you don't recognize the number format either. For example:

#+begin_example
1=-0-2
12111
2=0=
21
2=01
111
20012
112
1=-1=
1-12
12
1=
122
#+end_example

Fortunately, Bob  is labeled with  a support  phone number. Not  to be
deterred, you call and ask for help.

"That's right, just supply the fuel  amount to the-- oh, for more than
one burner?   No problem, you  just need  to add together  our Special
Numeral-Analogue Fuel  Units. Patent pending! They're  way better than
normal numbers for--"

You mention  that it's  quite cold up  here and ask  if they  can skip
ahead.

"Okay, our Special Numeral-Analogue Fuel Units - SNAFU for short - are
sort of  like normal  numbers.  You  know how  starting on  the right,
normal numbers have a ones place,  a tens place, a hundreds place, and
so on, where the digit in each  place tells you how many of that value
you have?"

"SNAFU works  the same way, except  it uses powers of  five instead of
ten. Starting from the right, you have  a ones place, a fives place, a
twenty-fives  place,  a  one-hundred-and-twenty-fives  place,  and  so
on. It's that easy!"

You ask why some of the digits look like - or = instead of "digits".

"You know, I never did ask the engineers why they did that. Instead of
using digits four through zero, the digits are 2, 1, 0, minus (written
-), and double-minus (written =).  Minus is worth -1, and double-minus
is worth -2."

"So, because  ten (in  normal numbers)  is two fives  and no  ones, in
SNAFU it is  written 20. Since eight (in normal  numbers) is two fives
minus two ones, it is written 2=."

"You can do it the other direction, too. Say you have the SNAFU number
2=-01.   That's 2  in the  625s place,  = (double-minus)  in the  125s
place, - (minus) in the 25s place, 0  in the 5s place, and 1 in the 1s
place. (2 times  625) plus (-2 times  125) plus (-1 times  25) plus (0
times 5)  plus (1  times 1).  That's  1250 plus -250  plus -25  plus 0
plus 1. 976!"

"I see here  that you're connected via our premium  uplink service, so
I'll  transmit our  handy SNAFU  brochure to  you now.   Did you  need
anything else?"

You ask if the fuel will even work in these temperatures.

"Wait, it's how  cold? There's no way  the fuel - or any  fuel - would
work in those  conditions! There are only a few  places in the-- where
did you say you are again?"

Just  then, you  notice one  of  the Elves  pour  a few  drops from  a
snowflake-shaped  container into  one  of the  fuel  tanks, thank  the
support representative for their time, and disconnect the call.

The SNAFU brochure contains a  few more examples of decimal ("normal")
numbers and their SNAFU counterparts:

#+begin_example
  Decimal          SNAFU
        1              1
        2              2
        3             1=
        4             1-
        5             10
        6             11
        7             12
        8             2=
        9             2-
       10             20
       15            1=0
       20            1-0
     2022         1=11-2
    12345        1-0---0
314159265  1121-1110-1=0
#+end_example

Based on this  process, the SNAFU numbers in the  example above can be
converted to decimal numbers as follows:

#+begin_example
 SNAFU  Decimal
1=-0-2     1747
 12111      906
  2=0=      198
    21       11
  2=01      201
   111       31
 20012     1257
   112       32
 1=-1=      353
  1-12      107
    12        7
    1=        3
   122       37
#+end_example

In decimal, the sum of these numbers is 4890.

As you  go to input  this number on  Bob's console, you  discover that
some  buttons you  expected are  missing.  Instead,  you are  met with
buttons labeled =, -, 0, 1, and 2. Bob needs the input value expressed
as a SNAFU number, not in decimal.

Reversing the process,  you can determine that for  the decimal number
4890, the SNAFU number you need to supply to Bob's console is 2=-1=0.

The Elves are starting to get cold. What SNAFU number do you supply to
Bob's console?
** TODO Day 25.2                                                  :noexport:

** Stats                                                          :noexport:

#+CAPTION: https://adventofcode.com/2022/stats
| 25 |  4 | ▉▉▉▉                                      |
| 24 |  4 | ▉▉▉▉                                      |
| 23 |  4 | ▉▉▉▉                                      |
| 22 |  4 | ▉▉▉▉                                      |
| 21 |  5 | ▉▉▉▉▉                                     |
| 20 |  4 | ▉▉▉▉                                      |
| 19 |  4 | ▉▉▉▉                                      |
| 18 |  5 | ▉▉▉▉▉                                     |
| 17 |  4 | ▉▉▉▉                                      |
| 16 |  5 | ▉▉▉▉▉                                     |
| 15 |  7 | ▉▉▉▉▉▉▉                                   |
| 14 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 13 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 12 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
| 11 | 12 | ▉▉▉▉▉▉▉▉▉▉▉▉                              |
| 10 | 13 | ▉▉▉▉▉▉▉▉▉▉▉▉▉                             |
|  9 | 14 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉                            |
|  8 | 17 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                         |
|  7 | 17 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                         |
|  6 | 23 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                   |
|  5 | 23 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                   |
|  4 | 26 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                |
|  3 | 30 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉            |
|  2 | 34 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉        |
|  1 | 41 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ |
#+TBLFM: $3='(orgtbl-uc-draw-grid $2 0 41 41)




* 2021 [18/50]
** DONE Day 1.1

You're minding your  own business on a ship at  sea when the overboard
alarm goes off!  You rush to see  if you can help.  Apparently, one of
the Elves  tripped and accidentally  sent the sleigh keys  flying into
the ocean!

Before you know it, you're inside a submarine the Elves keep ready for
situations like  this. It's  covered in  Christmas lights  (because of
course it is), and it even  has an experimental antenna that should be
able  to track  the keys  if you  can boost  its signal  strength high
enough; there's  a little  meter that  indicates the  antenna's signal
strength by displaying 0-50 stars.

Your instincts tell  you that in order to save  Christmas, you'll need
to get all fifty stars by December 25th.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

As  the   submarine  drops  below   the  surface  of  the   ocean,  it
automatically performs  a sonar sweep  of the  nearby sea floor.  On a
small screen, the sonar sweep report (your puzzle input) appears: each
line  is a  measurement of  the  sea floor  depth as  the sweep  looks
further and further away from the submarine.

For example, suppose you had the following report:

#+begin_example
199
200
208
210
200
207
240
269
260
263
#+end_example

This report indicates  that, scanning outward from  the submarine, the
sonar sweep found depths of 199, 200, 208, 210, and so on.

The first  order of business  is to figure  out how quickly  the depth
increases, just so you know what  you're dealing with - you never know
if the keys will get carried into  deeper water by an ocean current or
a fish or something.

To do  this, count the number  of times a depth  measurement increases
from the  previous measurement.  (There is  no measurement  before the
first measurement.) In the example above, the changes are as follows:

#+begin_example
199 (N/A - no previous measurement)
200 (increased)
208 (increased)
210 (increased)
200 (decreased)
207 (increased)
240 (increased)
269 (increased)
260 (decreased)
263 (increased)
#+end_example

In this example, there are 7 measurements that are larger than the
previous measurement.

How many measurements are larger than the previous measurement?

#+begin_src fennel -n :session d2101 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [lines]
  (let [t (aoc.table-zip
           (aoc.table-range lines 1 (- (length lines) 1))
           (aoc.table-range lines 2 (length lines)))]
    (length (lume.filter t (fn [[f t]] (< (tonumber f) (tonumber t)))))))

(fn test [expected input]
  (assert (= expected (solve input))))

(local test-input ["199"
                   "200"
                   "208"
                   "210"
                   "200"
                   "207"
                   "240"
                   "269"
                   "260"
                   "263"])

(test 7 test-input)

(solve (aoc.string-from "2021/01.inp"))
#+end_src

#+RESULTS:
: 1400


** DONE Day 1.2

Considering every single measurement isn't as useful as you expected:
there's just too much noise in the data.

Instead, consider sums of a three-measurement sliding window. Again
considering the above example:

#+begin_example
199  A      
200  A B    
208  A B C  
210    B C D
200  E   C D
207  E F   D
240  E F G  
269    F G H
260      G H
263        H
#+end_example

Start by comparing the first and second three-measurement windows. The
measurements in the first window are marked A (199, 200, 208); their
sum is 199 + 200 + 208 = 607. The second window is marked B (200, 208,
210); its sum is 618. The sum of measurements in the second window is
larger than the sum of the first, so this first comparison increased.

Your goal now is to count the  number of times the sum of measurements
in this sliding window increases from  the previous sum. So, compare A
with B,  then compare B with  C, then C with  D, and so on.  Stop when
there   aren't   enough   measurements    left   to   create   a   new
three-measurement sum.

In the above example, the sum of each three-measurement window is as
follows:

#+begin_example
A: 607 (N/A - no previous sum)
B: 618 (increased)
C: 618 (no change)
D: 617 (decreased)
E: 647 (increased)
F: 716 (increased)
G: 769 (increased)
H: 792 (increased)
#+end_example

In this example, there are 5 sums that are larger than the previous
sum.

Consider sums of a three-measurement sliding window. How many sums are
larger than the previous sum?

#+begin_src fennel -n :session d2101 :exports both
(fn solve2 [lines]
  (let [res []]
    (for [i 3 (length lines)]
      (table.insert res (+ (. lines (- i 2))
                           (. lines (- i 1))
                           (. lines i))))
    (solve res)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 5 test-input)

(solve2 (aoc.string-from "2021/01.inp"))
#+end_src

#+RESULTS:
: 1429


** DONE Day 2.1

Now, you need to figure out how to pilot this thing.

It seems like the submarine can take a series of commands like forward
1, down 2, or up 3:
- forward X increases the horizontal position by X units.
- down X increases the depth by X units.
- up X decreases the depth by X units.

Note that since you're on a submarine, down and up affect your depth,
and so they have the opposite result of what you might expect.

The submarine seems to already have a planned course (your puzzle
input). You should probably figure out where it's going. For example:

#+begin_example
forward 5
down 5
forward 8
up 3
down 8
forward 2
#+end_example

Your horizontal position and depth both start at 0. The steps above
would then modify them as follows:
- forward 5 adds 5 to your horizontal position, a total of 5.
- down 5 adds 5 to your depth, resulting in a value of 5.
- forward 8 adds 8 to your horizontal position, a total of 13.
- up 3 decreases your depth by 3, resulting in a value of 2.
- down 8 adds 8 to your depth, resulting in a value of 10.
- forward 2 adds 2 to your horizontal position, a total of 15.

After  following  these  instructions,  you would  have  a  horizontal
position of 15 and a depth of 10. (Multiplying these together produces
150.)

Calculate  the horizontal  position  and depth  you  would have  after
following the  planned course. What  do you  get if you  multiply your
final horizontal position by your final depth?

#+begin_src fennel -n :session d2102 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [lines]
  (let [s {:x 0 :y 0}]
    (each [_ line (ipairs lines)]
      (case (aoc.string-split line " ")
        ["forward" f] (tset s :x (+ f (. s :x)))
        ["down" d] (tset s :y (+ d (. s :y)))
        ["up" u] (tset s :y (- (. s :y) u))))
    (* (. s :x) (. s :y))))

(fn test [expected input]
  (assert (= expected (solve input))))

(local test-input
       ["forward 5"
        "down 5"
        "forward 8"
        "up 3"
        "down 8"
        "forward 2"])

(test 150 test-input)

(solve (aoc.string-from "2021/02.inp"))
#+end_src

#+RESULTS:
: 1561344


** DONE Day 2.2

Based on  your calculations, the  planned course doesn't seem  to make
any sense. You find the submarine manual and discover that the process
is actually slightly more complicated.

In  addition to  horizontal position  and depth,  you'll also  need to
track a  third value, aim, which  also starts at 0.  The commands also
mean something entirely different than you first thought:
- down X increases your aim by X units.
- up X decreases your aim by X units.
- forward X does two things:
  - It increases your horizontal position by X units.
  - It increases your depth by your aim multiplied by X.

Again  note that  since you're  on  a submarine,  down and  up do  the
opposite of what you might expect: "down" means aiming in the positive
direction.

Now, the above example does something different:
- forward 5 adds 5 to your horizontal position, a total of 5. Because
  your aim is 0, your depth does not change.
- down 5 adds 5 to your aim, resulting in a value of 5.
- forward 8 adds 8 to your horizontal position, a total of 13. Because
  your aim is 5, your depth increases by 8*5=40.
- up 3 decreases your aim by 3, resulting in a value of 2.
- down 8 adds 8 to your aim, resulting in a value of 10.
- forward 2 adds 2 to your horizontal position, a total of 15. Because
  your aim is 10, your depth increases by 2*10=20 to a total of 60.
  
After following  these new instructions,  you would have  a horizontal
position of 15 and a depth of 60. (Multiplying these produces 900.)

Using  this   new  interpretation  of  the   commands,  calculate  the
horizontal  position and  depth  you would  have  after following  the
planned course. What do you get  if you multiply your final horizontal
position by your final depth?

#+begin_src fennel -n :session d2102 :exports both
(fn solve2 [lines]
  (let [s {:x 0 :y 0 :z 0}]
    (each [_ line (ipairs lines)]
      (case (aoc.string-split line " ")
        ["forward" f] (do
                        (tset s :y (+ (. s :y) (* (. s :z) f)))
                        (tset s :x (+ f (. s :x))))
        ["down" d] (tset s :z (+ d (. s :z)))
        ["up" u] (tset s :z (- (. s :z) u))))
    (* (. s :x) (. s :y))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 900 test-input)

(solve2 (aoc.string-from "2021/02.inp"))
#+end_src

#+RESULTS:
: 1848454425


** DONE Day 3.1

The submarine has been making some  odd creaking noises, so you ask it
to produce a diagnostic report just in case.

The diagnostic report (your puzzle input) consists of a list of binary
numbers which, when decoded properly,  can tell you many useful things
about the conditions of the submarine. The first parameter to check is
the power consumption.

You  need to  use  the  binary numbers  in  the  diagnostic report  to
generate two new binary numbers (called the gamma rate and the epsilon
rate).  The power  consumption can  then be  found by  multiplying the
gamma rate by the epsilon rate.

Each  bit in  the gamma  rate can  be determined  by finding  the most
common  bit  in the  corresponding  position  of  all numbers  in  the
diagnostic report. For example, given the following diagnostic report:

#+begin_example
00100
11110
10110
10111
10101
01111
00111
11100
10000
11001
00010
01010
#+end_example

Considering only the  first bit of each number, there  are five 0 bits
and seven 1 bits. Since the most common bit is 1, the first bit of the
gamma rate is 1.

The most common second bit of  the numbers in the diagnostic report is
0, so the second bit of the gamma rate is 0.

The most common value  of the third, fourth, and fifth  bits are 1, 1,
and 0,  respectively, and so  the final three  bits of the  gamma rate
are 110.

So, the gamma rate is the binary number 10110, or 22 in decimal.

The epsilon rate  is calculated in a similar way;  rather than use the
most common bit, the least common  bit from each position is used. So,
the epsilon rate is 01001, or 9 in decimal. Multiplying the gamma rate
(22) by the epsilon rate (9) produces the power consumption, 198.

Use  the binary  numbers in  your diagnostic  report to  calculate the
gamma rate and epsilon rate, then  multiply them together. What is the
power consumption of the submarine?  (Be sure to represent your answer
in decimal, not binary.)


#+begin_src fennel -n :session d2103 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-input [input]
  (aoc.table-transpose
   (lume.map input #(aoc.string-toarray $))))

(fn solve [lines]
  (let [xs (read-input lines)
        gamma []
        epsilon []]
    (each [_ t (ipairs xs)]
      (case (< (aoc.table-count t 1) (aoc.table-count t 0))
        true (do
               (table.insert gamma 0)
               (table.insert epsilon 1))
        false (do
                (table.insert gamma 1)
                (table.insert epsilon 0))))
    (* (aoc.todecimal gamma)
       (aoc.todecimal epsilon))))

(fn test [expected input]
  (assert (= expected (solve input))))

(local test-input ["00100"
                   "11110"
                   "10110"
                   "10111"
                   "10101"
                   "01111"
                   "00111"
                   "11100"
                   "10000"
                   "11001"
                   "00010"
                   "01010"])

(test 198 test-input)

(solve (aoc.string-from "2021/03.inp"))
#+end_src

#+RESULTS:
: 3009600


** DONE Day 3.2

Next,  you  should  verify  the  life support  rating,  which  can  be
determined  by multiplying  the  oxygen generator  rating  by the  CO2
scrubber rating.

Both  the oxygen  generator rating  and  the CO2  scrubber rating  are
values that can  be found in your diagnostic report  - finding them is
the tricky part. Both values are  located using a similar process that
involves filtering out values until only one remains. Before searching
for either  rating value, start with  the full list of  binary numbers
from your diagnostic  report and consider just the first  bit of those
numbers. Then:
- Keep  only numbers  selected by  the bit  criteria for  the type  of
  rating value for  which you are searching. Discard  numbers which do
  not match the bit criteria.
- If you only have one number left, stop; this is the rating value for
  which you are searching.
- Otherwise,  repeat the  process,  considering the  next  bit to  the
  right.
  
The bit  criteria depends on  which type of  rating value you  want to
find:
- To find oxygen generator rating,  determine the most common value (0
  or 1) in  the current bit position, and keep  only numbers with that
  bit in  that position. If  0 and 1  are equally common,  keep values
  with a 1 in the position being considered.
- To find  CO2 scrubber  rating, determine the  least common  value (0
  or 1) in  the current bit position, and keep  only numbers with that
  bit in  that position. If  0 and 1  are equally common,  keep values
  with a 0 in the position being considered.
  
For example, to determine the  oxygen generator rating value using the
same example diagnostic report from above:
- Start with  all 12 numbers and  consider only the first  bit of each
  number. There are more 1 bits (7)  than 0 bits (5), so keep only the
  7  numbers with  a 1  in the  first position:  11110, 10110,  10111,
  10101, 11100, 10000, and 11001.
- Then, consider the second bit of  the 7 remaining numbers: there are
  more 0 bits (4) than 1 bits (3), so keep only the 4 numbers with a 0
  in the second position: 10110, 10111, 10101, and 10000.
- In the third position,  three of the four numbers have  a 1, so keep
  those three: 10110, 10111, and 10101.
- In the fourth position,  two of the three numbers have  a 1, so keep
  those two: 10110 and 10111.
- In the  fifth position, there  are an equal number  of 0 bits  and 1
  bits (one each).  So, to find the oxygen generator  rating, keep the
  number with a 1 in that position: 10111.
- As there is only one number  left, stop; the oxygen generator rating
  is 10111, or 23 in decimal.
  
Then, to determine the CO2 scrubber rating value from the same example
above:
- Start again with  all 12 numbers and consider only  the first bit of
  each number.  There are fewer  0 bits (5) than  1 bits (7),  so keep
  only the  5 numbers with  a 0 in  the first position:  00100, 01111,
  00111, 00010, and 01010.
- Then, consider the second bit of  the 5 remaining numbers: there are
  fewer 1 bits (2) than 0 bits (3),  so keep only the 2 numbers with a
  1 in the second position: 01111 and 01010.
- In the  third position, there  are an equal number  of 0 bits  and 1
  bits  (one each).  So, to  find the  CO2 scrubber  rating, keep  the
  number with a 0 in that position: 01010.
- As there is  only one number left, stop; the  CO2 scrubber rating is
  01010, or 10 in decimal.
  
Finally,  to  find  the  life  support  rating,  multiply  the  oxygen
generator rating (23) by the CO2 scrubber rating (10) to get 230.

Use  the binary  numbers in  your diagnostic  report to  calculate the
oxygen generator  rating and CO2  scrubber rating, then  multiply them
together. What is  the life support rating of the  submarine? (Be sure
to represent your answer in decimal, not binary.)

#+begin_src fennel -n :session d2103 :exports both
(fn rate-generator [xs pos]
  (if (= 1 (length xs)) (aoc.todecimal (. xs 1))
      (let [bits (. (aoc.table-transpose xs) pos)
            ones (aoc.table-count bits 1)
            zeroes (aoc.table-count bits 0)]
        (var pred "")
        (if (<= zeroes ones)
            (set pred "1")
            (set pred "0"))
        (let [xss (lume.filter xs #(= pred (. $ pos)))]
          (rate-generator xss (+ 1 pos))))))

(fn rate-scrubber [xs pos]
  (if (= 1 (length xs)) (aoc.todecimal (. xs 1))
      (let [bits (. (aoc.table-transpose xs) pos)
            ones (aoc.table-count bits 1)
            zeroes (aoc.table-count bits 0)]
        (var pred "")
        (if (<= zeroes ones)
            (set pred "0")
            (set pred "1"))
        (let [xss (lume.filter xs #(= pred (. $ pos)))]
          (rate-scrubber xss (+ 1 pos))))))

(fn solve2 [lines]
  (let [xs (lume.map lines #(aoc.string-toarray $))
        g (rate-generator xs 1)
        s (rate-scrubber xs 1)]
    (* g s)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 230 test-input)

(solve2 (aoc.string-from "2021/03.inp"))
#+end_src

#+RESULTS:
: 6940518

** DONE Day 4.1

You're already almost  1.5km (almost a mile) below the  surface of the
ocean, already so  deep that you can't see any  sunlight. What you can
see, however, is a giant squid that has attached itself to the outside
of your submarine.

Maybe it wants to play bingo?

Bingo is played  on a set of  boards each consisting of a  5x5 grid of
numbers. Numbers are chosen at random, and the chosen number is marked
on all  boards on  which it  appears. (Numbers may  not appear  on all
boards.)  If all  numbers in  any row  or any  column of  a board  are
marked, that board wins. (Diagonals don't count.)


The submarine has a bingo subsystem to help passengers (currently, you
and  the giant  squid) pass  the  time. It  automatically generates  a
random order in which to draw numbers and a random set of boards (your
puzzle input). For example:

#+begin_example
7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1

22 13 17 11  0
 8  2 23  4 24
21  9 14 16  7
 6 10  3 18  5
 1 12 20 15 19

 3 15  0  2 22
 9 18 13 17  5
19  8  7 25 23
20 11 10 24  4
14 21 16 12  6

14 21 17 24  4
10 16 15  9 19
18  8 23 26 20
22 11 13  6  5
 2  0 12  3  7
#+end_example

After the first five numbers are drawn (7, 4, 9, 5, and 11), there are
no winners, but the boards are  marked as follows (shown here adjacent
to each other to save space):

#+begin_example
22 13 17 11  0         3 15  0  2 22        14 21 17 24  4
 8  2 23  4 24         9 18 13 17  5        10 16 15  9 19
21  9 14 16  7        19  8  7 25 23        18  8 23 26 20
 6 10  3 18  5        20 11 10 24  4        22 11 13  6  5
 1 12 20 15 19        14 21 16 12  6         2  0 12  3  7
#+end_example

After the next six numbers are drawn (17, 23, 2, 0, 14, and 21), there
are still no winners:

#+begin_example
22 13 17 11  0         3 15  0  2 22        14 21 17 24  4
 8  2 23  4 24         9 18 13 17  5        10 16 15  9 19
21  9 14 16  7        19  8  7 25 23        18  8 23 26 20
 6 10  3 18  5        20 11 10 24  4        22 11 13  6  5
 1 12 20 15 19        14 21 16 12  6         2  0 12  3  7
#+end_example

Finally, 24 is drawn:

#+begin_example
22 13 17 11  0         3 15  0  2 22        14 21 17 24  4
 8  2 23  4 24         9 18 13 17  5        10 16 15  9 19
21  9 14 16  7        19  8  7 25 23        18  8 23 26 20
 6 10  3 18  5        20 11 10 24  4        22 11 13  6  5
 1 12 20 15 19        14 21 16 12  6         2  0 12  3  7
#+end_example

At  this point,  the third  board  wins because  it has  at least  one
complete row or column of marked numbers (in this case, the entire top
row is marked: 14 21 17 24 4).

The score of the winning board can now be calculated. Start by finding
the sum of all  unmarked numbers on that board; in  this case, the sum
is 188.  Then, multiply that  sum by the  number that was  just called
when the board won, 24, to get the final score, 188 * 24 = 4512.

To guarantee victory  against the giant squid, figure  out which board
will  win first.  What will  your final  score be  if you  choose that
board?

#+begin_src fennel -n :session d2104 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1"
        ""
        "22 13 17 11  0"
        " 8  2 23  4 24"
        "21  9 14 16  7"
        " 6 10  3 18  5"
        " 1 12 20 15 19"
        ""
        " 3 15  0  2 22"
        " 9 18 13 17  5"
        "19  8  7 25 23"
        "20 11 10 24  4"
        "14 21 16 12  6"
        ""
        "14 21 17 24  4"
        "10 16 15  9 19"
        "18  8 23 26 20"
        "22 11 13  6  5"
        " 2  0 12  3  7"])

(fn read-input [lines]
  (let [res []
        board []
        deal []]
    (each [num line (ipairs lines)]
      (let [digits (aoc.string-tonumarray line)]
        (if (= 1 num) (aoc.table-move 1 digits deal (length digits))
            (= "" line) (let [new []]
                          (when (= 5 (length board))
                            (aoc.table-move 1 board new 5)
                            (table.insert res new)))
            (table.insert board
                          (aoc.string-tonumarray line)))))
    (let [new []]
      (aoc.table-move 1 board new 5)
      (table.insert res new))
    [deal res]))

(fn scan-board [board deal]
  (var bingo false)
  (for [i 1 (length board) &until bingo]
    (when (lume.all (. board i) (fn [e] (aoc.table-contains? deal e)))
      (set bingo i)))
  (if bingo (. board bingo)
      (let [nb (aoc.table-transpose board)]
        (for [i 1 (length nb) &until bingo]
          (when (lume.all (. nb i) (fn [e] (aoc.table-contains? deal e)))
            (set bingo i)))
        (or (?. nb bingo) []))))

(fn score [deal winner]
  (*
   (. deal (length deal))
   (aoc.table-sum-if winner
                 #(not (aoc.table-contains? deal $)))))

(fn find-winner [deal boards]
  (var winner 0)
  (var numbers [])
  (for [i 1 (length deal) &until (not= 0 winner)]
    (each [j board (ipairs boards) &until (not= 0 winner)]
      (let [draw (aoc.table-range deal 1 i)
            bingo (scan-board board draw)]
        (when (not= 0 (length bingo))
          (set winner j)
          (set numbers draw)))))
  [winner numbers])

(fn solve [input]
  (let [[deals boards] (read-input input)
        [winner numbers] (find-winner deals boards)]
    (score numbers (. boards winner))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 4512 test-input)

(solve (aoc.string-from "2021/04.inp"))
#+end_src

#+RESULTS:
: 82440

** DONE Day 4.2
On the other hand,  it might be wise to try  a different strategy: let
the giant squid win.

You aren't  sure how  many bingo  boards a giant  squid could  play at
once, so rather  than waste time counting its arms,  the safe thing to
do  is  to figure  out  which  board will  win  last  and choose  that
one. That way, no matter which boards it picks, it will win for sure.

In  the above  example, the  second board  is the  last to  win, which
happens  after  13 is  eventually  called  and  its middle  column  is
completely marked. If  you were to keep playing until  this point, the
second board would have  a sum of unmarked numbers equal  to 148 for a
final score of 148 * 13 = 1924.

Figure out  which board will  win last. Once  it wins, what  would its
final score be?

#+begin_src fennel -n :session d2104 :exports both
(fn find-score [deal boards]
  (let [[winner numbers] (find-winner deal boards)]
    (if (= 1 (length boards))
      (score numbers (. boards 1))
      (do
        (table.remove boards winner)
        (find-score deal boards)))))

(fn solve2 [input]
  (let [[deals boards] (read-input input)]
    (find-score deals boards)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 1924 test-input)

(solve2 (aoc.string-from "2021/04.inp"))
#+end_src

#+RESULTS:
: 20774

** DONE Day 5.1

You come  across a  field of  hydrothermal vents  on the  ocean floor!
These vents  constantly produce large,  opaque clouds, so it  would be
best to avoid them if possible.

They tend to form in lines; the submarine helpfully produces a list of
nearby  lines of  vents (your  puzzle input)  for you  to review.  For
example:

#+begin_example
0,9 -> 5,9
8,0 -> 0,8
9,4 -> 3,4
2,2 -> 2,1
7,0 -> 7,4
6,4 -> 2,0
0,9 -> 2,9
3,4 -> 1,4
0,0 -> 8,8
5,5 -> 8,2
#+end_example

Each line of vents  is given as a line segment in  the format x1,y1 ->
x2,y2 where x1,y1 are the coordinates  of one end the line segment and
x2,y2  are the  coordinates  of  the other  end.  These line  segments
include the points at both ends. In other words:
- An entry like 1,1 -> 1,3 covers points 1,1, 1,2, and 1,3.
- An entry like 9,7 -> 7,7 covers points 9,7, 8,7, and 7,7.

For  now, only  consider horizontal  and vertical  lines: lines  where
either x1 = x2 or y1 = y2.

So,  the horizontal  and  vertical  lines from  the  above list  would
produce the following diagram:

#+begin_example
.......1..
..1....1..
..1....1..
.......1..
.112111211
..........
..........
..........
..........
222111....
#+end_example

In  this diagram,  the top  left corner  is 0,0  and the  bottom right
corner is  9,9. Each position  is shown as  the number of  lines which
cover that point or . if no  line covers that point. The top-left pair
of 1s,  for example,  comes from 2,2  -> 2,1; the  very bottom  row is
formed by the overlapping lines 0,9 -> 5,9 and 0,9 -> 2,9.

To avoid the most dangerous areas, you need to determine the number of
points where at least two lines overlap. In the above example, this is
anywhere in the diagram with a 2 or larger - a total of 5 points.

Consider only horizontal and vertical lines.  At how many points do at
least two lines overlap?

#+begin_src fennel -n :session d2105 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["0,9 -> 5,9"
                   "8,0 -> 0,8"
                   "9,4 -> 3,4"
                   "2,2 -> 2,1"
                   "7,0 -> 7,4"
                   "6,4 -> 2,0"
                   "0,9 -> 2,9"
                   "3,4 -> 1,4"
                   "0,0 -> 8,8"
                   "5,5 -> 8,2"])

(fn create-matrix [n]
  (let [res []]
    (for [i 1 n]
      (table.insert res (aoc.range-of 0 n)))
    res))

(fn table-inc [xs]
  (lume.map xs #(+ 1 $)))

(fn diagonal [x1 y1 x2 y2]
  (let [xs (aoc.range-to x1 x2)
        ys (aoc.range-to y1 y2)]
    (aoc.table-zip 
     (if (> x1 x2)
         (aoc.table-reverse xs)
         xs)
     (if (> y1 y2)
         (aoc.table-reverse ys)
         ys))))

(fn read-lines [lines diagonals]
  (let [res (create-matrix 1000)]
    (each [_ line (ipairs lines)]
      (let [[x1 y1 x2 y2] (table-inc (aoc.string-tonumarray line))]
        (if (= x1 x2)
            (for [y (math.min y1 y2) (math.max y1 y2)]
              (let [v (+ 1 (. (. res y) x1))]
                (aoc.table-replace res y x1 v)))
            (= y1 y2)
            (for [x (math.min x1 x2) (math.max x1 x2)]
              (let [v (+ 1 (. (. res y1) x))] 
                (aoc.table-replace res y1 x v)))
            (when diagonals
              (each [_ [x y] (ipairs (diagonal x1 y1 x2 y2))]
                (aoc.table-replace res y x (+ 1 (. (. res y) x))))))))
    res))

(fn solve [lines]
  (let [xs (read-lines lines false)]
    (accumulate [sum 0 _ x (ipairs xs)]
      (+ sum (length (lume.filter x #(< 1 $)))))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 5 test-input)

(solve (aoc.string-from "2021/05.inp"))
#+end_src

#+RESULTS:
: 8622

** DONE Day 5.2

Unfortunately, considering only horizontal  and vertical lines doesn't
give you the full picture; you need to also consider diagonal lines.

Because of  the limits  of the hydrothermal  vent mapping  system, the
lines  in your  list  will only  ever be  horizontal,  vertical, or  a
diagonal line at exactly 45 degrees. In other words:
- An entry like 1,1 -> 3,3 covers points 1,1, 2,2, and 3,3.
- An entry like 9,7 -> 7,9 covers points 9,7, 8,8, and 7,9.

Considering all  lines from  the above example  would now  produce the
following diagram:

#+begin_example
1.1....11.
.111...2..
..2.1.111.
...1.2.2..
.112313211
...1.2....
..1...1...
.1.....1..
1.......1.
222111....
#+end_example

You still  need to determine the  number of points where  at least two
lines overlap.  In the above  example, this  is still anywhere  in the
diagram with a 2 or larger - now a total of 12 points.

Consider all of  the lines. At how  many points do at  least two lines
overlap?

#+begin_src fennel -n :session d2105 :exports both
(fn solve2 [lines]
  (let [xs (read-lines lines true)]
    (accumulate [sum 0 _ x (ipairs xs)]
      (+ sum (length (lume.filter x #(< 1 $)))))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 12 test-input)

(solve2 (aoc.string-from "2021/05.inp"))
#+end_src

#+RESULTS:
: 22037

** DONE Day 6.1

The sea floor is getting steeper. Maybe the sleigh keys got carried
this way?

A massive  school of glowing  lanternfish swims past. They  must spawn
quickly to reach such large numbers - maybe exponentially quickly? You
should model their growth rate to be sure.

Although you know nothing about  this specific species of lanternfish,
you make some guesses about their attributes. Surely, each lanternfish
creates a new lanternfish once every 7 days.

However,  this process  isn't necessarily  synchronized between  every
lanternfish - one lanternfish might have  2 days left until it creates
another lanternfish,  while another  might have 4.  So, you  can model
each fish as a single number  that represents the number of days until
it creates a new lanternfish.

Furthermore, you reason, a new  lanternfish would surely need slightly
longer before  it's capable  of producing  more lanternfish:  two more
days for its first cycle.

So, suppose you have a lanternfish with an internal timer value of 3:
- After one day, its internal timer would become 2.
- After another day, its internal timer would become 1.
- After another day, its internal timer would become 0.
- After another day, its internal timer would reset to 6, and it would
  create a new lanternfish with an internal timer of 8.
- After another day, the first lanternfish would have an internal
  timer of 5, and the second lanternfish would have an internal timer
  of 7.
  
A lanternfish  that creates a  new fish resets its  timer to 6,  not 7
(because 0  is included as a  valid timer value). The  new lanternfish
starts with  an internal timer of  8 and does not  start counting down
until the next day.

Realizing  what  you're  trying  to do,  the  submarine  automatically
produces  a list  of the  ages of  several hundred  nearby lanternfish
(your puzzle input). For example, suppose you were given the following
list:

#+begin_example
3,4,3,1,2
#+end_example

This list means  that the first fish  has an internal timer  of 3, the
second fish  has an  internal timer of  4, and so  on until  the fifth
fish, which  has an internal  timer of  2. Simulating these  fish over
several days would proceed as follows:

#+begin_example
Initial state: 3,4,3,1,2
After  1 day:  2,3,2,0,1
After  2 days: 1,2,1,6,0,8
After  3 days: 0,1,0,5,6,7,8
After  4 days: 6,0,6,4,5,6,7,8,8
After  5 days: 5,6,5,3,4,5,6,7,7,8
After  6 days: 4,5,4,2,3,4,5,6,6,7
After  7 days: 3,4,3,1,2,3,4,5,5,6
After  8 days: 2,3,2,0,1,2,3,4,4,5
After  9 days: 1,2,1,6,0,1,2,3,3,4,8
After 10 days: 0,1,0,5,6,0,1,2,2,3,7,8
After 11 days: 6,0,6,4,5,6,0,1,1,2,6,7,8,8,8
After 12 days: 5,6,5,3,4,5,6,0,0,1,5,6,7,7,7,8,8
After 13 days: 4,5,4,2,3,4,5,6,6,0,4,5,6,6,6,7,7,8,8
After 14 days: 3,4,3,1,2,3,4,5,5,6,3,4,5,5,5,6,6,7,7,8
After 15 days: 2,3,2,0,1,2,3,4,4,5,2,3,4,4,4,5,5,6,6,7
After 16 days: 1,2,1,6,0,1,2,3,3,4,1,2,3,3,3,4,4,5,5,6,8
After 17 days: 0,1,0,5,6,0,1,2,2,3,0,1,2,2,2,3,3,4,4,5,7,8
After 18 days: 6,0,6,4,5,6,0,1,1,2,6,0,1,1,1,2,2,3,3,4,6,7,8,8,8,8
#+end_example

Each day, a 0 becomes a 6 and adds a new 8 to the end of the list,
while each other number decreases by 1 if it was present at the start
of the day.

In this example, after 18 days, there are a total of 26 fish. After 80
days, there would be a total of 5934.

Find a way to simulate lanternfish. How many lanternfish would there
be after 80 days?

#+begin_src fennel -n :session d2106 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input "3,4,3,1,2")

(fn life-cycle [xs]
  (let [result []]
    (each [_ x (ipairs xs)]
      (case x
        0 (do
            (table.insert result 6)
            (table.insert result 8))
        _ (table.insert result (- x 1))))
    result))

(fn solve [input]
  (var res (aoc.string-tonumarray (. input 1)))
  (for [i 1 80]
    (set res (life-cycle res)))
  (length res))

(fn test [expected input]
  (assert (= expected (solve [input]))))

(test 5934 test-input)

(solve (aoc.string-from "2021/06.inp"))
#+end_src

#+RESULTS:
: 354564

** DONE Day 6.2

Suppose  the lanternfish  live  forever and  have  unlimited food  and
space. Would they take over the entire ocean?

After  256 days  in  the example  above,  there would  be  a total  of
26984457539 lanternfish! How many lanternfish would there be after 256
days?

#+begin_src fennel -n :session d2106 :exports both
(fn read-input [input]
  (let [population [0 0 0 0 0 0 0 0 0]]
    (icollect [_ x (ipairs (aoc.string-tonumarray input))]
      (tset population (+ 1 x) (+ 1 (. population (+ 1 x)))))
    population))

(fn life-cycle2 [xs]
  [(. xs 2)
   (. xs 3)
   (. xs 4)
   (. xs 5)
   (. xs 6)
   (. xs 7)
   (+ (. xs 8) (. xs 1))
   (. xs 9)
   (. xs 1)])

(fn run-cycle [input cycles]
  (if (= 0 cycles) input
      (run-cycle (life-cycle2 input) (- cycles 1))))

(fn solve2 [input]
  (aoc.table-sum (run-cycle (read-input (. input 1)) 256)))

(fn test2 [expected input]
  (assert (= expected (solve2 [input]))))

(test2 26984457539 test-input)

(solve2 (aoc.string-from "2021/06.inp"))
#+end_src

#+RESULTS:
: 1609058859115

** DONE Day 7.1

A giant  whale has decided your  submarine is its next  meal, and it's
much faster than you are. There's nowhere to run!

Suddenly, a swarm of crabs (each in  its own tiny submarine - it's too
deep  for them  otherwise) zooms  in to  rescue you!  They seem  to be
preparing  to blast  a hole  in the  ocean floor;  sensors indicate  a
massive underground cave system just beyond where they're aiming!

The crab submarines all need to  be aligned before they'll have enough
power  to  blast  a  large  enough hole  for  your  submarine  to  get
through. However, it  doesn't look like they'll be  aligned before the
whale catches you! Maybe you can help?

There's one major catch - crab submarines can only move horizontally.

You quickly make a list of  the horizontal position of each crab (your
puzzle input). Crab submarines have limited  fuel, so you need to find
a way to make all of  their horizontal positions match while requiring
them to spend as little fuel as possible.

For example, consider the following horizontal positions:

#+begin_example
16,1,2,0,4,2,7,1,2,14
#+end_example

This means  there's a crab  with horizontal  position 16, a  crab with
horizontal position 1, and so on.

Each change of 1 step in horizontal  position of a single crab costs 1
fuel. You could  choose any horizontal position to align  them all on,
but the one that costs the least fuel is horizontal position 2:
- Move from 16 to 2: 14 fuel
- Move from 1 to 2: 1 fuel
- Move from 2 to 2: 0 fuel
- Move from 0 to 2: 2 fuel
- Move from 4 to 2: 2 fuel
- Move from 2 to 2: 0 fuel
- Move from 7 to 2: 5 fuel
- Move from 1 to 2: 1 fuel
- Move from 2 to 2: 0 fuel
- Move from 14 to 2: 12 fuel

This costs a total of 37  fuel. This is the cheapest possible outcome;
more  expensive outcomes  include aligning  at position  1 (41  fuel),
position 3 (39 fuel), or position 10 (71 fuel).

Determine the horizontal position that the crabs can align to using
the least fuel possible. How much fuel must they spend to align to
that position?

#+begin_src fennel -n :session d2107 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input "16,1,2,0,4,2,7,1,2,14")

(fn even? [x]
  (= 0 (% x 2)))

(fn median [xs]
  (table.sort xs)
  (let [len (length xs)
        mid (aoc.int/ len 2)]
    (if (even? len)
        (/ (+ (. xs mid) (. xs (aoc.inc mid))) 2)
        (. xs (+ 1 mid)))))

(fn solve [input]
  (let [in (aoc.string-tonumarray (. input 1))
        med (median in)]
    (aoc.table-sum
     (icollect [_ v (ipairs in)]
       (math.abs (- med v))))))

(fn test [expected input]
  (assert (= expected (solve [input]))))

(test 37 test-input)

(solve (aoc.string-from "2021/07.inp"))
#+end_src

#+RESULTS:
: 336131

** DONE Day 7.2

The crabs don't seem interested in your proposed solution. Perhaps you
misunderstand crab engineering?

As it turns out, crab submarine  engines don't burn fuel at a constant
rate. Instead,  each change of 1  step in horizontal position  costs 1
more unit of  fuel than the last:  the first step costs  1, the second
step costs 2, the third step costs 3, and so on.

As  each  crab moves,  moving  further  becomes more  expensive.  This
changes the  best horizontal  position to  align them  all on;  in the
example above, this becomes 5:

- Move from 16 to 5: 66 fuel
- Move from 1 to 5: 10 fuel
- Move from 2 to 5: 6 fuel
- Move from 0 to 5: 15 fuel
- Move from 4 to 5: 1 fuel
- Move from 2 to 5: 6 fuel
- Move from 7 to 5: 3 fuel
- Move from 1 to 5: 10 fuel
- Move from 2 to 5: 6 fuel
- Move from 14 to 5: 45 fuel

This costs  a total  of 170  fuel. This is  the new  cheapest possible
outcome; the old alignment position (2) now costs 206 fuel instead.

Determine the  horizontal position that  the crabs can align  to using
the least fuel possible so they can make you an escape route! How much
fuel must they spend to align to that position?

#+begin_src fennel -n :session d2107 :exports both
(fn mean [xs]
  (let [sum (aoc.table-sum xs)
        cnt (length xs)]
    (math.floor (/ sum cnt))))

(fn sum [n]
  (/ (* n (+ 1 n)) 2))

(fn fuel [f t]
  (sum (math.abs (- f t))))

(fn solve2 [input]
  (let [in (aoc.string-tonumarray (. input 1))
        med (mean in)]
    (aoc.table-sum 
     (icollect [_ v (ipairs in)]
       (fuel med v)))))

(fn test2 [expected input]
  (assert (= expected (solve2 [input]))))

(test2 170 test-input)

(solve2 (aoc.string-from "2021/07.inp"))
#+end_src

#+RESULTS:
: 92676646

** TODO Day 8.1                                                   :noexport:

You barely reach the safety of the cave when the whale smashes into
the cave mouth, collapsing it. Sensors indicate another exit to this
cave at a much greater depth, so you have no choice but to press on.

As your  submarine slowly makes its  way through the cave  system, you
notice that  the four-digit  seven-segment displays in  your submarine
are   malfunctioning;  they   must  have   been  damaged   during  the
escape. You'll  be in a lot  of trouble without them,  so you'd better
figure out what's wrong.

Each digit of a seven-segment display is rendered by turning on or off
any of seven segments named a through g:

#+begin_example
  0:      1:      2:      3:      4:
 aaaa    ....    aaaa    aaaa    ....
b    c  .    c  .    c  .    c  b    c
b    c  .    c  .    c  .    c  b    c
 ....    ....    dddd    dddd    dddd
e    f  .    f  e    .  .    f  .    f
e    f  .    f  e    .  .    f  .    f
 gggg    ....    gggg    gggg    ....

  5:      6:      7:      8:      9:
 aaaa    aaaa    aaaa    aaaa    aaaa
b    .  b    .  .    c  b    c  b    c
b    .  b    .  .    c  b    c  b    c
 dddd    dddd    ....    dddd    dddd
.    f  e    f  .    f  e    f  .    f
.    f  e    f  .    f  e    f  .    f
 gggg    gggg    ....    gggg    gggg
#+end_example

So, to render a 1, only segments c and f would be turned on; the rest
would be off. To render a 7, only segments a, c, and f would be turned
on.

The problem is  that the signals which control the  segments have been
mixed up  on each display.  The submarine  is still trying  to display
numbers by  producing output on  signal wires  a through g,  but those
wires  are connected  to  segments randomly.  Worse, the  wire/segment
connections are mixed up separately  for each four-digit display! (All
of the digits within a display use the same connections, though.)

So, you might know  that only signal wires b and g  are turned on, but
that doesn't mean segments b and g  are turned on: the only digit that
uses two segments is 1, so it must  mean segments c and f are meant to
be on.  With just that  information, you  still can't tell  which wire
(b/g) goes  to which segment (c/f).  For that, you'll need  to collect
more information.

For each display,  you watch the changing signals for  a while, make a
note of all ten unique signal patterns  you see, and then write down a
single four digit  output value (your puzzle input).  Using the signal
patterns, you should be able to  work out which pattern corresponds to
which digit.

For example, here is what you might see in a single entry in your
notes:
#+begin_example
acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab |
cdfeb fcadb cdfeb cdbaf
#+end_example

(The entry is wrapped here to two lines so it fits; in your notes, it
will all be on a single line.)

Each entry consists of ten unique  signal patterns, a | delimiter, and
finally  the  four digit  output  value.  Within  an entry,  the  same
wire/segment  connections  are  used  (but you  don't  know  what  the
connections actually  are). The  unique signal patterns  correspond to
the ten different ways the submarine tries to render a digit using the
current wire/segment  connections. Because  7 is  the only  digit that
uses three segments,  dab in the above example means  that to render a
7, signal lines d,  a, and b are on. Because 4 is  the only digit that
uses four segments, eafb means that to  render a 4, signal lines e, a,
f, and b are on.

Using  this  information,  you  should  be  able  to  work  out  which
combination  of   signal  wires  corresponds   to  each  of   the  ten
digits.    Then,   you    can   decode    the   four    digit   output
value. Unfortunately, in  the above example, all of the  digits in the
output value (cdfeb fcadb cdfeb cdbaf)  use five segments and are more
difficult to deduce.

For now, focus on the easy digits. Consider this larger example:
#+begin_example
be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb |
fdgacbe cefdb cefbgd gcbe
edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec |
fcgedb cgb dgebacf gc
fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef |
cg cg fdcagb cbg
fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega |
efabcd cedba gadfec cb
aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga |
gecf egdcabf bgf bfgea
fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf |
gebdcfa ecba ca fadegcb
dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf |
cefg dcbef fcge gbcadfe
bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd |
ed bcgafe cdgba cbgef
egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg |
gbdfcae bgc cg cgb
gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc |
fgae cfgab fg bagce
#+end_example

Because  the digits  1,  4, 7,  and  8  each use  a  unique number  of
segments, you  should be  able to tell  which combinations  of signals
correspond to those digits. Counting  only digits in the output values
(the part after  | on each line),  in the above example,  there are 26
instances of digits that use  a unique number of segments (highlighted
above).

In the output values, how many times do digits 1, 4, 7, or 8 appear?
** TODO Day 8.2                                                   :noexport:

** DONE Day 9.1

These caves seem  to be lava tubes. Parts are  even still volcanically
active; small  hydrothermal vents  release smoke  into the  caves that
slowly settles like rain.

If you can model  how the smoke flows through the  caves, you might be
able to  avoid it and  be that much  safer. The submarine  generates a
heightmap  of the  floor  of the  nearby caves  for  you (your  puzzle
input).

Smoke flows to the lowest point of the area it's in. For example,
consider the following heightmap:

#+begin_example
2199943210
3987894921
9856789892
8767896789
9899965678
#+end_example

Each number corresponds to the  height of a particular location, where
9 is the highest and 0 is the lowest a location can be.

Your first  goal is to  find the low points  - the locations  that are
lower than  any of  its adjacent locations.  Most locations  have four
adjacent locations (up, down, left,  and right); locations on the edge
or  corner  of   the  map  have  three  or   two  adjacent  locations,
respectively. (Diagonal locations do not count as adjacent.)

In the above example, there are  four low points, all highlighted: two
are in the first row (a 1 and a 0), one is in the third row (a 5), and
one  is in  the bottom  row (also  a 5).  All other  locations on  the
heightmap  have some  lower  adjacent  location, and  so  are not  low
points.

The risk  level of  a low  point is 1  plus its  height. In  the above
example, the risk levels of the low points are 2, 1, 6, and 6. The sum
of the risk levels of all low points in the heightmap is therefore 15.

Find all of the low points on your heightmap. What is the sum of the
risk levels of all low points on your heightmap?

#+begin_src fennel -n :session d2109 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["2199943210"
                   "3987894921"
                   "9856789892"
                   "8767896789"
                   "9899965678"])

(fn is-low? [xs i j]
  (let [ij (. (. xs i) j)
        lf (or (?. (?. xs i) (- j 1)) 10)
        rg (or (?. (?. xs i) (+ j 1)) 10)
        up (or (?. (?. xs (- i 1)) j) 10)
        dn (or (?. (?. xs (+ i 1)) j) 10)]
    (and
     (< ij up)
     (< ij dn)
     (< ij lf)
     (< ij rg))))

(fn solve [lines]
  (var res 0)
  (let [input (aoc.read-matrix lines true)]
    (for [i 1 (length input)]
      (for [j 1 (length (. input i))]
        (when (is-low? input i j)
          (set res (+ res (+ 1 (. (. input i) j))))))))
  res)

(fn test [expected input]
  (assert (= expected (solve input))))

(test 15 test-input)

(solve (aoc.string-from "2021/09.inp"))
#+end_src

#+RESULTS:
: 522

** DONE Day 9.2

Next, you need to  find the largest basins so you  know what areas are
most important to avoid.

A basin is all locations that eventually flow downward to a single low
point. Therefore,  every low point  has a basin, although  some basins
are very  small. Locations of  height 9 do not  count as being  in any
basin, and  all other  locations will  always be  part of  exactly one
basin.

The  size of  a basin  is the  number of  locations within  the basin,
including the low point. The example above has four basins.

The top-left basin, size 3:

#+begin_example
2199943210
3987894921
9856789892
8767896789
9899965678
#+end_example

The top-right basin, size 9:

#+begin_example
2199943210
3987894921
9856789892
8767896789
9899965678
#+end_example

The middle basin, size 14:

#+begin_example
2199943210
3987894921
9856789892
8767896789
9899965678
#+end_example

The bottom-right basin, size 9:

#+begin_example
2199943210
3987894921
9856789892
8767896789
9899965678
#+end_example

Find the  three largest basins  and multiply their sizes  together. In
the above example, this is 9 * 14 * 9 = 1134.

What  do you  get if  you  multiply together  the sizes  of the  three
largest basins?

#+begin_src fennel -n :session d2109 :exports both
(fn table-contains? [xs e]
  (var contains false)
  (each [i x (ipairs xs) &until contains]
    (when (and (= (. e 1) (. x 1))
               (= (. e 2) (. x 2)))
      (set contains true)))
  contains)

(fn size-basin [xs basin low]
  (let [[i j] low
        ij (or (?. (?. xs i) j) 10)
        lf (or (?. (?. xs i) (- j 1)) 10)
        rg (or (?. (?. xs i) (+ j 1)) 10)
        up (or (?. (?. xs (- i 1)) j) 10)
        dn (or (?. (?. xs (+ i 1)) j) 10)]
    (when (and (< ij 9)
               (not (table-contains? basin low)))
      (table.insert basin low)
      (when (and (<= ij up) (< up 9))
        (size-basin xs basin [(- i 1) j]))
      (when (and (<= ij dn) (< dn 9))
        (size-basin xs basin [(+ i 1) j]))
      (when (and (<= ij lf) (< lf 9))
        (size-basin xs basin [i (- j 1)]))
      (when (and (<= ij rg) (< rg 9))
        (size-basin xs basin [i (+ j 1)]))))
  (length basin))

(fn solve2 [lines]
  (let [input (aoc.read-matrix lines true)
        res []]
    (for [i 1 (length input)]
      (for [j 1 (length (. input i))]
        (when (is-low? input i j)
          (table.insert res (size-basin input [] [i j])))))
    (table.sort res)
    (* (table.remove res)
       (table.remove res)
       (table.remove res))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 1134 test-input)

(solve2 (aoc.string-from "2021/09.inp"))
#+end_src

#+RESULTS:
: 916688

** DONE Day 10.1

You ask the submarine to determine  the best route out of the deep-sea
cave, but it only replies:

Syntax error in navigation subsystem on line: all of them

All of  them?! The damage  is worse than you  thought. You bring  up a
copy of the navigation subsystem (your puzzle input).

The navigation  subsystem syntax is  made of several  lines containing
chunks. There are one or more  chunks on each line, and chunks contain
zero or  more other chunks. Adjacent  chunks are not separated  by any
delimiter; if one chunk stops, the next chunk (if any) can immediately
start. Every chunk must open and close with one of four legal pairs of
matching characters:
- If a chunk opens with (, it must close with ).
- If a chunk opens with [, it must close with ].
- If a chunk opens with {, it must close with }.
- If a chunk opens with <, it must close with >.

So, () is a legal chunk that  contains no other chunks, as is []. More
complex   but  valid   chunks   include   ([]),  {()()()},   <([{}])>,
[<>({}){}[([])<>]], and even (((((((((()))))))))).

Some lines are incomplete, but  others are corrupted. Find and discard
the corrupted lines first.

A  corrupted  line  is  one  where  a  chunk  closes  with  the  wrong
character - that is, where the  characters it opens and closes with do
not form one of the four legal pairs listed above.

Examples of corrupted chunks include (], {()()()>, (((()))}, and
<([]){()}[{}]). Such a chunk can appear anywhere within a line, and
its presence causes the whole line to be considered corrupted.

For example, consider the following navigation subsystem:

#+begin_example
[({(<(())[]>[[{[]{<()<>>
[(()[<>])]({[<{<<[]>>(
{([(<{}[<>[]}>{[]{[(<()>
(((({<>}<{<{<>}{[]{[]{}
[[<[([]))<([[{}[[()]]]
[{[{({}]{}}([{[{{{}}([]
{<[[]]>}<{[{[{[]{()[[[]
[<(<(<(<{}))><([]([]()
<{([([[(<>()){}]>(<<{{
<{([{{}}[<[[[<>{}]]]>[]]
#+end_example

Some of the lines aren't corrupted, just incomplete; you can ignore
these lines for now. The remaining five lines are corrupted:

#+begin_example
{([(<{}[<>[]}>{[]{[(<()> - Expected ], but found } instead.
[[<[([]))<([[{}[ [()]]] - Expected ], but found ) instead.
[{[{({}]{}}([{[{{{}}([] - Expected ), but found ] instead.
[<(<(<(<{}))><([]([]() - Expected >, but found ) instead.
<{([([[(<>()){}]>(<<{{ - Expected ], but found > instead.
#+end_example

Stop at the first incorrect closing character on each corrupted line.

Did you  know that syntax checkers  actually have contests to  see who
can get  the high  score for syntax  errors in a  file? It's  true! To
calculate the  syntax error score for  a line, take the  first illegal
character on the line and look it up in the following table:
- ): 3 points.
- ]: 57 points.
- }: 1197 points.
- >: 25137 points.

In the above example,  an illegal ) was found twice  (2*3 = 6 points),
an illegal ] was  found once (57 points), an illegal  } was found once
(1197 points), and an illegal > was found once (25137 points). So, the
total  syntax error  score for  this file  is 6+57+1197+25137  = 26397
points!

Find  the  first illegal  character  in  each  corrupted line  of  the
navigation subsystem. What  is the total syntax error  score for those
errors?

#+begin_src fennel -n :session d2110 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["[({(<(())[]>[[{[]{<()<>>"
                   "[(()[<>])]({[<{<<[]>>("
                   "{([(<{}[<>[]}>{[]{[(<()>"
                   "(((({<>}<{<{<>}{[]{[]{}"
                   "[[<[([]))<([[{}[[()]]]"
                   "[{[{({}]{}}([{[{{{}}([]" 
                   "{<[[]]>}<{[{[{[]{()[[[]"
                   "[<(<(<(<{}))><([]([]()"
                   "<{([([[(<>()){}]>(<<{{"
                   "<{([{{}}[<[[[<>{}]]]>[]]"])

(fn solve [lines]
  (let [result []]
    (each [_ line (ipairs lines)]
      (let [stack []
            input (aoc.string-toarray line)]
        (var stop false)
        (each [_ chunk (ipairs input) &until stop]
          (case chunk
            "<" (table.insert stack -25137)
            "{" (table.insert stack -1197)
            "[" (table.insert stack -57)
            "(" (table.insert stack -3)
            ">" (when (not= 0 (+ 25137 (table.remove stack)))
                  (table.insert result 25137)
                  (set stop true))
            "}" (when (not= 0 (+ 1197 (table.remove stack)))
                  (table.insert result 1197)
                  (set stop true))
            "]" (when (not= 0 (+ 57 (table.remove stack)))
                  (table.insert result 57)
                  (set stop true))
            ")" (when (not= 0 (+ 3 (table.remove stack)))
                  (table.insert result 3)
                  (set stop true))))))
    (aoc.table-sum result)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 26397 test-input)

(solve (aoc.string-from "2021/10.inp"))
#+end_src

#+RESULTS:
: 399153

** DONE Day 10.2
Now, discard the corrupted lines. The remaining lines are incomplete.

Incomplete  lines  don't  have  any incorrect  characters  -  instead,
they're missing  some closing characters  at the  end of the  line. To
repair  the navigation  subsystem, you  just  need to  figure out  the
sequence of  closing characters that  complete all open chunks  in the
line.

You can only use closing characters (),  ], }, or >), and you must add
them in the correct order so that  only legal pairs are formed and all
chunks end up closed.

In the example above, there are five incomplete lines:

#+begin_example
[({(<(())[]>[[{[]{<()<>> - Complete by adding }}]])})].
[(()[<>])]({[<{<<[]>>( - Complete by adding )}>]}).
(((({<>}<{<{<>}{[]{[]{} - Complete by adding }}>}>)))).
{<[[]]>}<{[{[{[]{()[[[] - Complete by adding ]]}}]}]}>.
<{([{{}}[<[[[<>{}]]]>[]] - Complete by adding ])}>.
#+end_example
  
Did you know  that autocomplete tools also have  contests?  It's true!
The  score   is  determined  by  considering   the  completion  string
character-by-character. Start with a total  score of 0. Then, for each
character, multiply the  total score by 5 and then  increase the total
score by  the point  value given  for the  character in  the following
table:
- ): 1 point.
- ]: 2 points.
- }: 3 points.
- >: 4 points.

So,  the last  completion string  above -  ])}> -  would be  scored as
follows:
- Start with a total score of 0.
- Multiply the total score by 5 to get 0, then add the value of ] (2)
  to get a new total score of 2.
- Multiply the total score by 5 to get 10, then add the value of ) (1)
  to get a new total score of 11.
- Multiply the total score by 5 to get 55, then add the value of } (3)
  to get a new total score of 58.
- Multiply the total score by 5 to get 290, then add the value of >
  (4) to get a new total score of 294.
  
The five lines' completion strings have total scores as follows:

#+begin_example
}}]])})] - 288957 total points.
)}>]}) - 5566 total points.
}}>}>)))) - 1480781 total points.
]]}}]}]}> - 995444 total points.
])}> - 294 total points.
#+end_example

Autocomplete tools  are an odd bunch:  the winner is found  by sorting
all of the scores and then taking the middle score. (There will always
be an odd  number of scores to consider.) In  this example, the middle
score is  288957 because there are  the same number of  scores smaller
and larger than it.

Find  the  completion  string  for each  incomplete  line,  score  the
completion strings, and sort the scores. What is the middle score?

#+begin_src fennel -n :session d2110 :exports both
(fn complete [xs]
  (var score 0)
  (each [_ v (ipairs xs)]
    (case v
      -3 (set score (+ (* 5 score) 1))
      -57 (set score (+ (* 5 score) 2))
      -1197 (set score (+ (* 5 score) 3))
      -25137 (set score (+ (* 5 score) 4))))
  score)

(fn solve2 [lines]
  (let [result []]
    (each [_ line (ipairs lines)]
      (let [stack []
            input (aoc.string-toarray line)]
        (var stop false)
        (each [_ chunk (ipairs input) &until stop]
          (case chunk
            "<" (table.insert stack -25137)
            "{" (table.insert stack -1197)
            "[" (table.insert stack -57)
            "(" (table.insert stack -3)
            ">" (when (not= 0 (+ 25137 (table.remove stack)))
                  (set stop true))
            "}" (when (not= 0 (+ 1197 (table.remove stack)))
                  (set stop true))
            "]" (when (not= 0 (+ 57 (table.remove stack)))
                  (set stop true))
            ")" (when (not= 0 (+ 3 (table.remove stack)))
                  (set stop true))))
        (when (not stop)
          (table.insert result (complete (aoc.table-reverse stack))))))
    (table.sort result)
    (let [mid (+ 1 (aoc.int/ (length result) 2))]
      (. result mid))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 288957 test-input)

(solve2 (aoc.string-from "2021/10.inp"))
#+end_src

#+RESULTS:
: 2995077699

** TODO Day 11.1                                                  :noexport:

You enter a large cavern  full of rare bioluminescent dumbo octopuses!
They seem to  not like the Christmas lights on  your submarine, so you
turn them off for now.

There  are 100  octopuses arranged  neatly in  a 10  by 10  grid. Each
octopus  slowly gains  energy over  time  and flashes  brightly for  a
moment when  its energy is full.  Although your lights are  off, maybe
you could navigate  through the cave without  disturbing the octopuses
if you could predict when the flashes of light will happen.

Each octopus has an energy level - your submarine can remotely measure
the energy level of each octopus (your puzzle input). For example:

#+begin_example
5483143223
2745854711
5264556173
6141336146
6357385478
4167524645
2176841721
6882881134
4846848554
5283751526
#+end_example

The energy level of each octopus is a value between 0 and 9. Here, the
top-left octopus has an energy level of 5, the bottom-right one has an
energy level of 6, and so on.

You can model the energy levels and flashes of light in steps. During
a single step, the following occurs:
- First, the energy level of each octopus increases by 1.
- Then, any octopus with an energy level greater than 9 flashes. This
  increases the energy level of all adjacent octopuses by 1, including
  octopuses that are diagonally adjacent. If this causes an octopus to
  have an energy level greater than 9, it also flashes. This process
  continues as long as new octopuses keep having their energy level
  increased beyond 9. (An octopus can only flash at most once per
  step.)
- Finally, any octopus that flashed during this step has its energy
  level set to 0, as it used all of its energy to flash.
  

Adjacent flashes can cause an octopus to flash on a step even if it
begins that step with very little energy. Consider the middle octopus
with 1 energy in this situation:

#+begin_example
Before any steps:
11111
19991
19191
19991
11111

After step 1:
34543
40004
50005
40004
34543

After step 2:
45654
51115
61116
51115
45654
#+end_example

An octopus is highlighted when it flashed during the given step.

Here is how the larger example above progresses:
#+begin_example
Before any steps:
5483143223
2745854711
5264556173
6141336146
6357385478
4167524645
2176841721
6882881134
4846848554
5283751526

After step 1:
6594254334
3856965822
6375667284
7252447257
7468496589
5278635756
3287952832
7993992245
5957959665
6394862637

After step 2:
8807476555
5089087054
8597889608
8485769600
8700908800
6600088989
6800005943
0000007456
9000000876
8700006848

After step 3:
0050900866
8500800575
9900000039
9700000041
9935080063
7712300000
7911250009
2211130000
0421125000
0021119000

After step 4:
2263031977
0923031697
0032221150
0041111163
0076191174
0053411122
0042361120
5532241122
1532247211
1132230211

After step 5:
4484144000
2044144000
2253333493
1152333274
1187303285
1164633233
1153472231
6643352233
2643358322
2243341322

After step 6:
5595255111
3155255222
3364444605
2263444496
2298414396
2275744344
2264583342
7754463344
3754469433
3354452433

After step 7:
6707366222
4377366333
4475555827
3496655709
3500625609
3509955566
3486694453
8865585555
4865580644
4465574644

After step 8:
7818477333
5488477444
5697666949
4608766830
4734946730
4740097688
6900007564
0000009666
8000004755
6800007755

After step 9:
9060000644
7800000976
6900000080
5840000082
5858000093
6962400000
8021250009
2221130009
9111128097
7911119976

After step 10:
0481112976
0031112009
0041112504
0081111406
0099111306
0093511233
0442361130
5532252350
0532250600
0032240000
#+end_example

After step 10, there have been a total of 204 flashes. Fast
forwarding, here is the same configuration every 10 steps:

#+begin_example
After step 20:
3936556452
5686556806
4496555690
4448655580
4456865570
5680086577
7000009896
0000000344
6000000364
4600009543

After step 30:
0643334118
4253334611
3374333458
2225333337
2229333338
2276733333
2754574565
5544458511
9444447111
7944446119

After step 40:
6211111981
0421111119
0042111115
0003111115
0003111116
0065611111
0532351111
3322234597
2222222976
2222222762

After step 50:
9655556447
4865556805
4486555690
4458655580
4574865570
5700086566
6000009887
8000000533
6800000633
5680000538

After step 60:
2533334200
2743334640
2264333458
2225333337
2225333338
2287833333
3854573455
1854458611
1175447111
1115446111

After step 70:
8211111164
0421111166
0042111114
0004211115
0000211116
0065611111
0532351111
7322235117
5722223475
4572222754

After step 80:
1755555697
5965555609
4486555680
4458655580
4570865570
5700086566
7000008666
0000000990
0000000800
0000000000

After step 90:
7433333522
2643333522
2264333458
2226433337
2222433338
2287833333
2854573333
4854458333
3387779333
3333333333

After step 100:
0397666866
0749766918
0053976933
0004297822
0004229892
0053222877
0532222966
9322228966
7922286866
6789998766
#+end_example

After 100 steps, there have been a total of 1656 flashes.

Given  the starting  energy  levels  of the  dumbo  octopuses in  your
cavern, simulate 100 steps. How many total flashes are there after 100
steps?
** TODO Day 11.2                                                  :noexport:

** TODO Day 12.1                                                  :noexport:

With your submarine's subterranean subsystems subsisting suboptimally,
the  only way  you're getting  out  of this  cave anytime  soon is  by
finding a  path yourself. Not just  a path -  the only way to  know if
you've found the best path is to find all of them.

Fortunately, the sensors are still mostly working, and so you build a
rough map of the remaining caves (your puzzle input). For example:

#+begin_example
start-A
start-b
A-c
A-b
b-d
A-end
b-end
#+end_example

This is a list of how all of the caves are connected. You start in the
cave named start, and your destination is the cave named end. An entry
like b-d means that  cave b is connected to cave d -  that is, you can
move between them.

So, the above cave system looks roughly like this:

#+begin_example
    start
    /   \
c--A-----b--d
    \   /
     end
#+end_example

Your goal is to find the number of distinct paths that start at start,
end at end, and don't visit small  caves more than once. There are two
types of  caves: big caves  (written in  uppercase, like A)  and small
caves (written in lowercase,  like b). It would be a  waste of time to
visit any  small cave more than  once, but big caves  are large enough
that it might be worth visiting them multiple times. So, all paths you
find should  visit small caves at  most once, and can  visit big caves
any number of times.


Given these rules, there are 10 paths through this example cave system:

#+begin_example
start,A,b,A,c,A,end
start,A,b,A,end
start,A,b,end
start,A,c,A,b,A,end
start,A,c,A,b,end
start,A,c,A,end
start,A,end
start,b,A,c,A,end
start,b,A,end
start,b,end
#+end_example

(Each line in the above list corresponds to a single path; the caves
visited by that path are listed in the order they are visited and
separated by commas.)

Note that in this cave system, cave d is never visited by any path: to
do so, cave b would need to be  visited twice (once on the way to cave
d and a second  time when returning from cave d), and  since cave b is
small, this is not allowed.

Here is a slightly larger example:

#+begin_example
dc-end
HN-start
start-kj
dc-start
dc-HN
LN-dc
HN-end
kj-sa
kj-HN
kj-dc
#+end_example

The 19 paths through it are as follows:

#+begin_example
start,HN,dc,HN,end
start,HN,dc,HN,kj,HN,end
start,HN,dc,end
start,HN,dc,kj,HN,end
start,HN,end
start,HN,kj,HN,dc,HN,end
start,HN,kj,HN,dc,end
start,HN,kj,HN,end
start,HN,kj,dc,HN,end
start,HN,kj,dc,end
start,dc,HN,end
start,dc,HN,kj,HN,end
start,dc,end
start,dc,kj,HN,end
start,kj,HN,dc,HN,end
start,kj,HN,dc,end
start,kj,HN,end
start,kj,dc,HN,end
start,kj,dc,end
#+end_example

Finally, this even larger example has 226 paths through it:

#+begin_example
fs-end
he-DX
fs-he
start-DX
pj-DX
end-zg
zg-sl
zg-pj
pj-he
RW-he
fs-DX
pj-RW
zg-RW
start-pj
he-WI
zg-he
pj-fs
start-RW
#+end_example

How many paths through this cave system are there that visit small
caves at most once?
** TODO Day 12.2                                                  :noexport:

** TODO Day 13.1                                                  :noexport:

You reach  another volcanically active part  of the cave. It  would be
nice if you  could do some kind  of thermal imaging so  you could tell
ahead of time which caves are too hot to safely enter.

Fortunately, the submarine seems to be equipped with a thermal camera!
When you activate it, you are greeted with:

Congratulations on  your purchase!  To activate this  infrared thermal
imaging camera  system, please enter the  code found on page  1 of the
manual.

Apparently, the Elves have never  used this feature. To your surprise,
you manage  to find the  manual; as  you go to  open it, page  1 falls
out. It's a large sheet of transparent paper! The transparent paper is
marked with random dots and includes instructions on how to fold it up
(your puzzle input). For example:

#+begin_example
6,10
0,14
9,10
0,3
10,4
4,11
6,0
6,12
4,1
0,13
10,12
3,4
3,0
8,4
1,10
2,14
8,10
9,0

fold along y=7
fold along x=5
#+end_example

The first  section is  a list  of dots on  the transparent  paper. 0,0
represents the top-left  coordinate. The first value,  x, increases to
the right. The second value, y, increases downward. So, the coordinate
3,0 is to the  right of 0,0, and the coordinate 0,7  is below 0,0. The
coordinates in this  example form the following pattern, where  # is a
dot on the paper and . is an empty, unmarked position:

#+begin_example
...#..#..#.
....#......
...........
#..........
...#....#.#
...........
...........
...........
...........
...........
.#....#.##.
....#......
......#...#
#..........
#.#........
#+end_example

Then, there is a list of fold instructions. Each instruction indicates
a line  on the transparent  paper and wants you  to fold the  paper up
(for horizontal  y=... lines) or  left (for vertical x=...  lines). In
this  example, the  first fold  instruction is  fold along  y=7, which
designates  the line  formed by  all  of the  positions where  y is  7
(marked here with -):

#+begin_example
...#..#..#.
....#......
...........
#..........
...#....#.#
...........
...........
-----------
...........
...........
.#....#.##.
....#......
......#...#
#..........
#.#........
#+end_example


Because this  is a horizontal line,  fold the bottom half  up. Some of
the dots might end up overlapping after the fold is complete, but dots
will never  appear exactly on  a fold line.  The result of  doing this
fold looks like this:

#+begin_example
#.##..#..#.
#...#......
......#...#
#...#......
.#.#..#.###
...........
...........
#+end_example

Now, only 17 dots are visible.

Notice, for example, the two dots in the bottom left corner before the
transparent paper  is folded; after  the fold is complete,  those dots
appear in the top  left corner (at 0,0 and 0,1).  Because the paper is
transparent, the  dot just below them  in the result (at  0,3) remains
visible, as it can be seen through the transparent paper.

Also notice that some dots can end up overlapping; in this case, the
dots merge together and become a single dot.

The second fold instruction is fold along x=5, which indicates this
line:

#+begin_example
#.##.|#..#.
#...#|.....
.....|#...#
#...#|.....
.#.#.|#.###
.....|.....
.....|.....
#+end_example

Because this is a vertical line, fold left:
#+begin_example
#####
#...#
#...#
#...#
#####
.....
.....
#+end_example

The instructions made a square!

The  transparent paper  is  pretty  big, so  for  now,  focus on  just
completing the first fold. After the  first fold in the example above,
17 dots are visible  - dots that end up overlapping  after the fold is
completed count as a single dot.

How  many  dots are  visible  after  completing  just the  first  fold
instruction on your transparent paper?
** TODO Day 13.2                                                  :noexport:

** TODO Day 14.1                                                  :noexport:

The incredible pressures at this depth are starting to put a strain on
your submarine. The submarine  has polymerization equipment that would
produce suitable materials to reinforce  the submarine, and the nearby
volcanically-active  caves  should  even   have  the  necessary  input
elements in sufficient quantities.

The  submarine manual  contains instructions  for finding  the optimal
polymer formula; specifically, it offers a polymer template and a list
of pair insertion rules (your puzzle input). You just need to work out
what polymer would result after repeating the pair insertion process a
few times.

For example:
#+begin_example
NNCB

CH -> B
HH -> N
CB -> H
NH -> C
HB -> C
HC -> B
HN -> C
NN -> C
BH -> H
NC -> B
NB -> B
BN -> B
BB -> N
BC -> B
CC -> N
CN -> C
#+end_example

The first line is the polymer template - this is the starting point of
the process.

The following section defines the pair insertion rules. A rule like AB
-> C means that when elements A and B are immediately adjacent,
element C should be inserted between them. These insertions all happen
simultaneously.

So, starting with the polymer template NNCB, the first step
simultaneously considers all three pairs:
- The first pair (NN) matches the rule NN -> C, so element C is
  inserted between the first N and the second N.
- The second pair (NC) matches the rule NC -> B, so element B is
  inserted between the N and the C.
- The third pair (CB) matches the rule CB -> H, so element H is
  inserted between the C and the B.
  
Note that these  pairs overlap: the second element of  one pair is the
first element of the next pair. Also, because all pairs are considered
simultaneously, inserted elements  are not considered to be  part of a
pair until the next step.

After the first step of this process, the polymer becomes NCNBCHB.

Here are the results of a few steps using the above rules:

#+begin_example
Template:     NNCB
After step 1: NCNBCHB
After step 2: NBCCNBBBCBHCB
After step 3: NBBBCNCCNBBNBNBBCHBHHBCHB
After step 4: NBBNBNBBCCNBCNCCNBBNBBNBBBNBBNBBCBHCBHHNHCBBCBHCB
#+end_example

This polymer grows quickly. After step 5, it has length 97; After step
10, it has length  3073. After step 10, B occurs  1749 times, C occurs
298 times,  H occurs  161 times,  and N occurs  865 times;  taking the
quantity  of the  most common  element (B,  1749) and  subtracting the
quantity of  the least  common element  (H, 161)  produces 1749  - 161
= 1588.

Apply 10 steps of pair insertion  to the polymer template and find the
most and least common  elements in the result. What do  you get if you
take the quantity of the most common element and subtract the quantity
of the least common element?
** TODO Day 14.2                                                  :noexport:

** TODO Day 15.1                                                  :noexport:

You've almost reached the exit of  the cave, but the walls are getting
closer together. Your submarine can barely still fit, though; the main
problem is that the  walls of the cave are covered  in chitons, and it
would be best not to bump any of them.

The cavern  is large,  but has  a very  low ceiling,  restricting your
motion to two dimensions. The shape  of the cavern resembles a square;
a quick scan of chiton density produces a map of risk level throughout
the cave (your puzzle input). For example:
#+begin_example
1163751742
1381373672
2136511328
3694931569
7463417111
1319128137
1359912421
3125421639
1293138521
2311944581
#+end_example

You start  in the top  left position,  your destination is  the bottom
right position,  and you  cannot move diagonally.  The number  at each
position is its  risk level; to determine the total  risk of an entire
path, add  up the  risk levels  of each position  you enter  (that is,
don't count the risk level of  your starting position unless you enter
it; leaving it adds no risk to your total).

Your goal is to find a path with the lowest total risk. In this
example, a path with the lowest total risk is highlighted here:

#+begin_example
1163751742
1381373672
2136511328
3694931569
7463417111
1319128137
1359912421
3125421639
1293138521
2311944581
#+end_example

The total risk of this path is 40 (the starting position is never
entered, so its risk is not counted).

What is  the lowest total risk  of any path  from the top left  to the
bottom right?
** TODO Day 15.2                                                  :noexport:

** TODO Day 16.1                                                  :noexport:

As  you  leave  the  cave  and   reach  open  waters,  you  receive  a
transmission from the Elves back on the ship.

The transmission was sent  using the Buoyancy Interchange Transmission
System (BITS), a  method of packing numeric expressions  into a binary
sequence.  Your submarine's  computer  has saved  the transmission  in
hexadecimal (your puzzle input).

The first step  of decoding the message is to  convert the hexadecimal
representation into binary. Each  character of hexadecimal corresponds
to four bits of binary data:

#+begin_example
0 = 0000
1 = 0001
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111
#+end_example

The BITS transmission contains a  single packet at its outermost layer
which   itself   contains   many  other   packets.   The   hexadecimal
representation of this  packet might encode a few extra  0 bits at the
end; these are not part of the transmission and should be ignored.

Every  packet begins  with a  standard  header: the  first three  bits
encode the packet  version, and the next three bits  encode the packet
type ID.  These two  values are  numbers; all  numbers encoded  in any
packet  are  represented  as  binary with  the  most  significant  bit
first.  For example,  a version  encoded  as the  binary sequence  100
represents the number 4.

Packets  with type  ID  4  represent a  literal  value. Literal  value
packets encode a  single binary number. To do this,  the binary number
is padded with  leading zeroes until its length is  a multiple of four
bits, and then  it is broken into  groups of four bits.  Each group is
prefixed by a  1 bit except the  last group, which is prefixed  by a 0
bit.  These  groups  of  five   bits  immediately  follow  the  packet
header. For example, the hexadecimal string D2FE28 becomes:

#+begin_example
110100101111111000101000
VVVTTTAAAAABBBBBCCCCC
#+end_example

Below each bit is a label indicating its purpose:
- The three bits labeled V (110) are the packet version, 6.
- The three bits labeled T (100) are the packet type ID, 4, which
  means the packet is a literal value.
- The five bits labeled A (10111) start with a 1 (not the last group,
  keep reading) and contain the first four bits of the number, 0111.
- The five bits labeled B (11110) start with a 1 (not the last group,
  keep reading) and contain four more bits of the number, 1110.
- The five bits labeled C (00101) start with a 0 (last group, end of
  packet) and contain the last four bits of the number, 0101.
- The three unlabeled 0 bits at the end are extra due to the
  hexadecimal representation and should be ignored.
  
So, this packet represents a literal value with binary representation
011111100101, which is 2021 in decimal.

Every other type of packet (any packet with a type ID other than 4)
represent an operator that performs some calculation on one or more
sub-packets contained within. Right now, the specific operations
aren't important; focus on parsing the hierarchy of sub-packets.

An operator packet contains one or more packets. To indicate which
subsequent binary data represents its sub-packets, an operator packet
can use one of two modes indicated by the bit immediately after the
packet header; this is called the length type ID:
- If the length type ID is 0, then the next 15 bits are a number that
  represents the total length in bits of the sub-packets contained by
  this packet.
- If the length type ID is 1, then the next 11 bits are a number that
  represents the number of sub-packets immediately contained by this
  packet.
  
Finally, after the length type ID bit and the 15-bit or 11-bit field,
the sub-packets appear.

For example, here is an operator packet (hexadecimal string
38006F45291200) with length type ID 0 that contains two sub-packets:

#+begin_example
00111000000000000110111101000101001010010001001000000000
VVVTTTILLLLLLLLLLLLLLLAAAAAAAAAAABBBBBBBBBBBBBBBB
#+end_example

- The three bits labeled V (001) are the packet version, 1.
- The three bits labeled T (110) are the packet type ID, 6, which
  means the packet is an operator.
- The bit labeled I (0) is the length type ID, which indicates that
  the length is a 15-bit number representing the number of bits in the
  sub-packets.
- The 15 bits labeled L (000000000011011) contain the length of the
  sub-packets in bits, 27.
- The 11 bits labeled A contain the first sub-packet, a literal value
  representing the number 10.
- The 16 bits labeled B contain the second sub-packet, a literal value
  representing the number 20.
  
After reading 11 and 16 bits of sub-packet data, the total length
indicated in L (27) is reached, and so parsing of this packet stops.

As another example, here is an operator packet (hexadecimal string
EE00D40C823060) with length type ID 1 that contains three sub-packets:

#+begin_example
11101110000000001101010000001100100000100011000001100000
VVVTTTILLLLLLLLLLLAAAAAAAAAAABBBBBBBBBBBCCCCCCCCCCC
#+end_example

- The three bits labeled V (111) are the packet version, 7.
- The three bits labeled T (011) are the packet type ID, 3, which
  means the packet is an operator.
- The bit labeled I (1) is the length type ID, which indicates that
  the length is a 11-bit number representing the number of
  sub-packets.
- The 11 bits labeled L (00000000011) contain the number of
  sub-packets, 3.
- The 11 bits labeled A contain the first sub-packet, a literal value
  representing the number 1.
- The 11 bits labeled B contain the second sub-packet, a literal value
  representing the number 2.
- The 11 bits labeled C contain the third sub-packet, a literal value
  representing the number 3.
  
After reading 3 complete sub-packets, the number of sub-packets
indicated in L (3) is reached, and so parsing of this packet stops.

For now, parse the hierarchy of the packets throughout the
transmission and add up all of the version numbers.

Here are a few more examples of hexadecimal-encoded transmissions:
- 8A004A801A8002F478 represents an operator packet (version 4) which
  contains an operator packet (version 1) which contains an operator
  packet (version 5) which contains a literal value (version 6); this
  packet has a version sum of 16.
- 620080001611562C8802118E34 represents an operator packet (version 3)
  which contains two sub-packets; each sub-packet is an operator
  packet that contains two literal values. This packet has a version
  sum of 12.
- C0015000016115A2E0802F182340 has the same structure as the previous
  example, but the outermost packet uses a different length type
  ID. This packet has a version sum of 23.
- A0016C880162017C3686B18A3D4780 is an operator packet that contains
  an operator packet that contains an operator packet that contains
  five literal values; it has a version sum of 31.
  
Decode the  structure of  your hexadecimal-encoded  BITS transmission;
what do you get if you add up the version numbers in all packets?
** TODO Day 16.2                                                  :noexport:

** TODO Day 17.1                                                  :noexport:

You finally decode the Elves' message. HI, the message says. You
continue searching for the sleigh keys.

Ahead of you is what appears to be a large ocean trench. Could the
keys have fallen into it? You'd better send a probe to investigate.

The probe launcher on your submarine can fire the probe with any
integer velocity in the x (forward) and y (upward, or downward if
negative) directions. For example, an initial x,y velocity like 0,10
would fire the probe straight up, while an initial velocity like 10,-1
would fire the probe forward at a slight downward angle.

The probe's x,y position starts at 0,0. Then, it will follow some
trajectory by moving in steps. On each step, these changes occur in
the following order:
- The probe's x position increases by its x velocity.
- The probe's y position increases by its y velocity.
- Due to drag, the probe's x velocity changes by 1 toward the value 0;
  that is, it decreases by 1 if it is greater than 0, increases by 1
  if it is less than 0, or does not change if it is already 0.
- Due to gravity, the probe's y velocity decreases by 1.

For the probe to successfully make  it into the trench, the probe must
be on some trajectory that causes it  to be within a target area after
any step.  The submarine computer  has already calculated  this target
area (your puzzle input). For example:

#+begin_example
target area: x=20..30, y=-10..-5
#+end_example

This target  area means  that you  need to  find initial  x,y velocity
values such that after any step, the probe's x position is at least 20
and at most 30, and the probe's y position is at least -10 and at most
-5.

Given this target area, one initial velocity that causes the probe to
be within the target area after any step is 7,2:

#+begin_example
.............#....#............
.......#..............#........
...............................
S........................#.....
...............................
...............................
...........................#...
...............................
....................TTTTTTTTTTT
....................TTTTTTTTTTT
....................TTTTTTTT#TT
....................TTTTTTTTTTT
....................TTTTTTTTTTT
....................TTTTTTTTTTT
#+end_example

In  this diagram,  S  is  the probe's  initial  position,  0,0. The  x
coordinate  increases to  the right,  and the  y coordinate  increases
upward. In the bottom right, positions that are within the target area
are shown  as T. After each  step (until the target  area is reached),
the position  of the probe  is marked with  #. (The bottom-right  # is
both a position the probe reaches and a position in the target area.)

Another initial velocity that causes the probe to be within the target
area after any step is 6,3:

#+begin_example
...............#..#............
...........#........#..........
...............................
......#..............#.........
...............................
...............................
S....................#.........
...............................
...............................
...............................
.....................#.........
....................TTTTTTTTTTT
....................TTTTTTTTTTT
....................TTTTTTTTTTT
....................TTTTTTTTTTT
....................T#TTTTTTTTT
....................TTTTTTTTTTT
#+end_example

Another one is 9,0:
#+begin_example
S........#.....................
.................#.............
...............................
........................#......
...............................
....................TTTTTTTTTTT
....................TTTTTTTTTT#
....................TTTTTTTTTTT
....................TTTTTTTTTTT
....................TTTTTTTTTTT
....................TTTTTTTTTTT
#+end_example

One initial velocity that doesn't cause the probe to be within the
target area after any step is 17,-4:

#+begin_example
S..............................................................
...............................................................
...............................................................
...............................................................
.................#.............................................
....................TTTTTTTTTTT................................
....................TTTTTTTTTTT................................
....................TTTTTTTTTTT................................
....................TTTTTTTTTTT................................
....................TTTTTTTTTTT..#.............................
....................TTTTTTTTTTT................................
...............................................................
...............................................................
...............................................................
...............................................................
................................................#..............
...............................................................
...............................................................
...............................................................
...............................................................
...............................................................
...............................................................
..............................................................#
#+end_example

The probe appears to pass through the target area, but is never within
it after any step. Instead, it continues down and to the right - only
the first few steps are shown.

If you're going to fire a highly scientific probe out of a super cool
probe launcher, you might as well do it with style. How high can you
make the probe go while still reaching the target area?

In the above example, using an initial velocity of 6,9 is the best you
can do, causing the probe to reach a maximum y position of 45. (Any
higher initial y velocity causes the probe to overshoot the target
area entirely.)

Find the initial velocity that causes the probe to reach the highest y
position and still eventually be within the target area after any
step. What is the highest y position it reaches on this trajectory?
** TODO Day 17.2                                                  :noexport:

** TODO Day 18.1                                                  :noexport:

You descend into  the ocean trench and encounter  some snailfish. They
say they  saw the sleigh keys!  They'll even tell you  which direction
the keys went if  you help one of the smaller  snailfish with his math
homework.

Snailfish  numbers   aren't  like  regular  numbers.   Instead,  every
snailfish number  is a pair  - an ordered  list of two  elements. Each
element of the pair can be either a regular number or another pair.

Pairs are written as [x,y], where x and y are the elements within the
pair. Here are some example snailfish numbers, one snailfish number
per line:

#+begin_example
[1,2]
[[1,2],3]
[9,[8,7]]
[[1,9],[8,5]]
[[[[1,2],[3,4]],[[5,6],[7,8]]],9]
[[[9,[3,8]],[[0,9],6]],[[[3,7],[4,9]],3]]
[[[[1,3],[5,3]],[[1,3],[8,7]]],[[[4,9],[6,9]],[[8,2],[7,3]]]]
#+end_example

This  snailfish  homework is  about  addition.  To add  two  snailfish
numbers,  form a  pair  from  the left  and  right  parameters of  the
addition   operator.   For   example,  [1,2]   +   [[3,4],5]   becomes
[[1,2],[[3,4],5]].

There's only  one problem: snailfish  numbers must always  be reduced,
and  the  process  of  adding  two snailfish  numbers  can  result  in
snailfish numbers that need to be reduced.

To reduce a snailfish number, you must repeatedly do the first action
in this list that applies to the snailfish number:
- If any pair is nested inside four pairs, the leftmost such pair explodes.
- If any regular number is 10 or greater, the leftmost such regular
  number splits.
  
Once no action in the above list applies, the snailfish number is
reduced.

During reduction, at most one  action applies, after which the process
returns  to the  top of  the list  of actions.  For example,  if split
produces a  pair that meets  the explode criteria, that  pair explodes
before other splits occur.

To explode a pair, the pair's left value is added to the first regular
number to  the left  of the  exploding pair (if  any), and  the pair's
right value is added  to the first regular number to  the right of the
exploding pair  (if any). Exploding  pairs will always consist  of two
regular numbers. Then, the entire  exploding pair is replaced with the
regular number 0.

Here are some examples of a single explode action:
- [[[[[9,8],1],2],3],4] becomes [[[[0,9],2],3],4] (the 9 has no
  regular number to its left, so it is not added to any regular
  number).
- [7,[6,[5,[4,[3,2]]]]] becomes [7,[6,[5,[7,0]]]] (the 2 has no
  regular number to its right, and so it is not added to any regular
  number).
- [[6,[5,[4,[3,2]]]],1] becomes [[6,[5,[7,0]]],3].
- [[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]] becomes
  [[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]] (the pair [3,2] is unaffected
  because the pair [7,3] is further to the left; [3,2] would explode
  on the next action).
- [[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]] becomes
  [[3,[2,[8,0]]],[9,[5,[7,0]]]].
  
To split a regular number, replace it with a pair; the left element of
the pair should be the regular number divided by two and rounded down,
while  the right  element of  the pair  should be  the regular  number
divided  by two  and rounded  up. For  example, 10  becomes [5,5],  11
becomes [5,6], 12 becomes [6,6], and so on.

Here is the process of finding the reduced result of
[[[[4,3],4],4],[7,[[8,4],9]]] + [1,1]:
#+begin_example
after addition: [[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]
after explode:  [[[[0,7],4],[7,[[8,4],9]]],[1,1]]
after explode:  [[[[0,7],4],[15,[0,13]]],[1,1]]
after split:    [[[[0,7],4],[[7,8],[0,13]]],[1,1]]
after split:    [[[[0,7],4],[[7,8],[0,[6,7]]]],[1,1]]
after explode:  [[[[0,7],4],[[7,8],[6,0]]],[8,1]]
#+end_example

Once no reduce actions apply, the snailfish number that remains is the
actual       result       of       the       addition       operation:
[[[[0,7],4],[[7,8],[6,0]]],[8,1]].

The homework assignment involves adding up a list of snailfish numbers
(your  puzzle input).  The  snailfish  numbers are  each  listed on  a
separate line. Add the first snailfish number and the second, then add
that result and the third, then add that result and the fourth, and so
on until all numbers in the list have been used once.

For example, the final sum of this list is
[[[[1,1],[2,2]],[3,3]],[4,4]]:

#+begin_example
[1,1]
[2,2]
[3,3]
[4,4]
#+end_example

The final sum of this list is [[[[3,0],[5,3]],[4,4]],[5,5]]:
#+begin_example
[1,1]
[2,2]
[3,3]
[4,4]
[5,5]
#+end_example

The final sum of this list is [[[[5,0],[7,4]],[5,5]],[6,6]]:
#+begin_example
[1,1]
[2,2]
[3,3]
[4,4]
[5,5]
[6,6]
#+end_example

Here's a slightly larger example:
#+begin_example
[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]
[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]
[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]
[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]
[7,[5,[[3,8],[1,4]]]]
[[2,[2,2]],[8,[8,1]]]
[2,9]
[1,[[[9,3],9],[[9,0],[0,7]]]]
[[[5,[7,4]],7],1]
[[[[4,2],2],6],[8,7]]
#+end_example

The final sum [[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]] is
found after adding up the above snailfish numbers:

#+begin_example
  [[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]
+ [7,[[[3,7],[4,3]],[[6,3],[8,8]]]]
= [[[[4,0],[5,4]],[[7,7],[6,0]]],[[8,[7,7]],[[7,9],[5,0]]]]

  [[[[4,0],[5,4]],[[7,7],[6,0]]],[[8,[7,7]],[[7,9],[5,0]]]]
+ [[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]
= [[[[6,7],[6,7]],[[7,7],[0,7]]],[[[8,7],[7,7]],[[8,8],[8,0]]]]

  [[[[6,7],[6,7]],[[7,7],[0,7]]],[[[8,7],[7,7]],[[8,8],[8,0]]]]
+ [[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]
= [[[[7,0],[7,7]],[[7,7],[7,8]]],[[[7,7],[8,8]],[[7,7],[8,7]]]]

  [[[[7,0],[7,7]],[[7,7],[7,8]]],[[[7,7],[8,8]],[[7,7],[8,7]]]]
+ [7,[5,[[3,8],[1,4]]]]
= [[[[7,7],[7,8]],[[9,5],[8,7]]],[[[6,8],[0,8]],[[9,9],[9,0]]]]

  [[[[7,7],[7,8]],[[9,5],[8,7]]],[[[6,8],[0,8]],[[9,9],[9,0]]]]
+ [[2,[2,2]],[8,[8,1]]]
= [[[[6,6],[6,6]],[[6,0],[6,7]]],[[[7,7],[8,9]],[8,[8,1]]]]

  [[[[6,6],[6,6]],[[6,0],[6,7]]],[[[7,7],[8,9]],[8,[8,1]]]]
+ [2,9]
= [[[[6,6],[7,7]],[[0,7],[7,7]]],[[[5,5],[5,6]],9]]

  [[[[6,6],[7,7]],[[0,7],[7,7]]],[[[5,5],[5,6]],9]]
+ [1,[[[9,3],9],[[9,0],[0,7]]]]
= [[[[7,8],[6,7]],[[6,8],[0,8]]],[[[7,7],[5,0]],[[5,5],[5,6]]]]

  [[[[7,8],[6,7]],[[6,8],[0,8]]],[[[7,7],[5,0]],[[5,5],[5,6]]]]
+ [[[5,[7,4]],7],1]
= [[[[7,7],[7,7]],[[8,7],[8,7]]],[[[7,0],[7,7]],9]]

  [[[[7,7],[7,7]],[[8,7],[8,7]]],[[[7,0],[7,7]],9]]
+ [[[[4,2],2],6],[8,7]]
= [[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]
#+end_example

To check  whether it's  the right answer,  the snailfish  teacher only
checks the magnitude  of the final sum.  The magnitude of a  pair is 3
times the magnitude of its left  element plus 2 times the magnitude of
its right  element. The  magnitude of  a regular  number is  just that
number.

For example, the magnitude  of [9,1] is 3*9 + 2*1  = 29; the magnitude
of [1,9] is 3*1 + 2*9  = 21. Magnitude calculations are recursive: the
magnitude of [[9,1],[1,9]] is 3*29 + 2*21 = 129.

Here are a few more magnitude examples:
- [[1,2],[[3,4],5]] becomes 143.
- [[[[0,7],4],[[7,8],[6,0]]],[8,1]] becomes 1384.
- [[[[1,1],[2,2]],[3,3]],[4,4]] becomes 445.
- [[[[3,0],[5,3]],[4,4]],[5,5]] becomes 791.
- [[[[5,0],[7,4]],[5,5]],[6,6]] becomes 1137.
- [[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]] becomes 3488.

So, given this example homework assignment:
#+begin_example
[[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]
[[[5,[2,8]],4],[5,[[9,9],0]]]
[6,[[[6,2],[5,6]],[[7,6],[4,7]]]]
[[[6,[0,7]],[0,9]],[4,[9,[9,0]]]]
[[[7,[6,4]],[3,[1,3]]],[[[5,5],1],9]]
[[6,[[7,3],[3,2]]],[[[3,8],[5,7]],4]]
[[[[5,4],[7,7]],8],[[8,3],8]]
[[9,3],[[9,9],[6,[4,9]]]]
[[2,[[7,7],7]],[[5,8],[[9,3],[0,2]]]]
[[[[5,2],5],[8,[3,7]]],[[5,[7,5]],[4,4]]]
#+end_example

The final sum is:

#+begin_example
[[[[6,6],[7,6]],[[7,7],[7,0]]],[[[7,7],[7,7]],[[7,8],[9,9]]]]
#+end_example

The magnitude of this final sum is 4140.

Add up all of the snailfish numbers from the homework assignment in
the order they appear. What is the magnitude of the final sum?
** TODO Day 18.2                                                  :noexport:

** TODO Day 19.1                                                  :noexport:

As  your  probe  drifted  down  through  this  area,  it  released  an
assortment of beacons  and scanners into the water.  It's difficult to
navigate in  the pitch black open  waters of the ocean  trench, but if
you can build  a map of the  trench using data from  the scanners, you
should be able to safely reach the bottom.

The  beacons  and scanners  float  motionless  in the  water;  they're
designed to maintain the same position  for long periods of time. Each
scanner is capable  of detecting all beacons in a  large cube centered
on the  scanner; beacons  that are  at most 1000  units away  from the
scanner in  each of the  three axes (x, y,  and z) have  their precise
position determined relative to  the scanner. However, scanners cannot
detect other scanners. The  submarine has automatically summarized the
relative positions  of beacons detected  by each scanner  (your puzzle
input).

For example, if a scanner is at x,y,z coordinates 500,0,-500 and there
are  beacons at  -500,1000,-1500  and 1501,0,-500,  the scanner  could
report that the  first beacon is at -1000,1000,-1000  (relative to the
scanner) but would not detect the second beacon at all.

Unfortunately,  while each  scanner can  report the  positions of  all
detected beacons  relative to itself,  the scanners do not  know their
own position.  You'll need to  determine the positions of  the beacons
and scanners yourself.

The  scanners and  beacons map  a  single contiguous  3d region.  This
region can  be reconstructed  by finding pairs  of scanners  that have
overlapping detection regions such that  there are at least 12 beacons
that  both scanners  detect  within the  overlap.  By establishing  12
common beacons,  you can  precisely determine  where the  scanners are
relative to each other, allowing you to reconstruct the beacon map one
scanner at a time.

For  a moment,  consider only  two  dimensions. Suppose  you have  the
following scanner reports:

#+begin_example
--- scanner 0 ---
0,2
4,1
3,3

--- scanner 1 ---
-1,-1
-5,0
-2,1
#+end_example

Drawing x  increasing rightward, y  increasing upward, scanners  as S,
and beacons as B, scanner 0 detects this:

#+begin_example
...B.
B....
....B
S....
#+end_example

Scanner 1 detects this:

#+begin_example
...B..
B....S
....B.
#+end_example

For   this  example,   assume   scanners  only   need  3   overlapping
beacons. Then, the beacons visible to both scanners overlap to produce
the following complete map:

#+begin_example
...B..
B....S
....B.
S.....
#+end_example

Unfortunately, there's a second problem:  the scanners also don't know
their rotation  or facing direction.  Due to magnetic  alignment, each
scanner is rotated  some integer number of 90-degree  turns around all
of the x, y,  and z axes. That is, one scanner  might call a direction
positive x, while  another scanner might call  that direction negative
y. Or, two scanners might agree  on which direction is positive x, but
one scanner  might be  upside-down from the  perspective of  the other
scanner.  In total,  each  scanner could  be in  any  of 24  different
orientations: facing positive or negative  x, y, or z, and considering
any of four directions "up" from that facing.

For example, here is an arrangement  of beacons as seen from a scanner
in the same position but in different orientations:

#+begin_example
--- scanner 0 ---
-1,-1,1
-2,-2,2
-3,-3,3
-2,-3,1
5,6,-4
8,0,7

--- scanner 0 ---
1,-1,1
2,-2,2
3,-3,3
2,-1,3
-5,4,-6
-8,-7,0

--- scanner 0 ---
-1,-1,-1
-2,-2,-2
-3,-3,-3
-1,-3,-2
4,6,5
-7,0,8

--- scanner 0 ---
1,1,-1
2,2,-2
3,3,-3
1,3,-2
-4,-6,5
7,0,8

--- scanner 0 ---
1,1,1
2,2,2
3,3,3
3,1,2
-6,-4,-5
0,7,-8
#+end_example

By finding  pairs of scanners  that both see at  least 12 of  the same
beacons, you  can assemble the  entire map. For example,  consider the
following report:

#+begin_example
--- scanner 0 ---
404,-588,-901
528,-643,409
-838,591,734
390,-675,-793
-537,-823,-458
-485,-357,347
-345,-311,381
-661,-816,-575
-876,649,763
-618,-824,-621
553,345,-567
474,580,667
-447,-329,318
-584,868,-557
544,-627,-890
564,392,-477
455,729,728
-892,524,684
-689,845,-530
423,-701,434
7,-33,-71
630,319,-379
443,580,662
-789,900,-551
459,-707,401

--- scanner 1 ---
686,422,578
605,423,415
515,917,-361
-336,658,858
95,138,22
-476,619,847
-340,-569,-846
567,-361,727
-460,603,-452
669,-402,600
729,430,532
-500,-761,534
-322,571,750
-466,-666,-811
-429,-592,574
-355,545,-477
703,-491,-529
-328,-685,520
413,935,-424
-391,539,-444
586,-435,557
-364,-763,-893
807,-499,-711
755,-354,-619
553,889,-390

--- scanner 2 ---
649,640,665
682,-795,504
-784,533,-524
-644,584,-595
-588,-843,648
-30,6,44
-674,560,763
500,723,-460
609,671,-379
-555,-800,653
-675,-892,-343
697,-426,-610
578,704,681
493,664,-388
-671,-858,530
-667,343,800
571,-461,-707
-138,-166,112
-889,563,-600
646,-828,498
640,759,510
-630,509,768
-681,-892,-333
673,-379,-804
-742,-814,-386
577,-820,562

--- scanner 3 ---
-589,542,597
605,-692,669
-500,565,-823
-660,373,557
-458,-679,-417
-488,449,543
-626,468,-788
338,-750,-386
528,-832,-391
562,-778,733
-938,-730,414
543,643,-506
-524,371,-870
407,773,750
-104,29,83
378,-903,-323
-778,-728,485
426,699,580
-438,-605,-362
-469,-447,-387
509,732,623
647,635,-688
-868,-804,481
614,-800,639
595,780,-596

--- scanner 4 ---
727,592,562
-293,-554,779
441,611,-461
-714,465,-776
-743,427,-804
-660,-479,-426
832,-632,460
927,-485,-438
408,393,-506
466,436,-512
110,16,151
-258,-428,682
-393,719,612
-211,-452,876
808,-476,-593
-575,615,604
-485,667,467
-680,325,-822
-627,-443,-432
872,-547,-609
833,512,582
807,604,487
839,-516,451
891,-625,532
-652,-548,-490
30,-46,-14
#+end_example

Because all coordinates are relative,  in this example, all "absolute"
positions  will  be  expressed  relative   to  scanner  0  (using  the
orientation of scanner 0 and as if scanner 0 is at coordinates 0,0,0).

Scanners 0 and 1 have overlapping detection cubes; the 12 beacons they
both detect (relative to scanner 0) are at the following coordinates:

#+begin_example
-618,-824,-621
-537,-823,-458
-447,-329,318
404,-588,-901
544,-627,-890
528,-643,409
-661,-816,-575
390,-675,-793
423,-701,434
-345,-311,381
459,-707,401
-485,-357,347
#+end_example

These same 12 beacons (in the  same order) but from the perspective of
scanner 1 are:

#+begin_example
686,422,578
605,423,415
515,917,-361
-336,658,858
-476,619,847
-460,603,-452
729,430,532
-322,571,750
-355,545,-477
413,935,-424
-391,539,-444
553,889,-390
#+end_example

Because  of this,  scanner  1  must be  at  68,-1246,-43 (relative  to
scanner 0).

Scanner 4  overlaps with scanner  1; the  12 beacons they  both detect
(relative to scanner 0) are:

#+begin_example
459,-707,401
-739,-1745,668
-485,-357,347
432,-2009,850
528,-643,409
423,-701,434
-345,-311,381
408,-1815,803
534,-1912,768
-687,-1600,576
-447,-329,318
-635,-1737,486
#+end_example

So, scanner 4 is at -20,-1133,1061 (relative to scanner 0).

Following this process, scanner 2 must be at 1105,-1205,1229 (relative
to scanner  0) and  scanner 3  must be  at -92,-2380,-20  (relative to
scanner 0).

The full list of beacons (relative to scanner 0) is:

#+begin_example
-892,524,684
-876,649,763
-838,591,734
-789,900,-551
-739,-1745,668
-706,-3180,-659
-697,-3072,-689
-689,845,-530
-687,-1600,576
-661,-816,-575
-654,-3158,-753
-635,-1737,486
-631,-672,1502
-624,-1620,1868
-620,-3212,371
-618,-824,-621
-612,-1695,1788
-601,-1648,-643
-584,868,-557
-537,-823,-458
-532,-1715,1894
-518,-1681,-600
-499,-1607,-770
-485,-357,347
-470,-3283,303
-456,-621,1527
-447,-329,318
-430,-3130,366
-413,-627,1469
-345,-311,381
-36,-1284,1171
-27,-1108,-65
7,-33,-71
12,-2351,-103
26,-1119,1091
346,-2985,342
366,-3059,397
377,-2827,367
390,-675,-793
396,-1931,-563
404,-588,-901
408,-1815,803
423,-701,434
432,-2009,850
443,580,662
455,729,728
456,-540,1869
459,-707,401
465,-695,1988
474,580,667
496,-1584,1900
497,-1838,-617
527,-524,1933
528,-643,409
534,-1912,768
544,-627,-890
553,345,-567
564,392,-477
568,-2007,-577
605,-1665,1952
612,-1593,1893
630,319,-379
686,-3108,-505
776,-3184,-501
846,-3110,-434
1135,-1161,1235
1243,-1093,1063
1660,-552,429
1693,-557,386
1735,-437,1738
1749,-1800,1813
1772,-405,1572
1776,-675,371
1779,-442,1789
1780,-1548,337
1786,-1538,337
1847,-1591,415
1889,-1729,1762
1994,-1805,1792
#+end_example

In total, there are 79 beacons.

Assemble the full map of beacons. How many beacons are there?
** TODO Day 19.2                                                  :noexport:

** TODO Day 20.1                                                  :noexport:

With the scanners fully deployed, you turn their attention to mapping
the floor of the ocean trench.

When you  get back the  image from the scanners,  it seems to  just be
random noise. Perhaps  you can combine an  image enhancement algorithm
and the input image (your puzzle input) to clean it up a little.


For example:
#+begin_example
..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..##
#..######.###...####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###
.######.###.####...#.##.##..#..#..#####.....#.#....###..#.##......#.....#.
.#..#..##..#...##.######.####.####.#.#...#.......#..#.#.#...####.##.#.....
.#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.###.##...#..
...####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.....
..##..####..#...#.#.#...##..#.#..###..#####........#..####......#..#

#..#.
#....
##..#
..#..
..###
#+end_example

The first section  is the image enhancement algorithm.  It is normally
given on a single  line, but it has been wrapped  to multiple lines in
this example for legibility. The second  section is the input image, a
two-dimensional grid of light pixels (#) and dark pixels (.).

The image enhancement  algorithm describes how to enhance  an image by
simultaneously converting all pixels in the input image into an output
image. Each  pixel of the output  image is determined by  looking at a
3x3  square  of  pixels  centered on  the  corresponding  input  image
pixel. So, to determine the value of the pixel at (5,10) in the output
image, nine pixels from the input  image need to be considered: (4,9),
(4,10),   (4,11),   (5,9),   (5,10),  (5,11),   (6,9),   (6,10),   and
(6,11).  These nine  input pixels  are combined  into a  single binary
number that  is used as  an index  in the image  enhancement algorithm
string.

For example,  to determine  the output pixel  that corresponds  to the
very middle pixel of the input  image, the nine pixels marked by [...]
would need to be considered:
#+begin_example
# . . # .
#[. . .].
#[# . .]#
.[. # .].
. . # # #
#+end_example

Starting from the  top-left and reading across each  row, these pixels
are  ..., then  #.., then  .#.;  combining these  forms ...#...#..  By
turning dark pixels (.) into 0 and light pixels (#) into 1, the binary
number 000100010 can be formed, which is 34 in decimal.

The image enhancement algorithm string is exactly 512 characters long,
enough  to match  every possible  9-bit binary  number. The  first few
characters of the string (numbered starting from zero) are as follows:
#+begin_example
0         10        20        30  34    40        50        60        70
|         |         |         |   |     |         |         |         |
..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..##
#+end_example

In the  middle of  this first  group of  characters, the  character at
index 34 can  be found: #. So,  the output pixel in the  center of the
output image should be #, a light pixel.

This process  can then  be repeated  to calculate  every pixel  of the
output image.

Through advances in  imaging technology, the images  being operated on
here are  infinite in size. Every  pixel of the infinite  output image
needs to  be calculated exactly  based on  the relevant pixels  of the
input image. The small input image you  have is only a small region of
the actual infinite input image; the  rest of the input image consists
of dark pixels (.). For the purposes of the example, to save on space,
only a portion  of the infinite-sized input and output  images will be
shown.

The starting input  image, therefore, looks something  like this, with
more dark  pixels (.) extending  forever in every direction  not shown
here:
#+begin_example
...............
...............
...............
...............
...............
.....#..#......
.....#.........
.....##..#.....
.......#.......
.......###.....
...............
...............
...............
...............
...............
#+end_example

By   applying  the   image  enhancement   algorithm  to   every  pixel
simultaneously, the following output image can be obtained:
#+begin_example
...............
...............
...............
...............
.....##.##.....
....#..#.#.....
....##.#..#....
....####..#....
.....#..##.....
......##..#....
.......#.#.....
...............
...............
...............
...............
#+end_example

Through further advances in imaging technology, the above output image
can also be  used as an input  image! This allows it to  be enhanced a
second time:
#+begin_example
...............
...............
...............
..........#....
....#..#.#.....
...#.#...###...
...#...##.#....
...#.....#.#...
....#.#####....
.....#.#####...
......##.##....
.......###.....
...............
...............
...............
#+end_example

Truly incredible -  now the small details are really  starting to come
through. After enhancing the original input image twice, 35 pixels are
lit.

Start with  the original input  image and apply the  image enhancement
algorithm twice, being careful to account for the infinite size of the
images. How many pixels are lit in the resulting image?
** TODO Day 20.2                                                  :noexport:

** TODO Day 21.1                                                  :noexport:

There's not  much to  do as you  slowly descend to  the bottom  of the
ocean. The submarine  computer challenges you to a nice  game of Dirac
Dice.

This game consists of a single die, two pawns, and a game board with a
circular   track   containing  ten   spaces   marked   1  through   10
clockwise.  Each  player's starting  space  is  chosen randomly  (your
puzzle input). Player 1 goes first.

Players take turns moving. On each player's turn, the player rolls the
die three times and adds up  the results. Then, the player moves their
pawn  that  many times  forward  around  the  track (that  is,  moving
clockwise on spaces in order of increasing value, wrapping back around
to 1 after 10). So, if a player is  on space 7 and they roll 2, 2, and
1, they would move forward 5 times, to spaces 8, 9, 10, 1, and finally
stopping on 2.

After each player moves, they increase their score by the value of the
space their  pawn stopped on. Players'  scores start at 0.  So, if the
first player starts on space 7 and rolls a total of 5, they would stop
on space 2 and add 2 to their score (for a total score of 2). The game
immediately  ends as  a  win for  any player  whose  score reaches  at
least 1000.

Since  the first  game  is  a practice  game,  the  submarine opens  a
compartment  labeled  deterministic dice  and  a  100-sided die  falls
out. This die  always rolls 1 first, then  2, then 3, and so  on up to
100, after which it starts over at 1 again. Play using this die.

For example, given these starting positions:
#+begin_example
Player 1 starting position: 4
Player 2 starting position: 8
#+end_example

This is how the game would go:
- Player 1 rolls 1+2+3 and moves to space 10 for a total score of 10.
- Player 2 rolls 4+5+6 and moves to space 3 for a total score of 3.
- Player 1 rolls 7+8+9 and moves to space 4 for a total score of 14.
- Player 2 rolls 10+11+12 and moves to space 6 for a total score of 9.
- Player 1 rolls 13+14+15 and moves to space 6 for a total score of 20.
- Player 2 rolls 16+17+18 and moves to space 7 for a total score of 16.
- Player 1 rolls 19+20+21 and moves to space 6 for a total score of 26.
- Player 2 rolls 22+23+24 and moves to space 6 for a total score of 22.

...after many turns...

- Player 2 rolls 82+83+84 and moves to space 6 for a total score of 742.
- Player 1 rolls 85+86+87 and moves to space 4 for a total score of 990.
- Player 2 rolls 88+89+90 and moves to space 3 for a total score of 745.
- Player 1 rolls 91+92+93 and moves to space 10 for a final score, 1000.

Since player 1  has at least 1000  points, player 1 wins  and the game
ends. At this point, the losing player  had 745 points and the die had
been rolled a total of 993 times; 745 * 993 = 739785.

Play a practice game using the deterministic 100-sided die. The moment
either player wins, what  do you get if you multiply  the score of the
losing player  by the number  of times the  die was rolled  during the
game?
** TODO Day 21.2                                                  :noexport:

** TODO Day 22.1                                                  :noexport:

Operating at these extreme ocean depths has overloaded the submarine's
reactor; it needs to be rebooted.

The reactor  core is  made up  of a large  3-dimensional grid  made up
entirely  of  cubes, one  cube  per  integer 3-dimensional  coordinate
(x,y,z). Each cube can be either on or off; at the start of the reboot
process, they  are all  off. (Could it  be an old  model of  a reactor
you've seen before?)

To reboot the reactor, you just need to set all of the cubes to either
on  or  off  by  following  a   list  of  reboot  steps  (your  puzzle
input). Each step  specifies a cuboid (the set of  all cubes that have
coordinates which fall  within ranges for x, y, and  z) and whether to
turn all of the cubes in that cuboid on or off.

For example, given these reboot steps:
#+begin_example
on x=10..12,y=10..12,z=10..12
on x=11..13,y=11..13,z=11..13
off x=9..11,y=9..11,z=9..11
on x=10..10,y=10..10,z=10..10
#+end_example

The first step (on x=10..12,y=10..12,z=10..12) turns on a 3x3x3 cuboid
consisting of 27 cubes:

#+begin_example
    10,10,10
    10,10,11
    10,10,12
    10,11,10
    10,11,11
    10,11,12
    10,12,10
    10,12,11
    10,12,12
    11,10,10
    11,10,11
    11,10,12
    11,11,10
    11,11,11
    11,11,12
    11,12,10
    11,12,11
    11,12,12
    12,10,10
    12,10,11
    12,10,12
    12,11,10
    12,11,11
    12,11,12
    12,12,10
    12,12,11
    12,12,12
#+end_example

The  second  step (on  x=11..13,y=11..13,z=11..13)  turns  on a  3x3x3
cuboid that overlaps  with the first. As a result,  only 19 additional
cubes turn on; the rest are already on from the previous step:
#+begin_example
    11,11,13
    11,12,13
    11,13,11
    11,13,12
    11,13,13
    12,11,13
    12,12,13
    12,13,11
    12,13,12
    12,13,13
    13,11,11
    13,11,12
    13,11,13
    13,12,11
    13,12,12
    13,12,13
    13,13,11
    13,13,12
    13,13,13
#+end_example

The third step (off x=9..11,y=9..11,z=9..11)  turns off a 3x3x3 cuboid
that  overlaps  partially with  some  cubes  that are  on,  ultimately
turning off 8 cubes:
#+begin_example
    10,10,10
    10,10,11
    10,11,10
    10,11,11
    11,10,10
    11,10,11
    11,11,10
    11,11,11
#+end_example

The final step (on x=10..10,y=10..10,z=10..10) turns on a single cube,
10,10,10. After this last step, 39 cubes are on.

The initialization  procedure only uses  cubes that  have x, y,  and z
positions  of at  least -50  and  at most  50. For  now, ignore  cubes
outside this region.

Here is a larger example:
#+begin_example
on x=-20..26,y=-36..17,z=-47..7
on x=-20..33,y=-21..23,z=-26..28
on x=-22..28,y=-29..23,z=-38..16
on x=-46..7,y=-6..46,z=-50..-1
on x=-49..1,y=-3..46,z=-24..28
on x=2..47,y=-22..22,z=-23..27
on x=-27..23,y=-28..26,z=-21..29
on x=-39..5,y=-6..47,z=-3..44
on x=-30..21,y=-8..43,z=-13..34
on x=-22..26,y=-27..20,z=-29..19
off x=-48..-32,y=26..41,z=-47..-37
on x=-12..35,y=6..50,z=-50..-2
off x=-48..-32,y=-32..-16,z=-15..-5
on x=-18..26,y=-33..15,z=-7..46
off x=-40..-22,y=-38..-28,z=23..41
on x=-16..35,y=-41..10,z=-47..6
off x=-32..-23,y=11..30,z=-14..3
on x=-49..-5,y=-3..45,z=-29..18
off x=18..30,y=-20..-8,z=-3..13
on x=-41..9,y=-7..43,z=-33..15
on x=-54112..-39298,y=-85059..-49293,z=-27449..7877
on x=967..23432,y=45373..81175,z=27513..53682
#+end_example

The  last two  steps are  fully outside  the initialization  procedure
area; all other steps are fully within it. After executing these steps
in the initialization procedure region, 590784 cubes are on.

Execute the  reboot steps.  Afterward, considering  only cubes  in the
region x=-50..50,y=-50..50,z=-50..50, how many cubes are on?
** TODO Day 22.2                                                  :noexport:

** TODO Day 23.1                                                  :noexport:

A  group  of  amphipods  notice  your fancy  submarine  and  flag  you
down. "With such an impressive  shell," one amphipod says, "surely you
can help us with a question that has stumped our best scientists."

They go on  to explain that a group of  timid, stubborn amphipods live
in a  nearby burrow. Four  types of  amphipods live there:  Amber (A),
Bronze (B),  Copper (C), and  Desert (D). They  live in a  burrow that
consists  of  a hallway  and  four  side  rooms.  The side  rooms  are
initially full of amphipods, and the hallway is initially empty.

They  give  you  a  diagram  of the  situation  (your  puzzle  input),
including locations of each amphipod (A, B,  C, or D, each of which is
occupying an otherwise open space), walls (#), and open space (.).

For example:
#+begin_example
#############
#...........#
###B#C#B#D###
  #A#D#C#A#
  #########
#+end_example

The amphipods would like a method to organize every amphipod into side
rooms so  that each side  room contains one  type of amphipod  and the
types are sorted A-D going left to right, like this:
#+begin_example
#############
#...........#
###A#B#C#D###
  #A#B#C#D#
  #########
#+end_example

Amphipods can move up, down, left, or right so long as they are moving
into  an unoccupied  open  space.  Each type  of  amphipod requires  a
different amount of energy to move one step: Amber amphipods require 1
energy per step, Bronze amphipods  require 10 energy, Copper amphipods
require 100,  and Desert ones  require 1000. The amphipods  would like
you to  find a way to  organize the amphipods that  requires the least
total energy.

However, because they are timid  and stubborn, the amphipods have some
extra rules:
- Amphipods will never stop on the space immediately outside any
  room. They can move into that space so long as they immediately
  continue moving. (Specifically, this refers to the four open spaces
  in the hallway that are directly above an amphipod starting
  position.)
- Amphipods will never move from the hallway into a room unless that
  room is their destination room and that room contains no amphipods
  which do not also have that room as their own destination. If an
  amphipod's starting room is not its destination room, it can stay in
  that room until it leaves the room. (For example, an Amber amphipod
  will not move from the hallway into the right three rooms, and will
  only move into the leftmost room if that room is empty or if it only
  contains other Amber amphipods.)
- Once an amphipod stops moving in the hallway, it will stay in that
  spot until it can move into a room. (That is, once any amphipod
  starts moving, any other amphipods currently in the hallway are
  locked in place and will not move again until they can move fully
  into a room.)
  

In the above example, the amphipods can be organized using a minimum
of 12521 energy. One way to do this is shown below.

Starting configuration:
#+begin_example
#############
#...........#
###B#C#B#D###
  #A#D#C#A#
  #########
#+end_example

One Bronze amphipod moves into the hallway, taking 4 steps and using
40 energy:
#+begin_example
#############
#...B.......#
###B#C#.#D###
  #A#D#C#A#
  #########
#+end_example

The only Copper amphipod not in its side room moves there, taking 4
steps and using 400 energy:
#+begin_example
#############
#...B.......#
###B#.#C#D###
  #A#D#C#A#
  #########
#+end_example

A Desert amphipod moves out of the way, taking 3 steps and using 3000
energy, and then the Bronze amphipod takes its place, taking 3 steps
and using 30 energy:
#+begin_example
#############
#.....D.....#
###B#.#C#D###
  #A#B#C#A#
  #########
#+end_example

The leftmost Bronze amphipod moves to its room using 40 energy:
#+begin_example
#############
#.....D.....#
###.#B#C#D###
  #A#B#C#A#
  #########
#+end_example

Both amphipods in the rightmost room move into the hallway, using 2003
energy in total:
#+begin_example
#############
#.....D.D.A.#
###.#B#C#.###
  #A#B#C#.#
  #########
#+end_example

Both Desert amphipods move into the rightmost room using 7000 energy:
#+begin_example
#############
#.........A.#
###.#B#C#D###
  #A#B#C#D#
  #########
#+end_example

Finally, the last Amber amphipod moves into its room, using 8 energy:
#+begin_example
#############
#...........#
###A#B#C#D###
  #A#B#C#D#
  #########
#+end_example

What is the least energy required to organize the amphipods?
** TODO Day 23.2                                                  :noexport:

** TODO Day 24.1                                                  :noexport:

Magic smoke starts leaking from  the submarine's arithmetic logic unit
(ALU).  Without the  ability  to perform  basic  arithmetic and  logic
functions,  the  submarine  can't   produce  cool  patterns  with  its
Christmas lights!

It also can't navigate. Or run the oxygen system.

Don't worry, though - you probably have enough oxygen left to give you
enough time to build a new ALU.

The  ALU  is  a  four-dimensional  processing  unit:  it  has  integer
variables  w,  x,  y,  and  z. These  variables  all  start  with  the
value 0. The ALU also supports six instructions:
- inp a - Read an input value and write it to variable a.
- add a b - Add the value of a to the value of b, then store the
  result in variable a.
- mul a b - Multiply the value of a by the value of b, then store the
  result in variable a.
- div a b - Divide the value of a by the value of b, truncate the
  result to an integer, then store the result in variable a. (Here,
  "truncate" means to round the value toward zero.)
- mod a b - Divide the value of a by the value of b, then store the
  remainder in variable a. (This is also called the modulo operation.)
- eql a b - If the value of a and b are equal, then store the value 1
  in variable a. Otherwise, store the value 0 in variable a.
  
In all of these instructions, a  and b are placeholders; a will always
be the variable where the result of the operation is stored (one of w,
x, y, or z), while b can be either a variable or a number. Numbers can
be positive or negative, but will always be integers.

The ALU has no jump instructions; in an ALU program, every instruction
is run  exactly once in  order from top  to bottom. The  program halts
after the last instruction has finished executing.

(Program authors should be  especially cautious; attempting to execute
div with b=0 or attempting to execute  mod with a<0 or b<=0 will cause
the program to  crash and might even damage the  ALU. These operations
are never intended in any serious ALU program.)

For  example, here  is an  ALU program  which takes  an input  number,
negates it, and stores it in x:
#+begin_example
inp x
mul x -1
#+end_example

Here is an ALU program which takes two input numbers, then sets z to 1
if the second input number is  three times larger than the first input
number, or sets z to 0 otherwise:
#+begin_example
inp z
inp x
mul z 3
eql z x
#+end_example

Here is  an ALU program which  takes a non-negative integer  as input,
converts it  into binary, and  stores the lowest  (1's) bit in  z, the
second-lowest (2's) bit in y, the third-lowest (4's) bit in x, and the
fourth-lowest (8's) bit in w:
#+begin_example
inp w
add z w
mod z 2
div w 2
add y w
mod y 2
div w 2
add x w
mod x 2
div w 2
mod w 2
#+end_example

Once  you have  built a  replacement ALU,  you can  install it  in the
submarine, which  will immediately resume  what it was doing  when the
ALU failed: validating  the submarine's model number. To  do this, the
ALU will run the MOdel  Number Automatic Detector program (MONAD, your
puzzle input).

Submarine model  numbers are always fourteen-digit  numbers consisting
only of  digits 1  through 9.  The digit  0 cannot  appear in  a model
number.

When MONAD checks a hypothetical  fourteen-digit model number, it uses
fourteen separate inp  instructions, each expecting a  single digit of
the model number in order of  most to least significant. (So, to check
the model  number 13579246899999, you  would give  1 to the  first inp
instruction,  3 to  the second  inp instruction,  5 to  the third  inp
instruction, and  so on.) This  means that when operating  MONAD, each
input instruction  should only ever  be given  an integer value  of at
least 1 and at most 9.

Then, after  MONAD has  finished running all  of its  instructions, it
will  indicate that  the model  number  was valid  by leaving  a 0  in
variable z.  However, if the model  number was invalid, it  will leave
some other non-zero value in z.

MONAD imposes  additional, mysterious  restrictions on  model numbers,
and legend says the last copy  of the MONAD documentation was eaten by
a tanuki. You'll need to figure out what MONAD does some other way.

To enable  as many  submarine features as  possible, find  the largest
valid fourteen-digit model  number that contains no 0  digits. What is
the largest model number accepted by MONAD?
** TODO Day 24.2                                                  :noexport:

** TODO Day 25.1                                                  :noexport:

This is it: the bottom of the  ocean trench, the last place the sleigh
keys  could  be. Your  submarine's  experimental  antenna still  isn't
boosted enough to detect the keys, but they must be here. All you need
to do is reach the seafloor and find them.

At  least,   you'd  touch   down  on  the   seafloor  if   you  could;
unfortunately,  it's completely  covered  by two  large  herds of  sea
cucumbers,  and  there isn't  an  open  space  large enough  for  your
submarine.

You suspect  that the Elves must  have done this before,  because just
then you discover the phone number of a deep-sea marine biologist on a
handwritten note taped to the wall of the submarine's cockpit.

"Sea cucumbers?  Yeah, they're  probably hunting  for food.  But don't
worry, they're  predictable critters: they move  in perfectly straight
lines,  only moving  forward  when  there's space  to  do so.  They're
actually quite polite!"

You  explain that  you'd  like to  predict when  you  could land  your
submarine.

"Oh that's  easy, they'll  eventually pile up  and leave  enough space
for-- wait, did  you say submarine? And the only  place with that many
sea cucumbers would  be at the very bottom of  the Mariana--" You hang
up the phone.

There are  two herds  of sea  cucumbers sharing  the same  region; one
always moves  east (>), while the  other always moves south  (v). Each
location can contain at most one sea cucumber; the remaining locations
are  empty  (.).  The  submarine  helpfully generates  a  map  of  the
situation (your puzzle input). For example:
#+begin_example
v...>>.vv>
.vv>>.vv..
>>.>v>...v
>>v>>.>.v.
v>v.vv.v..
>.>>..v...
.vv..>.>v.
v.v..>>v.v
....v..v.>
#+end_example

Every step, the sea cucumbers in  the east-facing herd attempt to move
forward one location, then the  sea cucumbers in the south-facing herd
attempt to move forward one location. When a herd moves forward, every
sea cucumber in the herd  first simultaneously considers whether there
is a sea  cucumber in the adjacent location it's  facing (even another
sea cucumber facing  the same direction), and then  every sea cucumber
facing an empty location simultaneously moves into that location.

So, in a situation like this:
#+begin_example
...>>>>>...
#+end_example

After one step, only the rightmost sea cucumber would have moved:
#+begin_example
...>>>>.>..
#+end_example

After the next step, two sea cucumbers move:
#+begin_example
...>>>.>.>.
#+end_example

During  a single  step, the  east-facing  herd moves  first, then  the
south-facing herd moves. So, given this situation:
#+begin_example
..........
.>v....v..
.......>..
..........
#+end_example

After  a single  step, of  the  sea cucumbers  on the  left, only  the
south-facing sea  cucumber has moved (as  it wasn't out of  the way in
time for the  east-facing cucumber on the left to  move), but both sea
cucumbers on  the right  have moved (as  the east-facing  sea cucumber
moved out of the way of the south-facing sea cucumber):
#+begin_example
..........
.>........
..v....v>.
..........
#+end_example

Due to strong water currents in  the area, sea cucumbers that move off
the right edge of  the map appear on the left  edge, and sea cucumbers
that move off the  bottom edge of the map appear on  the top edge. Sea
cucumbers  always check  whether their  destination location  is empty
before moving, even if that destination is on the opposite side of the
map:
#+begin_example
Initial state:
...>...
.......
......>
v.....>
......>
.......
..vvv..

After 1 step:
..vv>..
.......
>......
v.....>
>......
.......
....v..

After 2 steps:
....v>.
..vv...
.>.....
......>
v>.....
.......
.......

After 3 steps:
......>
..v.v..
..>v...
>......
..>....
v......
.......

After 4 steps:
>......
..v....
..>.v..
.>.v...
...>...
.......
v......
#+end_example

To find a safe place to land your submarine, the sea cucumbers need to
stop moving. Again consider the first example:

#+begin_example
Initial state:
v...>>.vv>
.vv>>.vv..
>>.>v>...v
>>v>>.>.v.
v>v.vv.v..
>.>>..v...
.vv..>.>v.
v.v..>>v.v
....v..v.>

After 1 step:
....>.>v.>
v.v>.>v.v.
>v>>..>v..
>>v>v>.>.v
.>v.v...v.
v>>.>vvv..
..v...>>..
vv...>>vv.
>.v.v..v.v

After 2 steps:
>.v.v>>..v
v.v.>>vv..
>v>.>.>.v.
>>v>v.>v>.
.>..v....v
.>v>>.v.v.
v....v>v>.
.vv..>>v..
v>.....vv.

After 3 steps:
v>v.v>.>v.
v...>>.v.v
>vv>.>v>..
>>v>v.>.v>
..>....v..
.>.>v>v..v
..v..v>vv>
v.v..>>v..
.v>....v..

After 4 steps:
v>..v.>>..
v.v.>.>.v.
>vv.>>.v>v
>>.>..v>.>
..v>v...v.
..>>.>vv..
>.v.vv>v.v
.....>>vv.
vvv>...v..

After 5 steps:
vv>...>v>.
v.v.v>.>v.
>.v.>.>.>v
>v>.>..v>>
..v>v.v...
..>.>>vvv.
.>...v>v..
..v.v>>v.v
v.v.>...v.

...

After 10 steps:
..>..>>vv.
v.....>>.v
..v.v>>>v>
v>.>v.>>>.
..v>v.vv.v
.v.>>>.v..
v.v..>v>..
..v...>v.>
.vv..v>vv.

...

After 20 steps:
v>.....>>.
>vv>.....v
.>v>v.vv>>
v>>>v.>v.>
....vv>v..
.v.>>>vvv.
..v..>>vv.
v.v...>>.v
..v.....v>

...

After 30 steps:
.vv.v..>>>
v>...v...>
>.v>.>vv.>
>v>.>.>v.>
.>..v.vv..
..v>..>>v.
....v>..>v
v.v...>vv>
v.v...>vvv

...

After 40 steps:
>>v>v..v..
..>>v..vv.
..>>>v.>.v
..>>>>vvv>
v.....>...
v.v...>v>>
>vv.....v>
.>v...v.>v
vvv.v..v.>

...

After 50 steps:
..>>v>vv.v
..v.>>vv..
v.>>v>>v..
..>>>>>vv.
vvv....>vv
..v....>>>
v>.......>
.vv>....v>
.>v.vv.v..

...

After 55 steps:
..>>v>vv..
..v.>>vv..
..>>v>>vv.
..>>>>>vv.
v......>vv
v>v....>>v
vvv...>..>
>vv.....>.
.>v.vv.v..

After 56 steps:
..>>v>vv..
..v.>>vv..
..>>v>>vv.
..>>>>>vv.
v......>vv
v>v....>>v
vvv....>.>
>vv......>
.>v.vv.v..

After 57 steps:
..>>v>vv..
..v.>>vv..
..>>v>>vv.
..>>>>>vv.
v......>vv
v>v....>>v
vvv.....>>
>vv......>
.>v.vv.v..

After 58 steps:
..>>v>vv..
..v.>>vv..
..>>v>>vv.
..>>>>>vv.
v......>vv
v>v....>>v
vvv.....>>
>vv......>
.>v.vv.v..
#+end_example

In this example, the sea cucumbers stop moving after 58 steps.

Find somewhere safe to land your submarine. What is the first step on
which no sea cucumbers move?
** TODO Day 25.2                                                  :noexport:

** Stats                                                          :noexport:

#+CAPTION: https://adventofcode.com/2021/stats
| 25 |  3 | ▉▉▉                                       |
| 24 |  4 | ▉▉▉▉                                      |
| 23 |  4 | ▉▉▉▉                                      |
| 22 |  4 | ▉▉▉▉                                      |
| 21 |  6 | ▉▉▉▉▉▉                                    |
| 20 |  5 | ▉▉▉▉▉                                     |
| 19 |  4 | ▉▉▉▉                                      |
| 18 |  6 | ▉▉▉▉▉▉                                    |
| 17 |  7 | ▉▉▉▉▉▉▉                                   |
| 16 |  7 | ▉▉▉▉▉▉▉                                   |
| 15 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 14 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
| 13 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
| 12 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
| 11 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
| 10 | 12 | ▉▉▉▉▉▉▉▉▉▉▉▉                              |
|  9 | 13 | ▉▉▉▉▉▉▉▉▉▉▉▉▉                             |
|  8 | 15 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                           |
|  7 | 16 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                          |
|  6 | 17 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                         |
|  5 | 17 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                         |
|  4 | 20 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                      |
|  3 | 30 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉            |
|  2 | 34 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉        |
|  1 | 41 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ |
#+TBLFM: $3='(orgtbl-uc-draw-grid $2 0 41 41)


* 2020 [18/50]
** DONE Day 1.1

After saving Christmas  five years in a row, you've  decided to take a
vacation at a nice resort on a tropical island. Surely, Christmas will
go on without you.

The   tropical  island   has  its   own  currency   and  is   entirely
cash-only.  The gold  coins  used there  have a  little  picture of  a
starfish;  the locals  just  call  them stars.  None  of the  currency
exchanges seem to have heard of them, but somehow, you'll need to find
fifty of these coins by the time you arrive so you can pay the deposit
on your room.

To save  your vacation, you  need to get  all fifty stars  by December
25th.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

Before you  leave, the Elves in  accounting just need you  to fix your
expense report (your puzzle  input); apparently, something isn't quite
adding up.

Specifically, they need  you to find the two entries  that sum to 2020
and then multiply those two numbers together.

For example, suppose your expense report contained the following:

#+begin_example
1721
979
366
299
675
1456
#+end_example

In  this   list,  the  two   entries  that   sum  to  2020   are  1721
and 299.  Multiplying them together produces  1721 * 299 =  514579, so
the correct answer is 514579.

Of course,  your expense report is  much larger. Find the  two entries
that sum to 2020; what do you get if you multiply them together?

#+begin_src fennel -n :session d2001 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input ["1721" "979" "366" "299" "675" "1456"])

(fn solve [input]
  (let [xx (tonumber (aoc.first input))
        xs (aoc.rest input)
        res (lume.filter xs (fn [a] (= 2020 (+ (tonumber a) xx))))]
    (if (aoc.empty? res)
        (solve xs)
        (* xx (tonumber (. res 1))))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 514579 test-input)

(solve (aoc.string-from "2020/01.inp"))
#+end_src

#+RESULTS:
: 63616

** DONE Day 1.2

The Elves in  accounting are thankful for your help;  one of them even
offers  you  a   starfish  coin  they  had  left  over   from  a  past
vacation. They offer you a second one if you can find three numbers in
your expense report that meet the same criteria.

Using the above example again, the  three entries that sum to 2020 are
979,   366,  and   675.   Multiplying  them   together  produces   the
answer, 241861950.

In your expense report, what is  the product of the three entries that
sum to 2020?

#+begin_src fennel -n :session d2001 :exports both
(fn solve2 [input]
  (var res nil)
  (for [i 1 (length input) &until res]
    (for [j i (length input) &until res]
      (for [k j (length input) &until res]
        (let [ii (tonumber (. input i))
              jj (tonumber (. input j))
              kk (tonumber (. input k))]
          (when (= 2020 (+ ii jj kk))
            (set res (* ii jj kk)))))))
  res)

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 241861950 test-input)

(solve2 (aoc.string-from "2020/01.inp"))
#+end_src

#+RESULTS:
: 67877784

** DONE Day 2.1

Your  flight departs  in  a few  days from  the  coastal airport;  the
easiest way down to the coast from here is via toboggan.

The shopkeeper at the North Pole  Toboggan Rental Shop is having a bad
day. "Something's wrong with our computers;  we can't log in!" You ask
if you can take a look.

Their password  database seems to be  a little corrupted: some  of the
passwords  wouldn't  have  been   allowed  by  the  Official  Toboggan
Corporate Policy that was in effect when they were chosen.

To try  to debug the  problem, they have  created a list  (your puzzle
input)  of passwords  (according to  the corrupted  database) and  the
corporate policy when that password was set.

For example, suppose you have the following list:

#+begin_example
1-3 a: abcde
1-3 b: cdefg
2-9 c: ccccccccc
#+end_example

Each  line  gives the  password  policy  and  then the  password.  The
password policy  indicates the  lowest and highest  number of  times a
given letter  must appear for the  password to be valid.  For example,
1-3 a means  that the password must  contain a at least 1  time and at
most 3 times.

In  the above  example, 2  passwords are  valid. The  middle password,
cdefg,  is  not;  it  contains  no   instances  of  b,  but  needs  at
least 1. The  first and third passwords are valid:  they contain one a
or nine c, both within the limits of their respective policies.

How many passwords are valid according to their policies?

#+begin_src fennel -n :session d2002 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input ["1-3 a: abcde"
                   "1-3 b: cdefg"
                   "2-9 c: ccccccccc"])

(fn read-policy [line]
  (let [tokens (aoc.string-split line " ")
        [min max] (aoc.string-split (. tokens 1) "-")
        val (string.sub (. tokens 2) 1 -2)
        pass (. tokens 3)]
    {:min (tonumber min) :max (tonumber max) :val val :pass pass}))

(fn validate-policy [p]
  (var res 0)
  (each [_ v (ipairs (aoc.string-toarray (. p :pass)))]
    (when (= v (. p :val))
        (set res (+ 1 res))))
  (if (and (<= (. p :min) res)
       (<= res (. p :max)))
      1
      0))

(fn solve [input]
  (var count 0)
  (each [_ line (ipairs input)]
    (set count (+ count
                  (validate-policy (read-policy line)))))
  count)

(fn test [expected input]
  (assert (= expected (solve input))))

(test 2 test-input)

(solve (aoc.string-from "2020/02.inp"))
#+end_src

#+RESULTS:
: 600

** DONE Day 2.2

While it  appears you  validated the  passwords correctly,  they don't
seem to be what the  Official Toboggan Corporate Authentication System
is expecting.

The shopkeeper  suddenly realizes that he  just accidentally explained
the password  policy rules from his  old job at the  sled rental place
down the street! The Official Toboggan Corporate Policy actually works
a little differently.

Each policy actually describes two  positions in the password, where 1
means  the first  character,  2  means the  second  character, and  so
on. (Be careful; Toboggan Corporate Policies have no concept of "index
zero"!)  Exactly  one  of  these  positions  must  contain  the  given
letter.  Other  occurrences  of  the letter  are  irrelevant  for  the
purposes of policy enforcement.

Given the same example list from above:

#+begin_example
1-3 a: abcde is valid: position 1 contains a and position 3 does not.
1-3 b: cdefg is invalid: neither position 1 nor position 3 contains b.
2-9 c: ccccccccc is invalid: both position 2 and position 9 contain c.
#+end_example

How many passwords are valid according to the new interpretation of
the policies?

#+begin_src fennel -n :session d2002 :exports both
(fn validate-policy2 [p]
  (let [val (. p :val)
        arr (aoc.string-toarray (. p :pass))]
    (if (aoc.xor
         (= val (. arr (. p :min)))
         (= val (. arr (. p :max))))
        1
        0)))

(fn solve2 [input]
  (var count 0)
  (each [_ line (ipairs input)]
    (set count (+ count
                  (validate-policy2 (read-policy line)))))
  count)

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 1 test-input)

(solve2 (aoc.string-from "2020/02.inp"))
#+end_src

#+RESULTS:
: 245

** DONE Day 3.1

With  the toboggan  login problems  resolved, you  set off  toward the
airport. While  travel by toboggan  might be easy, it's  certainly not
safe:  there's  very minimal  steering  and  the  area is  covered  in
trees. You'll need  to see which angles will take  you near the fewest
trees.

Due  to the  local geology,  trees  in this  area only  grow on  exact
integer coordinates in  a grid. You make a map  (your puzzle input) of
the open squares (.) and trees (#) you can see. For example:

#+begin_example
..##.......
#...#...#..
.#....#..#.
..#.#...#.#
.#...##..#.
..#.##.....
.#.#.#....#
.#........#
#.##...#...
#...##....#
.#..#...#.#
#+end_example

These aren't the  only trees, though; due to something  you read about
once involving arboreal genetics and biome stability, the same pattern
repeats to the right many times:

#+begin_example
..##.........##.........##.........##.........##.........##.......  --->
#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
.#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
.#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
..#.##.......#.##.......#.##.......#.##.......#.##.......#.##.....  --->
.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
.#........#.#........#.#........#.#........#.#........#.#........#
#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...
#...##....##...##....##...##....##...##....##...##....##...##....#
.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#  --->
#+end_example

You start on  the open square (.)  in the top-left corner  and need to
reach the bottom (below the bottom-most row on your map).

The toboggan  can only follow a  few specific slopes (you  opted for a
cheaper model  that prefers rational  numbers); start by  counting all
the trees you would encounter for the slope right 3, down 1:

From your starting  position at the top-left, check  the position that
is right 3  and down 1. Then,  check the position that is  right 3 and
down 1 from there, and so on until you go past the bottom of the map.

The locations you'd check in the  above example are marked here with O
where there was an open square and X where there was a tree:

#+begin_example
..##.........##.........##.........##.........##.........##.......  --->
#..O#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
.#....X..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
..#.#...#O#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
.#...##..#..X...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
..#.##.......#.X#.......#.##.......#.##.......#.##.......#.##.....  --->
.#.#.#....#.#.#.#.O..#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
.#........#.#........X.#........#.#........#.#........#.#........#
#.##...#...#.##...#...#.X#...#...#.##...#...#.##...#...#.##...#...
#...##....##...##....##...#X....##...##....##...##....##...##....#
.#..#...#.#.#..#...#.#.#..#...X.#.#..#...#.#.#..#...#.#.#..#...#.#  --->
#+end_example

In this example,  traversing the map using this slope  would cause you
to encounter 7 trees.

Starting at the  top-left corner of your map and  following a slope of
right 3 and down 1, how many trees would you encounter?

#+begin_src fennel -n :session d2003 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["..##......."
                   "#...#...#.."
                   ".#....#..#."
                   "..#.#...#.#"
                   ".#...##..#."
                   "..#.##....."
                   ".#.#.#....#"
                   ".#........#"
                   "#.##...#..."
                   "#...##....#"
                   ".#..#...#.#"])

(fn solve [dx dy lines]
  (var posx 1)
  (var posy 1)
  (let [field (aoc.read-matrix lines)
        lenx (length (. field 1))
        leny (length field)
        res []]
    (while (<= posy leny)
      (case (. (. field posy ) posx)
        "." (table.insert res 0)
        "#" (table.insert res 1))
      (set posx (if (>= lenx (+ dx posx))
                    (+ dx posx)
                    (- (+ dx posx) lenx)))
      (set posy (+ dy posy)))
    (aoc.table-sum res)))

(fn test [expected dx dy input]
  (assert (= expected (solve dx dy input))))

(test 7 3 1 test-input)

(solve 3 1 (aoc.string-from "2020/03.inp"))
#+end_src

#+RESULTS:
: 178


** DONE Day 3.2

Time  to check  the rest  of the  slopes -  you need  to minimize  the
probability of a sudden arboreal stop, after all.

Determine the number of trees you  would encounter if, for each of the
following slopes,  you start at  the top-left corner and  traverse the
map all the way to the bottom:
- Right 1, down 1.
- Right 3, down 1. (This is the slope you already checked.)
- Right 5, down 1.
- Right 7, down 1.
- Right 1, down 2.

In  the above  example, these  slopes would  find 2,  7, 3,  4, and  2
tree(s)   respectively;  multiplied   together,   these  produce   the
answer 336.

What  do  you  get  if  you multiply  together  the  number  of  trees
encountered on each of the listed slopes?

#+begin_src fennel -n :session d2003 :exports both
(fn solve2 [lines]
  (let [slopes [[1 1]
                [3 1]
                [5 1]
                [7 1]
                [1 2]]
        res []]
    (each [_ [dx dy] (ipairs slopes)]
      (table.insert res (solve dx dy lines)))
    (aoc.table-prod res)))

(fn test2 [expected lines]
  (assert (= expected (solve2 lines))))

(test2 336 test-input)

(solve2 (aoc.string-from "2020/03.inp"))
#+end_src

#+RESULTS:
: 3492520200

** DONE Day 4.1

You arrive at the airport only  to realize that you grabbed your North
Pole Credentials instead  of your passport. While  these documents are
extremely similar, North  Pole Credentials aren't issued  by a country
and therefore aren't  actually valid documentation for  travel in most
of the world.

It seems like you're not the  only one having problems, though; a very
long  line has  formed for  the automatic  passport scanners,  and the
delay could upset your travel itinerary.

Due to  some questionable network  security, you realize you  might be
able to solve both of these problems at the same time.

The  automatic  passport  scanners  are slow  because  they're  having
trouble  detecting  which  passports  have all  required  fields.  The
expected fields are as follows:
- byr (Birth Year)
- iyr (Issue Year)
- eyr (Expiration Year)
- hgt (Height)
- hcl (Hair Color)
- ecl (Eye Color)
- pid (Passport ID)
- cid (Country ID)

Passport data  is validated in  batch files (your puzzle  input). Each
passport is represented as a  sequence of key:value pairs separated by
spaces or newlines. Passports are separated by blank lines.

Here is an example batch file containing four passports:

#+begin_example
ecl:gry pid:860033327 eyr:2020 hcl:#fffffd
byr:1937 iyr:2017 cid:147 hgt:183cm

iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884
hcl:#cfa07d byr:1929

hcl:#ae17e1 iyr:2013
eyr:2024
ecl:brn pid:760753108 byr:1931
hgt:179cm

hcl:#cfa07d eyr:2025 pid:166559648
iyr:2011 ecl:brn hgt:59in
#+end_example

The first passport is valid - all eight fields are present. The second
passport is invalid - it is missing hgt (the Height field).

The third passport  is interesting; the only missing field  is cid, so
it looks like data from North Pole Credentials, not a passport at all!
Surely, nobody  would mind if  you made the system  temporarily ignore
missing cid fields. Treat this "passport" as valid.

The fourth passport is missing two fields, cid and byr. Missing cid is
fine, but missing any other field is not, so this passport is invalid.

According  to the  above rules,  your improved  system would  report 2
valid passports.

Count the  number of valid  passports -  those that have  all required
fields. Treat cid as optional. In  your batch file, how many passports
are valid?

#+begin_src fennel -n :session d2004 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["ecl:gry pid:860033327 eyr:2020 hcl:#fffffd"
        "byr:1937 iyr:2017 cid:147 hgt:183cm"
        ""
        "iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884"
        "hcl:#cfa07d byr:1929"
        ""
        "hcl:#ae17e1 iyr:2013"
        "eyr:2024"
        "ecl:brn pid:760753108 byr:1931"
        "hgt:179cm"
        ""
        "hcl:#cfa07d eyr:2025 pid:166559648"
        "iyr:2011 ecl:brn hgt:59in"])

(fn valid? [record]
  (if (and (. record :byr) (. record :iyr) (. record :eyr)
           (. record :hgt) (. record :hcl) (. record :ecl)
           (. record :pid))
      record
      nil))

(fn lines-torecords [lines]
  (when (not (= "" (. lines (length lines))))
    (table.insert lines "")) ;; need separator for last iteration
  (let [records []
        record []]
    (each [_ line (ipairs lines)]
      (if (= "" line)
          (do
            (table.insert records (aoc.string-totable (table.concat record " ")))
            (aoc.table-reset record))
          (table.insert record line)))
    records))

(fn solve [lines]
  (let [records (lines-torecords lines)]
    (length (lume.filter records (fn [x] (valid? x))))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 2 test-input)

(solve (aoc.string-from "2020/04.inp"))
#+end_src

#+RESULTS:
: 202


** DONE Day 4.2

The line is moving more quickly now, but you overhear airport security
talking   about  how   passports   with  invalid   data  are   getting
through. Better add some data validation, quick!

You can  continue to ignore  the cid field,  but each other  field has
strict rules about what values are valid for automatic validation:
- byr (Birth Year) - four digits; at least 1920 and at most 2002.
- iyr (Issue Year) - four digits; at least 2010 and at most 2020.
- eyr (Expiration Year) - four digits; at least 2020 and at most 2030.
- hgt (Height) - a number followed by either cm or in:
  - If cm, the number must be at least 150 and at most 193.
  - If in, the number must be at least 59 and at most 76.
- hcl (Hair Color) - a # followed by exactly six characters 0-9 or a-f.
- ecl (Eye Color) - exactly one of: amb blu brn gry grn hzl oth.
- pid (Passport ID) - a nine-digit number, including leading zeroes.
- cid (Country ID) - ignored, missing or not.

Your job is to count the  passports where all required fields are both
present and valid according to the  above rules. Here are some example
values:

#+begin_example
byr valid:   2002
byr invalid: 2003

hgt valid:   60in
hgt valid:   190cm
hgt invalid: 190in
hgt invalid: 190

hcl valid:   #123abc
hcl invalid: #123abz
hcl invalid: 123abc

ecl valid:   brn
ecl invalid: wat

pid valid:   000000001
pid invalid: 0123456789
#+end_example

Here are some invalid passports:

#+begin_example
eyr:1972 cid:100
hcl:#18171d ecl:amb hgt:170 pid:186cm iyr:2018 byr:1926

iyr:2019
hcl:#602927 eyr:1967 hgt:170cm
ecl:grn pid:012533040 byr:1946

hcl:dab227 iyr:2012
ecl:brn hgt:182cm pid:021572410 eyr:2020 byr:1992 cid:277

hgt:59cm ecl:zzz
eyr:2038 hcl:74454a iyr:2023
pid:3556412378 byr:2007
#+end_example

Here are some valid passports:

#+begin_example
pid:087499704 hgt:74in ecl:grn iyr:2012 eyr:2030 byr:1980
hcl:#623a2f

eyr:2029 ecl:blu cid:129 byr:1989
iyr:2014 pid:896056539 hcl:#a97842 hgt:165cm

hcl:#888785
hgt:164cm byr:2001 iyr:2015 cid:88
pid:545766238 ecl:hzl
eyr:2022

iyr:2010 hgt:158cm hcl:#b6652a ecl:blu byr:1944 eyr:2021 pid:093154719
#+end_example

Count the number of valid passports - those that have all required
fields and valid values. Continue to treat cid as optional. In your
batch file, how many passports are valid?

#+begin_src fennel -n :session d2004 :exports both
(local test-input2
       ["pid:087499704 hgt:74in ecl:grn iyr:2012 eyr:2030 byr:1980"
        "hcl:#623a2f"
        ""
        "eyr:2029 ecl:blu cid:129 byr:1989"
        "iyr:2014 pid:896056539 hcl:#a97842 hgt:165cm"
        ""
        "hcl:#888785"
        "hgt:164cm byr:2001 iyr:2015 cid:88"
        "pid:545766238 ecl:hzl"
        "eyr:2022"
        ""
        "iyr:2010 hgt:158cm hcl:#b6652a ecl:blu byr:1944 eyr:2021 pid:093154719"
        ""
        "eyr:1972 cid:100"
        "hcl:#18171d ecl:amb hgt:170 pid:186cm iyr:2018 byr:1926"
        ""
        "iyr:2019"
        "hcl:#602927 eyr:1967 hgt:170cm"
        "ecl:grn pid:012533040 byr:1946"
        ""
        "hcl:dab227 iyr:2012"
        "ecl:brn hgt:182cm pid:021572410 eyr:2020 byr:1992 cid:277"
        ""
        "hgt:59cm ecl:zzz"
        "eyr:2038 hcl:74454a iyr:2023"
        "pid:3556412378 byr:2007"])

(fn valid-byr? [record]
  "valid if four digits at least 1920 and at most 2002"
  (match (tonumber (. record :byr))
    (where byr (and (<= 1920 byr) (<= byr 2002))) true
    _ false))

(fn valid-iyr? [record]
  "valid if four digits at least 2010 and at most 2020"
  (match (tonumber (. record :iyr))
    (where iyr (and (<= 2010 iyr) (<= iyr 2020))) true
    _ false))

(fn valid-eyr? [record]
  "valid if four digits at least 2020 and at most 2030"
  (match (tonumber (. record :eyr))
    (where eyr (and (<= 2020 eyr) (<= eyr 2030))) true
    _ false))

(fn valid-hgt? [record]
  "valid if number between 150cm and 193cm or 59in and 76in"
  (match (. record :hgt)
    (where hgt (or
                (and (= "cm" (string.sub hgt -2))
                     (let [h (tonumber (string.sub hgt 1 -3))]
                       (and (<= 150 h) (<= h 193))))
                (and (= "in" (string.sub hgt -2))
                     (let [h (tonumber (string.sub hgt 1 -3))]
                       (and (<= 59 h) (<= h 76)))))) true
    _ false))

(fn valid-hcl? [record]
  "valid if a # followed by exactly six characters 0-9 or a-f"
  (match (. record :hcl)
    (where hcl (and (= 7 (length hcl))
                    (= "#" (string.sub hcl 1 1))
                    (let [(b e) (string.find hcl "%x*" 2)]
                      (and (= b 2) (= e 7))))) true
    _ false))

(fn valid-ecl? [record]
  "valid if exactly one of: amb blu brn gry grn hzl oth"
  (case (. record :ecl)
    "amb" true
    "blu" true
    "brn" true
    "gry" true
    "grn" true
    "hzl" true
    "oth" true
    _ false))

(fn valid-pid? [record]
  "valid if a nine-digit number, including leading zeroes"
  (match (. record :pid)
    (where pid (and (string.find pid "%d") (= 9 (length pid)))) true
    _ false))

(fn valid2? [record]
  (and (valid-byr? record)
       (valid-iyr? record)
       (valid-eyr? record)
       (valid-hgt? record)
       (valid-hcl? record)
       (valid-ecl? record)
       (valid-pid? record)))

(fn solve2 [lines]
  (let [records (lines-torecords lines)]
    (length (lume.filter records (fn [x] (valid2? x))))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 4 test-input2)

(solve2 (aoc.string-from "2020/04.inp"))
#+end_src

#+RESULTS:
: 137

** DONE Day 5.1

You board your plane only to  discover a new problem: you dropped your
boarding pass!  You aren't sure  which seat is  yours, and all  of the
flight attendants are busy with the flood of people that suddenly made
it through passport control.

You write a  quick program to use  your phone's camera to  scan all of
the nearby boarding  passes (your puzzle input); perhaps  you can find
your seat through process of elimination.

Instead  of   zones  or  groups,   this  airline  uses   binary  space
partitioning  to  seat   people.  A  seat  might   be  specified  like
FBFBBFFRLR, where F means "front", B means "back", L means "left", and
R means "right".

The first  7 characters will either  be F or B;  these specify exactly
one of the 128 rows on the plane (numbered 0 through 127). Each letter
tells you which half of a region  the given seat is in. Start with the
whole list of rows; the first  letter indicates whether the seat is in
the front (0 through 63) or the back (64 through 127). The next letter
indicates which half  of that region the  seat is in, and  so on until
you're left with exactly one row.

For example, consider just the first seven characters of FBFBBFFRLR:
- Start by considering the whole range, rows 0 through 127.
- F means to take the lower half, keeping rows 0 through 63.
- B means to take the upper half, keeping rows 32 through 63.
- F means to take the lower half, keeping rows 32 through 47.
- B means to take the upper half, keeping rows 40 through 47.
- B keeps rows 44 through 47.
- F keeps rows 44 through 45.
- The final F keeps the lower of the two, row 44.

The last three characters will be either L or R; these specify exactly
one of the 8 columns of seats on the plane (numbered 0 through 7). The
same  process as  above  proceeds  again, this  time  with only  three
steps. L means to keep the lower half, while R means to keep the upper
half.

For example, consider just the last 3 characters of FBFBBFFRLR:
- Start by considering the whole range, columns 0 through 7.
- R means to take the upper half, keeping columns 4 through 7.
- L means to take the lower half, keeping columns 4 through 5.
- The final R keeps the upper of the two, column 5.

So,  decoding FBFBBFFRLR  reveals  that  it is  the  seat  at row  44,
column 5.

Every seat also has a unique seat  ID: multiply the row by 8, then add
the column. In this example, the seat has ID 44 * 8 + 5 = 357.

Here are some other boarding passes:
- BFFFBBFRRR: row 70, column 7, seat ID 567.
- FFFBBBFRRR: row 14, column 7, seat ID 119.
- BBFFBBFRLL: row 102, column 4, seat ID 820.

As a sanity check, look through  your list of boarding passes. What is
the highest seat ID on a boarding pass?

#+begin_src fennel -n :session d2005 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["FBFBBFFRLR"
                   "BFFFBBFRRR"
                   "FFFBBBFRRR"
                   "BBFFBBFRLL"])

(fn find-row [input range]
  (let [c (aoc.first input)
        e (aoc.rest input)]
    (case c
      "F" (find-row e (aoc.table-range range 1 (/ (length range) 2)))
      "B" (find-row e (aoc.table-range range (+ 1 (/ (length range) 2)) (length range)))
      _ (. range 1))))

(fn find-col [input range]
  (let [c (aoc.first input)
        e (aoc.rest input)]
    (case c
      "L" (find-col e (aoc.table-range range 1 (/ (length range) 2)))
      "R" (find-col e (aoc.table-range range (+ 1 (/ (length range) 2)) (length range)))
      _ (. range 1))))

(fn find-seat-num [line]
  (let [rows (aoc.range 0 127)
        cols (aoc.range 0 7)
        input (aoc.string-toarray line)
        input-row (aoc.table-range input  1 7)
        input-col (aoc.table-range input  8 10)
        row (find-row input-row rows)
        col (find-col input-col cols)]
    (+ (* row 8) col)))

(fn find-seat-nums [lines]
  (let [res []]
    (each [_ line (ipairs lines)]
      (table.insert res (find-seat-num line)))
    res))

(fn solve [lines]
  (aoc.table-max (find-seat-nums lines)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 820 test-input)

(solve (aoc.string-from "2020/05.inp"))
#+end_src

#+RESULTS:
: 890

** DONE Day 5.2

Ding! The "fasten seat belt" signs have turned on. Time to find your
seat.

It's a completely full flight, so your seat should be the only missing
boarding pass  in your  list. However,  there's a  catch: some  of the
seats at  the very  front and back  of the plane  don't exist  on this
aircraft, so they'll be missing from your list as well.

Your seat wasn't at the very front or back, though; the seats with IDs
+1 and -1 from yours will be in your list.

What is the ID of your seat?

#+begin_src fennel -n :session d2005 :exports both
(fn solve2 [lines]
  (let [all-seats (aoc.range-to 85 890)
        taken-seats (find-seat-nums lines)
        free-seats (lume.filter all-seats (fn [x] (not (lume.find taken-seats x))))]
    (. free-seats 1)))

(solve2 (aoc.string-from "2020/05.inp"))
#+end_src

#+RESULTS:
: 651

** DONE Day 6.1

As your flight approaches the  regional airport where you'll switch to
a much larger plane, customs  declaration forms are distributed to the
passengers.

The form  asks a  series of  26 yes-or-no  questions marked  a through
z. All you  need to do is  identify the questions for  which anyone in
your group answers  "yes". Since your group is just  you, this doesn't
take very long.

However, the  person sitting next  to you  seems to be  experiencing a
language barrier and asks  if you can help. For each  of the people in
their group, you write down the questions for which they answer "yes",
one per line. For example:

#+begin_example
abcx
abcy
abcz
#+end_example

In this group,  there are 6 questions to which  anyone answered "yes":
a, b, c,  x, y, and z.  (Duplicate answers to the  same question don't
count extra; each question counts at most once.)

Another group asks for your  help, then another, and eventually you've
collected  answers  from  every  group   on  the  plane  (your  puzzle
input). Each group's answers are separated by a blank line, and within
each group, each person's answers are on a single line. For example:

#+begin_example
abc

a
b
c

ab
ac

a
a
a
a

b
#+end_example

This list represents answers from five groups:
- The first group contains one person who answered "yes" to 3
  questions: a, b, and c.
- The second group contains three people; combined, they answered
  "yes" to 3 questions: a, b, and c.
- The third group contains two people; combined, they answered "yes"
  to 3 questions: a, b, and c.
- The fourth group contains four people; combined, they answered "yes"
  to only 1 question, a.
- The last group contains one person who answered "yes" to only 1
  question, b.
  
In this example, the sum of these counts is 3 + 3 + 3 + 1 + 1 = 11.

For each group, count the number of questions to which anyone answered
"yes". What is the sum of those counts?

#+begin_src fennel -n :session d2006 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["abc" ""
                   "a" "b" "c" ""
                   "ab" "ac" ""
                   "a" "a" "a" "a" ""
                   "b"])

(fn any-answers [input]
  (when (not= "" (. input (length input)))
    (table.insert input ""))
  (let [res []
        group []]
    (each [_ line (ipairs input)]
      (if (= "" line)
          (do (table.insert res (length (aoc.table-union group)))
              (aoc.table-reset group))
          (table.insert group (aoc.string-toarray line))))
    res))

(fn solve [input]
  (let [answers (any-answers input)]
    (accumulate [sum 0 _ answer (ipairs answers)]
      (+ sum answer))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 11 test-input)

(solve (aoc.string-from "2020/06.inp"))
#+end_src

#+RESULTS:
: 7120


** DONE Day 6.2

As you  finish the last  group's customs declaration, you  notice that
you misread one word in the instructions:

You  don't need  to identify  the questions  to which  anyone answered
"yes"; you need  to identify the questions to  which everyone answered
"yes"!

Using the same example as above:
#+begin_example
abc

a
b
c

ab
ac

a
a
a
a

b
#+end_example

This list represents answers from five groups:
- In the first group, everyone (all 1 person) answered "yes" to 3
  questions: a, b, and c.
- In the second group, there is no question to which everyone answered
  "yes".
- In the third group, everyone answered yes to only 1 question,
  a. Since some people did not answer "yes" to b or c, they don't
  count.
- In the fourth group, everyone answered yes to only 1 question, a.
- In the fifth group, everyone (all 1 person) answered "yes" to 1
  question, b.
  
In this example, the sum of these counts is =3 + 0 + 1 + 1 + 1 = 6=.

For each group, count the number of questions to which everyone
answered "yes". What is the sum of those counts?

#+begin_src fennel -n :session d2006 :exports both
(fn every-answers [input]
  (when (not= "" (. input (length input)))
    (table.insert input ""))
  (let [res []
        group []]
    (each [_ line (ipairs input)]
      (if (= "" line)
          (do (table.insert res (length (aoc.table-disjunc group)))
              (aoc.table-reset group))
          (table.insert group (aoc.string-toarray line))))
    res))

(fn solve2 [input]
  (let [answers (every-answers input)]
    (accumulate [sum 0 _ answer (ipairs answers)]
      (+ sum answer))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 6 test-input)

(solve2 (aoc.string-from "2020/06.inp"))
#+end_src

#+RESULTS:
: 3570

** DONE Day 7.1

You land  at the  regional airport  in time for  your next  flight. In
fact,  it looks  like you'll  even have  time to  grab some  food: all
flights are currently delayed due to issues in luggage processing.

Due to recent aviation regulations, many rules (your puzzle input) are
being enforced about bags and their contents; bags must be color-coded
and   must   contain   specific  quantities   of   other   color-coded
bags. Apparently, nobody responsible  for these regulations considered
how long they would take to enforce!

For example, consider the following rules:

#+begin_example
light red bags contain 1 bright white bag, 2 muted yellow bags.
dark orange bags contain 3 bright white bags, 4 muted yellow bags.
bright white bags contain 1 shiny gold bag.
muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.
shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.
dark olive bags contain 3 faded blue bags, 4 dotted black bags.
vibrant plum bags contain 5 faded blue bags, 6 dotted black bags.
faded blue bags contain no other bags.
dotted black bags contain no other bags.
#+end_example

These rules  specify the required  contents for  9 bag types.  In this
example,  every  faded blue  bag  is  empty,  every vibrant  plum  bag
contains 11 bags (5 faded blue and 6 dotted black), and so on.

You have a shiny  gold bag. If you wanted to carry it  in at least one
other  bag, how  many  different bag  colors would  be  valid for  the
outermost  bag? (In  other  words: how  many  colors can,  eventually,
contain at least one shiny gold bag?)

In the above rules, the following options would be available to you:
- A bright white bag, which can hold your shiny gold bag directly.
- A muted yellow bag, which can hold your shiny gold bag directly,
  plus some other bags.
- A dark orange bag, which can hold bright white and muted yellow
  bags, either of which could then hold your shiny gold bag.
- A light red bag, which can hold bright white and muted yellow bags,
  either of which could then hold your shiny gold bag.
  
So, in  this example,  the number  of bag  colors that  can eventually
contain at least one shiny gold bag is 4.

How many  bag colors can  eventually contain  at least one  shiny gold
bag? (The list of rules is quite long; make sure you get all of it.)

#+begin_src fennel -n :session d2007 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["light red bags contain 1 bright white bag, 2 muted yellow bags."
        "dark orange bags contain 3 bright white bags, 4 muted yellow bags."
        "bright white bags contain 1 shiny gold bag."
        "muted yellow bags contain 2 shiny gold bags, 9 faded blue bags."
        "shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags."
        "dark olive bags contain 3 faded blue bags, 4 dotted black bags."
        "vibrant plum bags contain 5 faded blue bags, 6 dotted black bags."
        "faded blue bags contain no other bags."
        "dotted black bags contain no other bags."])

(fn read-line [line]
  (case (aoc.string-split line " ")
    [t11 t12 "bags" "contain" "no" "other" "bags."]
    [(.. t11 t12) {}]
    [t11 t12 "bags" "contain" n2 t21 t22 "bags."]
    [(.. t11 t12) {(.. t21 t22) (tonumber n2)}]
    [t11 t12 "bags" "contain" n2 t21 t22 "bags," n3 t31 t32 "bags."]
    [(.. t11 t12) {(.. t21 t22) (tonumber n2) (.. t31 t32) (tonumber n3)}]
    [t11 t12 "bags" "contain" n2 t21 t22 "bags," n3 t31 t32 "bags," n4 t41 t42 "bags."]
    [(.. t11 t12) {(.. t21 t22) (tonumber n2) (.. t31 t32) (tonumber n3) (.. t41 t42) (tonumber n4)}]
    [t11 t12 "bags" "contain" n2 t21 t22 "bags," n3 t31 t32 "bags," n4 t41 t42 "bags," n5 t51 t52 "bags."]
    [(.. t11 t12) {(.. t21 t22) (tonumber n2) (.. t31 t32) (tonumber n3) (.. t41 t42) (tonumber n4) (.. t51 t52) (tonumber n5)}]
    _ (do (print (..  "W:" line)) nil)))

(fn bag2bags [line]
  (string.gsub (string.gsub line "bag," "bags,") "bag%." "bags%."))

(fn read-lines [lines]
  (let [res {}]
    (each [_ line (ipairs lines)]
      (let [rule (read-line (bag2bags line))]
        (tset res (. rule 1) (. rule 2))))
    res))

(fn search-symbol [tree symbol]
  (let [res []]
    (each [k v (pairs tree)]
      (when (. v symbol)
        (table.insert res k)))
    res))

(fn solve [lines]
  (let [tree (read-lines lines)
        search [:shinygold]
        found []]
    (while (< 0 (length search))
      (let [child (table.remove search 1)
            parents (search-symbol tree child)]
        (when (< 0 (length parents))
          (lume.map parents
                    (fn [p]
                      (when (not (lume.find found p))
                        (table.insert search p)
                        (table.insert found p)))))))
    (length found)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 4 test-input)

(solve (aoc.string-from "2020/07.inp"))
#+end_src

#+RESULTS:
: 128

** DONE Day 7.2

It's  getting pretty  expensive to  fly these  days -  not because  of
ticket prices, but  because of the ridiculous number of  bags you need
to buy!

Consider again your =shiny gold= bag and the rules from the above example:
- =faded blue= bags contain 0 other bags.
- =dotted black= bags contain 0 other bags.
- =vibrant plum=  bags contain 11  other bags: 5  =faded blue= bags  and 6
  =dotted black= bags.
- =dark olive= bags contain 7 other bags: 3 =faded blue= bags and 4 =dotted
  black= bags.

So, a single =shiny  gold= bag must contain 1 =dark olive=  bag (and the 7
bags within it) plus 2 =vibrant plum=  bags (and the 11 bags within each
of those): =1 + 1*7 + 2 + 2*11 = 32= bags!

Of  course, the  actual rules  have a  small chance  of going  several
levels deeper  than this example;  be sure to  count all of  the bags,
even if the nesting becomes topologically impractical!

Here's another example:

#+begin_example
shiny gold bags contain 2 dark red bags.
dark red bags contain 2 dark orange bags.
dark orange bags contain 2 dark yellow bags.
dark yellow bags contain 2 dark green bags.
dark green bags contain 2 dark blue bags.
dark blue bags contain 2 dark violet bags.
dark violet bags contain no other bags.
#+end_example

In this example, a single =shiny gold= bag must contain 126 other bags.

How many  individual bags are  required inside your single  =shiny gold=
bag?

#+begin_src fennel -n :session d2007 :exports both
(local test2-input
       ["shiny gold bags contain 2 dark red bags."
        "dark red bags contain 2 dark orange bags."
        "dark orange bags contain 2 dark yellow bags."
        "dark yellow bags contain 2 dark green bags."
        "dark green bags contain 2 dark blue bags."
        "dark blue bags contain 2 dark violet bags."
        "dark violet bags contain no other bags."])

(macro times [t body1 & rest-body]
  `(fcollect [i# 1 ,t 1]
     (do ,body1 ,(unpack rest-body))))

(fn solve2 [lines]
  (let [tree (read-lines lines)
        search [:shinygold]
        found []]
    (while (< 0 (length search))
      (let [root (table.remove search 1)]
        (each [k v (pairs (. tree root))]
          (times v (table.insert search k))
          (times v (table.insert found k)))))
    (length found)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 32 test-input)

(test2 126 test2-input)

(solve2 (aoc.string-from "2020/07.inp"))
#+end_src

#+RESULTS:
: 20189

** DONE Day 8.1

Your flight to the major airline hub reaches cruising altitude without
incident. While  you consider checking  the in-flight menu for  one of
those drinks that come with a  little umbrella, you are interrupted by
the kid sitting next to you.

Their handheld game console won't turn on!  They ask if you can take a
look.

You narrow  the problem down  to a strange  infinite loop in  the boot
code (your puzzle input) of the device.  You should be able to fix it,
but first you need to be able to run the code in isolation.

The boot code  is represented as a text file  with one instruction per
line of text. Each instruction consists  of an operation (acc, jmp, or
nop) and an argument (a signed number like +4 or -20).
- acc  increases  or  decreases  a  single  global  value  called  the
  accumulator by the value given in  the argument. For example, acc +7
  would  increase  the  accumulator   by  7.  The  accumulator  starts
  at 0. After an acc instruction, the instruction immediately below it
  is executed next.
- jmp  jumps  to  a  new  instruction relative  to  itself.  The  next
  instruction to execute is found using the argument as an offset from
  the  jmp  instruction; for  example,  jmp  +2  would skip  the  next
  instruction, jmp  +1 would  continue to the  instruction immediately
  below it, and jmp -20 would  cause the instruction 20 lines above to
  be executed next.
- nop  stands for  No OPeration  -  it does  nothing. The  instruction
  immediately below it is executed next.

For example, consider the following program:

#+begin_example
nop +0
acc +1
jmp +4
acc +3
jmp -3
acc -99
acc +1
jmp -4
acc +6
#+end_example

These instructions are visited in this order:

#+begin_example
nop +0  | 1
acc +1  | 2, 8(!)
jmp +4  | 3
acc +3  | 6
jmp -3  | 7
acc -99 |
acc +1  | 4
jmp -4  | 5
acc +6  |
#+end_example

First, the  nop +0  does nothing. Then,  the accumulator  is increased
from 0 to 1 (acc +1) and jmp +4 sets the next instruction to the other
acc +1 near  the bottom. After it increases the  accumulator from 1 to
2,  jmp -4  executes, setting  the next  instruction to  the only  acc
+3. It  sets the accumulator  to 5, and jmp  -3 causes the  program to
continue back at the first acc +1.

This is  an infinite loop:  with this  sequence of jumps,  the program
will run forever. The moment the  program tries to run any instruction
a second time, you know it will never terminate.

Immediately before the program would run an instruction a second time,
the value in the accumulator is 5.

Run your copy of the boot  code. Immediately before any instruction is
executed a second time, what value is in the accumulator?

#+begin_src fennel -n :session d2008 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["nop +0"
        "acc +1"
        "jmp +4"
        "acc +3"
        "jmp -3"
        "acc -99"
        "acc +1"
        "jmp -4"
        "acc +6"])

(fn solve [input]
  (var pos 1)
  (var res 0)
  (let [torun (aoc.range-to 1 (length input))]
    (while (lume.find torun pos)
      (aoc.table-remove torun pos)
      (case (aoc.string-split (. input pos) " ")
        ["nop" a] (set pos (+ pos 1))
        ["acc" b] (do
                    (set pos (+ pos 1))
                    (set res (+ res (tonumber b))))
        ["jmp" c] (set pos (+ pos (tonumber c))))))
  res)

(fn test [expected input]
  (assert (= expected (solve input))))

(test 5 test-input)

(solve (aoc.string-from "2020/08.inp"))
#+end_src

#+RESULTS:
: 1614

** DONE Day 8.2

After some careful analysis, you believe that exactly one instruction
is corrupted.

Somewhere in the program, either a jmp is supposed to be a nop, or a
nop is supposed to be a jmp. (No acc instructions were harmed in the
corruption of this boot code.)

The  program is  supposed to  terminate  by attempting  to execute  an
instruction immediately  after the  last instruction  in the  file. By
changing exactly one jmp or nop, you can repair the boot code and make
it terminate correctly.

For example, consider the same program from above:
#+begin_example
nop +0
acc +1
jmp +4
acc +3
jmp -3
acc -99
acc +1
jmp -4
acc +6
#+end_example

If you change  the first instruction from  nop +0 to jmp  +0, it would
create  a   single-instruction  infinite  loop,  never   leaving  that
instruction. If  you change  almost any of  the jmp  instructions, the
program will  still eventually find  another jmp instruction  and loop
forever.

However, if you change the  second-to-last instruction (from jmp -4 to
nop -4), the program terminates!  The instructions are visited in this
order:

#+begin_example
nop +0  | 1
acc +1  | 2
jmp +4  | 3
acc +3  |
jmp -3  |
acc -99 |
acc +1  | 4
nop -4  | 5
acc +6  | 6
#+end_example

After  the  last  instruction  (acc +6),  the  program  terminates  by
attempting to  run the instruction  below the last instruction  in the
file. With this change, after  the program terminates, the accumulator
contains the value 8 (acc +1, acc +1, acc +6).

Fix the program so that it terminates normally by changing exactly one
jmp (to  nop) or nop  (to jmp). What is  the value of  the accumulator
after the program terminates?

#+begin_src fennel -n :session d2008 :exports both
(fn run [input]
  (local len (length input))
  (var pos 1)
  (var res 0)
  (let [torun (aoc.range-to 1 len)]
    (while (lume.find torun pos)
      (aoc.table-remove torun pos)
      (case (aoc.string-split (. input pos) " ")
        ["nop" a] (set pos (+ pos 1))
        ["NOP" A] (set pos (+ pos (tonumber A)))
        ["acc" b] (do
                    (set pos (+ pos 1))
                    (set res (+ res (tonumber b))))
        ["jmp" c] (set pos (+ pos (tonumber c)))
        ["JMP" C] (set pos (+ pos 1)))))
  (if (> pos len)
      res
      -1))

(fn fix-first [input]
  (var done false)
  (each [i v (ipairs input) &until done]
    (case (string.sub v 1 3)
      "jmp" (do (set done true)
                (aoc.table-replace-row input i (.. "JMP" (string.sub v 4))))
      "nop" (do (set done true)
                (aoc.table-replace-row input i (.. "NOP" (string.sub v 4))))))
  input)

(fn fix [input]
  (var found false)
  (var replaced false)
  (each [i v (ipairs input) &until (and found replaced)]
    (case (string.sub v 1 3)
      "JMP" (do (set found true)
                (aoc.table-replace-row input i (.. "jmp" (string.sub v 4))))
      "NOP" (do (set found true)
                (aoc.table-replace-row input i (.. "nop" (string.sub v 4))))
      "jmp" (when found
              (set replaced true)
              (aoc.table-replace-row input i (.. "JMP" (string.sub v 4))))
      "nop" (when found
              (set replaced true)
              (aoc.table-replace-row input i (.. "NOP" (string.sub v 4))))))
  input)

(fn solve2 [input]
  (var fixed (fix-first input))
  (var acc (run fixed))
  (while (< acc 0)
    (set fixed (fix fixed))
    (set acc (run fixed)))
  acc)

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 8 test-input)

(solve2 (aoc.string-from "2020/08.inp"))
#+end_src

#+RESULTS:
: 1260

** DONE Day 9.1

With your  neighbor happily enjoying  their video game, you  turn your
attention to  an open data  port on the little  screen in the  seat in
front of you.

Though the  port is  non-standard, you  manage to  connect it  to your
computer  through   the  clever   use  of  several   paperclips.  Upon
connection, the port outputs a series of numbers (your puzzle input).

The data  appears to be  encrypted with the  eXchange-Masking Addition
System (XMAS)  which, conveniently for you,  is an old cypher  with an
important weakness.

XMAS starts by transmitting a preamble of 25 numbers. After that, each
number you receive should be the sum  of any two of the 25 immediately
previous  numbers. The  two numbers  will have  different values,  and
there might be more than one such pair.

For example, suppose  your preamble consists of the  numbers 1 through
25 in a random order. To be valid,  the next number must be the sum of
two of those numbers:
- 26 would be a  valid next number, as it could be 1  plus 25 (or many
  other pairs, like 2 and 24).
- 49 would be a valid next number, as it is the sum of 24 and 25.
- 100  would not  be valid;  no  two of  the previous  25 numbers  sum
  to 100.
- 50 would also  not be valid; although 25 appears  in the previous 25
  numbers, the two numbers in the pair must be different.
  
Suppose the  26th number  is 45,  and the first  number (no  longer an
option, as it is  more than 25 numbers ago) was 20.  Now, for the next
number to be valid, there needs to be some pair of numbers among 1-19,
21-25, or 45 that add up to it:
- 26 would still be a valid next  number, as 1 and 25 are still within
  the previous 25 numbers.
- 65 would not be valid, as no two of the available numbers sum to it.
- 64 and 66 would  both be valid, as they are the  result of 19+45 and
  21+45 respectively.
  
Here is a  larger example which only considers the  previous 5 numbers
(and has a preamble of length 5):

#+begin_example
35
20
15
25
47
40
62
55
65
95
102
117
150
182
127
219
299
277
309
576
#+end_example

In this example,  after the 5-number preamble, almost  every number is
the sum of  two of the previous  5 numbers; the only  number that does
not follow this rule is 127.

The first step of  attacking the weakness in the XMAS  data is to find
the first number in the list (after the preamble) which is not the sum
of two of the 25 numbers before it. What is the first number that does
not have this property?

#+begin_src fennel -n :session d2009 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["35"
        "20"
        "15"
        "25"
        "47"
        "40"
        "62"
        "55"
        "65"
        "95"
        "102"
        "117"
        "150"
        "182"
        "127"
        "219"
        "299"
        "277"
        "309"
        "576"])

(fn any-two-sum [xs x]
  (if (= 0 (length xs))
      0
      (lume.any (aoc.table-range xs 2 (length xs))
                 (fn [e] (= x (+ e (. xs 1)))))
      x
      (any-two-sum (aoc.table-range xs 2 (length xs)) x)))

(fn solve [input preamble]
  (var done false)
  (let [numbers (lume.map input tonumber)]
    (for [i (+ 1 preamble) (length numbers) &until done]
      (let [xs (aoc.table-range numbers (- i preamble ) (- i 1))
            sum (any-two-sum xs (. numbers i))]
        (when (= 0 sum)
          (set done (. numbers i))))))
  done)

(fn test [expected input]
  (assert (= expected (solve input 5))))

(test 127 test-input)

(solve (aoc.string-from "2020/09.inp") 25)
#+end_src

#+RESULTS:
: 18272118

** DONE Day 9.2

The final step  in breaking the XMAS encryption relies  on the invalid
number you just found: you must find  a contiguous set of at least two
numbers in your list which sum to the invalid number from step 1.

Again consider the above example:

#+begin_example
35
20
15
25
47
40
62
55
65
95
102
117
150
182
127
219
299
277
309
576
#+end_example

In this list, adding up all of the numbers from 15 through 40 produces
the invalid number from step 1, 127. (Of course, the contiguous set of
numbers in your actual list might be much longer.)

To find the encryption weakness, add together the smallest and largest
number in this contiguous range; in this example, these are 15 and 47,
producing 62.

What  is  the  encryption  weakness in  your  XMAS-encrypted  list  of
numbers?

#+begin_src fennel -n :session d2009 :exports both
(fn solve2 [input x]
  (var over false)
  (var res 0)
  (let [xs (lume.map input tonumber)]
    (for [i 1 (- (length xs) 1) &until (< 0 res)]
      (set over false)
      (for [j (+ 1 i) (length xs) &until over]
        (let [sum (aoc.table-sum (aoc.table-range xs i j))]
          (if (< x sum)
              (set over true)
              (= x sum)
              (do (set over true)
                  (set res (+
                            (let [xij (aoc.table-sort (aoc.table-range xs i j))]
                              (+ (. xij 1) (. xij (length xij))))))))))))
  res)

(fn test2 [expected input sum]
  (assert (= expected (solve2 input sum))))

(test2 62 test-input 127)

(solve2 (aoc.string-from "2020/09.inp") 18272118)
#+end_src

#+RESULTS:
: 2186361

** TODO Day 10.1                                                  :noexport:

Patched into the aircraft's data  port, you discover weather forecasts
of a massive tropical storm. Before you can figure out whether it will
impact your vacation plans, however, your device suddenly turns off!

Its battery is dead.

You'll need  to plug  it in.  There's only  one problem:  the charging
outlet  near your  seat produces  the  wrong number  of jolts.  Always
prepared, you make a list of all of the joltage adapters in your bag.

Each of your  joltage adapters is rated for a  specific output joltage
(your puzzle input).  Any given adapter can  take an input 1,  2, or 3
jolts  lower  than its  rating  and  still  produce its  rated  output
joltage.

In addition,  your device has a  built-in joltage adapter rated  for 3
jolts  higher than  the highest-rated  adapter in  your bag.  (If your
adapter list were 3, 9, and 6, your device's built-in adapter would be
rated for 12 jolts.)

Treat  the charging  outlet  near  your seat  as  having an  effective
joltage rating of 0.

Since you have some  time to kill, you might as well  test all of your
adapters. Wouldn't  want to get to  your resort and realize  you can't
even charge your device!

If you use every adapter in your bag at once, what is the distribution
of joltage differences between the  charging outlet, the adapters, and
your device?

For example,  suppose that  in your  bag, you  have adapters  with the
following joltage ratings:
#+begin_example
16
10
15
5
1
11
7
19
6
12
4
#+end_example

With these adapters,  your device's built-in joltage  adapter would be
rated for 19 + 3 = 22 jolts, 3 higher than the highest-rated adapter.

Because adapters can only connect to a source 1-3 jolts lower than its
rating, in order to use every  adapter, you'd need to choose them like
this:
- The charging outlet has an effective rating of 0 jolts, so the only
  adapters that could connect to it directly would need to have a
  joltage rating of 1, 2, or 3 jolts. Of these, only one you have is
  an adapter rated 1 jolt (difference of 1).
- From your 1-jolt rated adapter, the only choice is your 4-jolt rated
  adapter (difference of 3).
- From the 4-jolt rated adapter, the adapters rated 5, 6, or 7 are
  valid choices. However, in order to not skip any adapters, you have
  to pick the adapter rated 5 jolts (difference of 1).
- Similarly, the next choices would need to be the adapter rated 6 and
  then the adapter rated 7 (with difference of 1 and 1).
- The only adapter that works with the 7-jolt rated adapter is the one
  rated 10 jolts (difference of 3).
- From 10, the choices are 11 or 12; choose 11 (difference of 1) and
  then 12 (difference of 1).
- After 12, only valid adapter has a rating of 15 (difference of 3),
  then 16 (difference of 1), then 19 (difference of 3).
- Finally, your device's built-in adapter is always 3 higher than the
  highest adapter, so its rating is 22 jolts (always a difference of
  3).
  
In this example, when using every  adapter, there are 7 differences of
1 jolt and 5 differences of 3 jolts.

Here is a larger example:
#+begin_example
28
33
18
42
31
14
46
20
48
47
24
23
49
45
19
38
39
11
1
32
25
35
8
17
7
9
4
2
34
10
3
#+end_example

In this  larger example,  in a  chain that uses  all of  the adapters,
there are 22 differences of 1 jolt and 10 differences of 3 jolts.

Find a  chain that uses all  of your adapters to  connect the charging
outlet  to  your  device's  built-in adapter  and  count  the  joltage
differences  between  the  charging  outlet, the  adapters,  and  your
device. What  is the  number of 1-jolt  differences multiplied  by the
number of 3-jolt differences?
** TODO Day 10.2                                                  :noexport:

** TODO Day 11.1                                                  :noexport:

Your plane lands with  plenty of time to spare. The  final leg of your
journey is a ferry that goes directly to the tropical island where you
can finally  start your  vacation. As  you reach  the waiting  area to
board the  ferry, you realize  you're so  early, nobody else  has even
arrived yet!

By modeling the  process people use to choose (or  abandon) their seat
in the waiting area, you're pretty sure you can predict the best place
to sit. You make a quick map of the seat layout (your puzzle input).

The seat layout  fits neatly on a grid. Each  position is either floor
(.), an  empty seat  (L), or  an occupied seat  (#). For  example, the
initial seat layout might look like this:
#+begin_example
L.LL.LL.LL
LLLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLLL
L.LLLLLL.L
L.LLLLL.LL
#+end_example

Now,  you  just  need  to  model  the  people  who  will  be  arriving
shortly.  Fortunately,  people  are entirely  predictable  and  always
follow a simple set of rules. All decisions are based on the number of
occupied seats  adjacent to a given  seat (one of the  eight positions
immediately up,  down, left,  right, or diagonal  from the  seat). The
following rules are applied to every seat simultaneously:
- If a seat is empty (L) and there are no occupied seats adjacent to
  it, the seat becomes occupied.
- If a seat is occupied (#) and four or more seats adjacent to it are
  also occupied, the seat becomes empty.
- Otherwise, the seat's state does not change.

Floor (.) never changes; seats don't move, and nobody sits on the floor.

After  one round  of these  rules, every  seat in  the example  layout
becomes occupied:
#+begin_example
#.##.##.##
#######.##
#.#.#..#..
####.##.##
#.##.##.##
#.#####.##
..#.#.....
##########
#.######.#
#.#####.##
#+end_example

After a  second round, the seats  with four or more  occupied adjacent
seats become empty again:
#+begin_example
#.LL.L#.##
#LLLLLL.L#
L.L.L..L..
#LLL.LL.L#
#.LL.LL.LL
#.LLLL#.##
..L.L.....
#LLLLLLLL#
#.LLLLLL.L
#.#LLLL.##
#+end_example

This process continues for three more rounds:
#+begin_example
#.##.L#.##
#L###LL.L#
L.#.#..#..
#L##.##.L#
#.##.LL.LL
#.###L#.##
..#.#.....
#L######L#
#.LL###L.L
#.#L###.##

#.#L.L#.##
#LLL#LL.L#
L.L.L..#..
#LLL.##.L#
#.LL.LL.LL
#.LL#L#.##
..L.L.....
#L#LLLL#L#
#.LLLLLL.L
#.#L#L#.##

#.#L.L#.##
#LLL#LL.L#
L.#.L..#..
#L##.##.L#
#.#L.LL.LL
#.#L#L#.##
..L.L.....
#L#L##L#L#
#.LLLLLL.L
#.#L#L#.##
#+end_example

At this point, something interesting happens: the chaos stabilizes and
further applications  of these rules  cause no seats to  change state!
Once people stop moving around, you count 37 occupied seats.

Simulate your  seating area by  applying the seating  rules repeatedly
until no seats change state. How many seats end up occupied?
** TODO Day 11.2                                                  :noexport:

** TODO Day 12.1                                                  :noexport:

Your ferry made decent progress toward  the island, but the storm came
in  faster than  anyone  expected.  The ferry  needs  to take  evasive
actions!

Unfortunately,   the   ship's   navigation  computer   seems   to   be
malfunctioning;  rather than  giving a  route directly  to safety,  it
produced extremely circuitous instructions.  When the captain uses the
PA system to ask if anyone can help, you quickly volunteer.

The navigation instructions (your puzzle input) consists of a sequence
of single-character  actions paired  with integer input  values. After
staring at  them for a  few minutes, you  work out what  they probably
mean:
- Action N means to move north by the given value.
- Action S means to move south by the given value.
- Action E means to move east by the given value.
- Action W means to move west by the given value.
- Action L means to turn left the given number of degrees.
- Action R means to turn right the given number of degrees.
- Action F means to move forward by the given value in the direction
  the ship is currently facing.
  
The ship starts  by facing east. Only  the L and R  actions change the
direction the ship is facing. (That is, if the ship is facing east and
the next instruction  is N10, the ship would move  north 10 units, but
would still move east if the following action were F.)

For example:
#+begin_example
F10
N3
F7
R90
F11
#+end_example

These instructions would be handled as follows:
- F10 would move the ship 10 units east (because the ship starts by
  facing east) to east 10, north 0.
- N3 would move the ship 3 units north to east 10, north 3.
- F7 would move the ship another 7 units east (because the ship is
  still facing east) to east 17, north 3.
- R90 would cause the ship to turn right by 90 degrees and face south;
  it remains at east 17, north 3.
- F11 would move the ship 11 units south to east 17, south 8.

At the end  of these instructions, the ship's  Manhattan distance (sum
of the absolute  values of its east/west position  and its north/south
position) from its starting position is 17 + 8 = 25.

Figure  out  where  the  navigation instructions  lead.  What  is  the
Manhattan  distance  between that  location  and  the ship's  starting
position?
** TODO Day 12.2                                                  :noexport:

** TODO Day 13.1                                                  :noexport:

Your ferry can make it safely to  a nearby port, but it won't get much
further. When  you call  to book  another ship,  you discover  that no
ships embark  from that port to  your vacation island. You'll  need to
get from the port to the nearest airport.

Fortunately, a shuttle bus service is  available to bring you from the
sea port to the airport! Each bus has an ID number that also indicates
how often the bus leaves for the airport.

Bus  schedules are  defined based  on  a timestamp  that measures  the
number of  minutes since some  fixed reference  point in the  past. At
timestamp  0,   every  bus   simultaneously  departed  from   the  sea
port. After that, each bus travels  to the airport, then various other
locations, and finally  returns to the sea port to  repeat its journey
forever.

The time this loop  takes a particular bus is also  its ID number: the
bus with ID  5 departs from the  sea port at timestamps 0,  5, 10, 15,
and so on. The bus with ID 11 departs  at 0, 11, 22, 33, and so on. If
you are  there when  the bus  departs, you  can ride  that bus  to the
airport!

Your notes (your puzzle input) consist of two lines. The first line is
your estimate of the earliest timestamp you could depart on a bus. The
second line  lists the bus  IDs that are  in service according  to the
shuttle company;  entries that show x  must be out of  service, so you
decide to ignore them.

To save time once you arrive, your  goal is to figure out the earliest
bus you can take to the airport. (There will be exactly one such bus.)

For example, suppose you have the following notes:
#+begin_example
939
7,13,x,x,59,x,31,19
#+end_example

Here, the earliest timestamp you could  depart is 939, and the bus IDs
in service are  7, 13, 59, 31,  and 19. Near timestamp  939, these bus
IDs depart at the times marked D:
#+begin_example
time   bus 7   bus 13  bus 59  bus 31  bus 19
929      .       .       .       .       .
930      .       .       .       D       .
931      D       .       .       .       D
932      .       .       .       .       .
933      .       .       .       .       .
934      .       .       .       .       .
935      .       .       .       .       .
936      .       D       .       .       .
937      .       .       .       .       .
938      D       .       .       .       .
939      .       .       .       .       .
940      .       .       .       .       .
941      .       .       .       .       .
942      .       .       .       .       .
943      .       .       .       .       .
944      .       .       D       .       .
945      D       .       .       .       .
946      .       .       .       .       .
947      .       .       .       .       .
948      .       .       .       .       .
949      .       D       .       .       .
#+end_example

The earliest bus you could take is  bus ID 59. It doesn't depart until
timestamp 944, so you would need to  wait 944 - 939 = 5 minutes before
it departs. Multiplying the bus ID by the number of minutes you'd need
to wait gives 295.

What  is the  ID of  the  earliest bus  you  can take  to the  airport
multiplied by the number of minutes you'll need to wait for that bus?
** TODO Day 13.2                                                  :noexport:

** TODO Day 14.1                                                  :noexport:

As your ferry approaches the sea  port, the captain asks for your help
again. The computer  system that runs this port  isn't compatible with
the docking  program on  the ferry, so  the docking  parameters aren't
being correctly initialized in the docking program's memory.

After a  brief inspection, you  discover that the sea  port's computer
system   uses  a   strange  bitmask   system  in   its  initialization
program. Although you  don't have the correct decoder  chip handy, you
can emulate it in software!

The initialization program  (your puzzle input) can  either update the
bitmask or  write a value to  memory. Values and memory  addresses are
both 36-bit  unsigned integers. For  example, ignoring bitmasks  for a
moment, a  line like mem[8]  = 11 would write  the value 11  to memory
address 8.

The bitmask is always  given as a string of 36  bits, written with the
most significant  bit (representing  2^35) on the  left and  the least
significant bit (2^0,  that is, the 1s bit) on  the right. The current
bitmask is  applied to values  immediately before they are  written to
memory: a 0 or 1 overwrites  the corresponding bit in the value, while
an X leaves the bit in the value unchanged.

For example, consider the following program:
#+begin_example
mask = XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
mem[8] = 11
mem[7] = 101
mem[8] = 0
#+end_example

This program starts by specifying a bitmask (mask = ....). The mask it
specifies will overwrite  two bits in every written value:  the 2s bit
is overwritten with 0, and the 64s bit is overwritten with 1.

The  program   then  attempts  to   write  the  value  11   to  memory
address 8. By expanding everything out to individual bits, the mask is
applied as follows:
#+begin_example
value:  000000000000000000000000000000001011  (decimal 11)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 000000000000000000000000000001001001  (decimal 73)
#+end_example

So, because of the  mask, the value 73 is written  to memory address 8
instead. Then, the program tries to write 101 to address 7:
#+begin_example
value:  000000000000000000000000000001100101  (decimal 101)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 000000000000000000000000000001100101  (decimal 101)
#+end_example

This  time, the  mask has  no effect,  as the  bits it  overwrote were
already the values  the mask tried to set. Finally,  the program tries
to write 0 to address 8:
#+begin_example
value:  000000000000000000000000000000000000  (decimal 0)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 000000000000000000000000000001000000  (decimal 64)
#+end_example

64 is  written to address  8 instead,  overwriting the value  that was
there previously.

To initialize  your ferry's docking program,  you need the sum  of all
values left in memory after the initialization program completes. (The
entire 36-bit address space begins initialized to the value 0 at every
address.) In  the above  example, only  two values  in memory  are not
zero -  101 (at address  7) and  64 (at address  8) - producing  a sum
of 165.

Execute the initialization program. What is the sum of all values left
in memory after it completes? (Do not truncate the sum to 36 bits.)
** TODO Day 14.2                                                  :noexport:

** TODO Day 15.1                                                  :noexport:

You catch  the airport shuttle  and try to book  a new flight  to your
vacation  island. Due  to  the  storm, all  direct  flights have  been
cancelled, but a route is available  to get around the storm. You take
it.

While you wait for your flight, you  decide to check in with the Elves
back at the North Pole. They're playing  a memory game and are ever so
excited to explain the rules!

In this  game, the players  take turns  saying numbers. They  begin by
taking  turns reading  from a  list of  starting numbers  (your puzzle
input).  Then, each  turn consists  of considering  the most  recently
spoken number:
- If that was the first time the number has been spoken, the current
  player says 0.
- Otherwise, the number had been spoken before; the current player
  announces how many turns apart the number is from when it was
  previously spoken.
  
So,  after the  starting numbers,  each  turn results  in that  player
speaking aloud either 0 (if the last  number is new) or an age (if the
last number is a repeat).

For example, suppose the starting numbers are 0,3,6:
- Turn 1: The 1st number spoken is a starting number, 0.
- Turn 2: The 2nd number spoken is a starting number, 3.
- Turn 3: The 3rd number spoken is a starting number, 6.
- Turn 4: Now, consider the last number spoken, 6. Since that was the
  first time the number had been spoken, the 4th number spoken is 0.
- Turn 5: Next, again consider the last number spoken, 0. Since it had
  been spoken before, the next number to speak is the difference
  between the turn number when it was last spoken (the previous
  turn, 4) and the turn number of the time it was most recently spoken
  before then (turn 1). Thus, the 5th number spoken is 4 - 1, 3.
- Turn 6: The last number spoken, 3 had also been spoken before, most
  recently on turns 5 and 2. So, the 6th number spoken is 5 - 2, 3.
- Turn 7: Since 3 was just spoken twice in a row, and the last two
  turns are 1 turn apart, the 7th number spoken is 1.
- Turn 8: Since 1 is new, the 8th number spoken is 0.
- Turn 9: 0 was last spoken on turns 8 and 4, so the 9th number spoken
  is the difference between them, 4.
- Turn 10: 4 is new, so the 10th number spoken is 0.

(The game ends when the Elves get  sick of playing or dinner is ready,
whichever comes first.)

Their question for  you is: what will be the  2020th number spoken? In
the example above, the 2020th number spoken will be 436.

Here are a few more examples:
- Given the starting numbers 1,3,2, the 2020th number spoken is 1.
- Given the starting numbers 2,1,3, the 2020th number spoken is 10.
- Given the starting numbers 1,2,3, the 2020th number spoken is 27.
- Given the starting numbers 2,3,1, the 2020th number spoken is 78.
- Given the starting numbers 3,2,1, the 2020th number spoken is 438.
- Given the starting numbers 3,1,2, the 2020th number spoken is 1836.

Given your starting numbers, what will be the 2020th number spoken?
** TODO Day 15.2                                                  :noexport:

** TODO Day 16.1                                                  :noexport:

As you're walking  to yet another connecting flight,  you realize that
one of the  legs of your re-routed  trip coming up is  on a high-speed
train. However, the  train ticket you were given is  in a language you
don't understand. You  should probably figure out what  it says before
you get to the train station after the next flight.

Unfortunately, you  can't actually read  the words on the  ticket. You
can, however, read the numbers, and so you figure out the fields these
tickets must have and the valid ranges for values in those fields.

You collect the  rules for ticket fields, the numbers  on your ticket,
and the  numbers on other  nearby tickets  for the same  train service
(via the airport security cameras) together into a single document you
can reference (your puzzle input).

The  rules for  ticket  fields specify  a list  of  fields that  exist
somewhere  on the  ticket  and the  valid ranges  of  values for  each
field. For example,  a rule like class:  1-3 or 5-7 means  that one of
the fields in every ticket is named  class and can be any value in the
ranges 1-3 or 5-7 (inclusive, such that 3 and 5 are both valid in this
field, but 4 is not).

Each  ticket  is  represented  by a  single  line  of  comma-separated
values. The  values are the  numbers on the  ticket in the  order they
appear; every ticket  has the same format. For  example, consider this
ticket:
#+begin_example
.--------------------------------------------------------.
| ????: 101    ?????: 102   ??????????: 103     ???: 104 |
|                                                        |
| ??: 301  ??: 302             ???????: 303      ??????? |
| ??: 401  ??: 402           ???? ????: 403    ????????? |
'--------------------------------------------------------'
#+end_example

Here,  ? represents  text in  a  language you  don't understand.  This
ticket           might           be           represented           as
101,102,103,104,301,302,303,401,402,403; of  course, the  actual train
tickets  you're looking  at are  much more  complicated. In  any case,
you've extracted just the numbers in  such a way that the first number
is  always the  same specific  field, the  second number  is always  a
different specific  field, and so on  - you just don't  know what each
position actually means!

Start by determining  which tickets are completely  invalid; these are
tickets that contain  values which aren't valid for  any field. Ignore
your ticket for now.

For example, suppose you have the following notes:
#+begin_example
class: 1-3 or 5-7
row: 6-11 or 33-44
seat: 13-40 or 45-50

your ticket:
7,1,14

nearby tickets:
7,3,47
40,4,50
55,2,20
38,6,12
#+end_example

It doesn't matter  which position corresponds to which  field; you can
identify invalid  nearby tickets  by considering only  whether tickets
contain values that are not valid  for any field. In this example, the
values  on the  first nearby  ticket are  all valid  for at  least one
field. This is not true of  the other three nearby tickets: the values
4, 55, and 12 are are not  valid for any field. Adding together all of
the invalid values produces your ticket  scanning error rate: 4 + 55 +
12 = 71.

Consider the validity of the nearby  tickets you scanned. What is your
ticket scanning error rate?
** TODO Day 16.2                                                  :noexport:

** TODO Day 17.1                                                  :noexport:

As  your flight  slowly  drifts  through the  sky,  the  Elves at  the
Mythical Information Bureau at the North Pole contact you. They'd like
some help debugging a malfunctioning experimental energy source aboard
one of their super-secret imaging satellites.

The experimental energy source is  based on cutting-edge technology: a
set of  Conway Cubes contained  in a  pocket dimension! When  you hear
it's having problems, you can't help but agree to take a look.

The pocket dimension contains an infinite 3-dimensional grid. At every
integer 3-dimensional  coordinate (x,y,z), there exists  a single cube
which is either active or inactive.

In the initial  state of the pocket dimension, almost  all cubes start
inactive. The only  exception to this is a small  flat region of cubes
(your puzzle input);  the cubes in this region start  in the specified
active (#) or inactive (.) state.

The energy source then proceeds to boot up by executing six cycles.

Each cube only ever considers its neighbors: any of the 26 other cubes
where any of their coordinates differ by at most 1. For example, given
the  cube   at  x=1,y=2,z=3,  its   neighbors  include  the   cube  at
x=2,y=2,z=2, the cube at x=0,y=2,z=3, and so on.

During a cycle, all cubes  simultaneously change their state according
to the following rules:
- If a cube is active and exactly 2 or 3 of its neighbors are also
  active, the cube remains active. Otherwise, the cube becomes
  inactive.
- If a cube is inactive but exactly 3 of its neighbors are active, the
  cube becomes active. Otherwise, the cube remains inactive.
  
The engineers  responsible for  this experimental energy  source would
like  you to  simulate the  pocket  dimension and  determine what  the
configuration of  cubes should  be at  the end  of the  six-cycle boot
process.

For example, consider the following initial state:
#+begin_example
.#.
..#
###
#+end_example

Even though the pocket dimension  is 3-dimensional, this initial state
represents a  small 2-dimensional  slice of  it. (In  particular, this
initial state defines a 3x3x1 region of the 3-dimensional space.)

Simulating a few cycles from this initial state produces the following
configurations, where the result of each cycle is shown layer-by-layer
at each given  z coordinate (and the frame of  view follows the active
cells in each cycle):

Before any cycles:
#+begin_example
z=0
.#.
..#
###
#+end_example


After 1 cycle:
#+begin_example
z=-1
#..
..#
.#.

z=0
#.#
.##
.#.

z=1
#..
..#
.#.
#+end_example


After 2 cycles:
#+begin_example
z=-2
.....
.....
..#..
.....
.....

z=-1
..#..
.#..#
....#
.#...
.....

z=0
##...
##...
#....
....#
.###.

z=1
..#..
.#..#
....#
.#...
.....

z=2
.....
.....
..#..
.....
.....
#+end_example


After 3 cycles:
#+begin_example
z=-2
.......
.......
..##...
..###..
.......
.......
.......

z=-1
..#....
...#...
#......
.....##
.#...#.
..#.#..
...#...

z=0
...#...
.......
#......
.......
.....##
.##.#..
...#...

z=1
..#....
...#...
#......
.....##
.#...#.
..#.#..
...#...

z=2
.......
.......
..##...
..###..
.......
.......
.......
#+end_example

After the full six-cycle boot process completes, 112 cubes are left in
the active state.

Starting  with   your  given   initial  configuration,   simulate  six
cycles. How  many cubes are left  in the active state  after the sixth
cycle?
** TODO Day 17.2                                                  :noexport:

** TODO Day 18.1                                                  :noexport:

As you  look out  the window and  notice a  heavily-forested continent
slowly  appear over  the horizon,  you  are interrupted  by the  child
sitting next to you. They're curious if you could help them with their
math homework.

Unfortunately, it seems like this  "math" follows different rules than
you remember.

The homework (your  puzzle input) consists of a  series of expressions
that  consist of  addition  (+), multiplication  (*), and  parentheses
((...)).  Just  like  normal   math,  parentheses  indicate  that  the
expression  inside must  be evaluated  before it  can be  used by  the
surrounding expression. Addition still finds the sum of the numbers on
both  sides  of  the  operator, and  multiplication  still  finds  the
product.

However, the  rules of operator  precedence have changed.  Rather than
evaluating multiplication before addition, the operators have the same
precedence, and are evaluated left-to-right regardless of the order in
which they appear.

For example, the steps to evaluate the expression 1  + 2 * 3 + 4 * 5 +
6 are as follows:
#+begin_example
1 + 2 * 3 + 4 * 5 + 6
  3   * 3 + 4 * 5 + 6
      9   + 4 * 5 + 6
         13   * 5 + 6
             65   + 6
                 71
#+end_example

Parentheses can override this order; for example, here is what happens
if parentheses are added to form 1 + (2 * 3) + (4 * (5 + 6)):
#+begin_example
1 + (2 * 3) + (4 * (5 + 6))
1 +    6    + (4 * (5 + 6))
     7      + (4 * (5 + 6))
     7      + (4 *   11   )
     7      +     44
            51
#+end_example

Here are a few more examples:
#+begin_example
    2 * 3 + (4 * 5) becomes 26.
    5 + (8 * 3 + 9 + 3 * 4 * 3) becomes 437.
    5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4)) becomes 12240.
    ((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2 becomes 13632.
#+end_example

Before  you can  help with  the homework,  you need  to understand  it
yourself. Evaluate the  expression on each line of  the homework; what
is the sum of the resulting values?
** TODO Day 18.2                                                  :noexport:

** TODO Day 19.1                                                  :noexport:

You land in an airport surrounded by dense forest. As you walk to your
high-speed train, the Elves at the Mythical Information Bureau contact
you again. They think their satellite  has collected an image of a sea
monster!  Unfortunately, the  connection  to the  satellite is  having
problems, and many  of the messages sent back from  the satellite have
been corrupted.

They sent  you a list  of the rules valid  messages should obey  and a
list  of  received messages  they've  collected  so far  (your  puzzle
input).

The rules for  valid messages (the top part of  your puzzle input) are
numbered and build upon each other. For example:
#+begin_example
0: 1 2
1: "a"
2: 1 3 | 3 1
3: "b"
#+end_example

Some rules,  like 3:  "b", simply  match a  single character  (in this
case, b).

The  remaining rules  list the  sub-rules that  must be  followed; for
example, the rule  0: 1 2 means  that to match rule 0,  the text being
checked must  match rule 1, and  the text after the  part that matched
rule 1 must then match rule 2.

Some of the rules have multiple lists of sub-rules separated by a pipe
(|). This means  that at least one list of  sub-rules must match. (The
ones that match might be different each time the rule is encountered.)
For example,  the rule 2: 1  3 | 3 1  means that to match  rule 2, the
text being  checked must match  rule 1 followed by  rule 3 or  it must
match rule 3 followed by rule 1.

Fortunately, there are no loops in  the rules, so the list of possible
matches will be finite.  Since rule 1 matches a and  rule 3 matches b,
rule 2 matches either ab or ba. Therefore, rule 0 matches aab or aba.

Here's a more interesting example:
#+begin_example
0: 4 1 5
1: 2 3 | 3 2
2: 4 4 | 5 5
3: 4 5 | 5 4
4: "a"
5: "b"
#+end_example

Here, because rule  4 matches a and  rule 5 matches b,  rule 2 matches
two letters  that are  the same  (aa or  bb), and  rule 3  matches two
letters that are different (ab or ba).

Since rule 1 matches rules 2 and  3 once each in either order, it must
match two  pairs of letters,  one pair  with matching letters  and one
pair with  different letters.  This leaves eight  possibilities: aaab,
aaba, bbab, bbba, abaa, abbb, baaa, or babb.

Rule 0, therefore,  matches a (rule 4), then any  of the eight options
from rule 1, then b (rule  5): aaaabb, aaabab, abbabb, abbbab, aabaab,
aabbbb, abaaab, or ababbb.

The received messages  (the bottom part of your puzzle  input) need to
be checked against the rules so  you can determine which are valid and
which are  corrupted. Including the  rules and the  messages together,
this might look like:
#+begin_example
0: 4 1 5
1: 2 3 | 3 2
2: 4 4 | 5 5
3: 4 5 | 5 4
4: "a"
5: "b"

ababbb
bababa
abbbab
aaabbb
aaaabbb
#+end_example

Your goal is to determine the number of messages that completely match
rule 0.  In the above  example, ababbb  and abbbab match,  but bababa,
aaabbb, and aaaabbb do not, producing  the answer 2. The whole message
must match all of rule 0; there can't be extra unmatched characters in
the message. (For example, aaaabbb might appear to match rule 0 above,
but it has an extra unmatched b on the end.)

How many messages completely match rule 0?
** TODO Day 19.2                                                  :noexport:

** TODO Day 20.1                                                  :noexport:

The  high-speed  train  leaves  the forest  and  quickly  carries  you
south. You can even see a desert  in the distance! Since you have some
spare time, you might as well see if there was anything interesting in
the image the Mythical Information Bureau satellite captured.

After  decoding the  satellite messages,  you discover  that the  data
actually contains many small images  created by the satellite's camera
array. The camera array consists  of many cameras; rather than produce
a single  square image, they  produce many smaller square  image tiles
that need to be reassembled back into a single image.

Each camera in the camera array returns a single monochrome image tile
with a random unique ID number.  The tiles (your puzzle input) arrived
in a random order.

Worse yet, the  camera array appears to be  malfunctioning: each image
tile has been rotated and flipped  to a random orientation. Your first
task is  to reassemble the  original image  by orienting the  tiles so
they fit together.

To show  how the tiles should  be reassembled, each tile's  image data
includes  a border  that  should  line up  exactly  with its  adjacent
tiles. All  tiles have this  border, and  the border lines  up exactly
when the tiles  are both oriented correctly. Tiles at  the edge of the
image also  have this border,  but the  outermost edges won't  line up
with any other tiles.

For example, suppose you have the following nine tiles:
#+begin_example
Tile 2311:
..##.#..#.
##..#.....
#...##..#.
####.#...#
##.##.###.
##...#.###
.#.#.#..##
..#....#..
###...#.#.
..###..###

Tile 1951:
#.##...##.
#.####...#
.....#..##
#...######
.##.#....#
.###.#####
###.##.##.
.###....#.
..#.#..#.#
#...##.#..

Tile 1171:
####...##.
#..##.#..#
##.#..#.#.
.###.####.
..###.####
.##....##.
.#...####.
#.##.####.
####..#...
.....##...

Tile 1427:
###.##.#..
.#..#.##..
.#.##.#..#
#.#.#.##.#
....#...##
...##..##.
...#.#####
.#.####.#.
..#..###.#
..##.#..#.

Tile 1489:
##.#.#....
..##...#..
.##..##...
..#...#...
#####...#.
#..#.#.#.#
...#.#.#..
##.#...##.
..##.##.##
###.##.#..

Tile 2473:
#....####.
#..#.##...
#.##..#...
######.#.#
.#...#.#.#
.#########
.###.#..#.
########.#
##...##.#.
..###.#.#.

Tile 2971:
..#.#....#
#...###...
#.#.###...
##.##..#..
.#####..##
.#..####.#
#..#.#..#.
..####.###
..#.#.###.
...#.#.#.#

Tile 2729:
...#.#.#.#
####.#....
..#.#.....
....#..#.#
.##..##.#.
.#.####...
####.#.#..
##.####...
##..#.##..
#.##...##.

Tile 3079:
#.#.#####.
.#..######
..#.......
######....
####.#..#.
.#...#.##.
#.#####.##
..#.###...
..#.......
..#.###...
#+end_example


By rotating,  flipping, and  rearranging them, you  can find  a square
arrangement that causes all adjacent borders to line up:
#+begin_example
#...##.#.. ..###..### #.#.#####.
..#.#..#.# ###...#.#. .#..######
.###....#. ..#....#.. ..#.......
###.##.##. .#.#.#..## ######....
.###.##### ##...#.### ####.#..#.
.##.#....# ##.##.###. .#...#.##.
#...###### ####.#...# #.#####.##
.....#..## #...##..#. ..#.###...
#.####...# ##..#..... ..#.......
#.##...##. ..##.#..#. ..#.###...

#.##...##. ..##.#..#. ..#.###...
##..#.##.. ..#..###.# ##.##....#
##.####... .#.####.#. ..#.###..#
####.#.#.. ...#.##### ###.#..###
.#.####... ...##..##. .######.##
.##..##.#. ....#...## #.#.#.#...
....#..#.# #.#.#.##.# #.###.###.
..#.#..... .#.##.#..# #.###.##..
####.#.... .#..#.##.. .######...
...#.#.#.# ###.##.#.. .##...####

...#.#.#.# ###.##.#.. .##...####
..#.#.###. ..##.##.## #..#.##..#
..####.### ##.#...##. .#.#..#.##
#..#.#..#. ...#.#.#.. .####.###.
.#..####.# #..#.#.#.# ####.###..
.#####..## #####...#. .##....##.
##.##..#.. ..#...#... .####...#.
#.#.###... .##..##... .####.##.#
#...###... ..##...#.. ...#..####
..#.#....# ##.#.#.... ...##.....
#+end_example

For reference, the IDs of the above tiles are:
#+begin_example
1951    2311    3079
2729    1427    2473
2971    1489    1171
#+end_example

To check that  you've assembled the image correctly,  multiply the IDs
of the four  corner tiles together. If you do  this with the assembled
tiles  from the  example above,  you get  1951 *  3079 *  2971 *  1171
= 20899048083289.

Assemble the  tiles into  an image.  What do you  get if  you multiply
together the IDs of the four corner tiles?
** TODO Day 20.2                                                  :noexport:

** TODO Day 21.1                                                  :noexport:

You reach the  train's last stop and  the closest you can  get to your
vacation island without getting wet. There aren't even any boats here,
but nothing can  stop you now: you  build a raft. You just  need a few
days' worth of food for your journey.

You don't speak the local language,  so you can't read any ingredients
lists. However, sometimes,  allergens are listed in a  language you do
understand. You  should be able  to use this information  to determine
which ingredient contains which allergen  and work out which foods are
safe to take with you on your trip.

You start by  compiling a list of foods (your  puzzle input), one food
per line. Each line includes  that food's ingredients list followed by
some or all of the allergens the food contains.

Each  allergen is  found in  exactly one  ingredient. Each  ingredient
contains zero  or one allergen.  Allergens aren't always  marked; when
they're listed (as in (contains  nuts, shellfish) after an ingredients
list),  the ingredient  that  contains each  listed  allergen will  be
somewhere in the  corresponding ingredients list. However,  even if an
allergen  isn't listed,  the  ingredient that  contains that  allergen
could still be present: maybe they forgot to label it, or maybe it was
labeled in a language you don't know.

For example, consider the following list of foods:
#+begin_example
mxmxvkd kfcds sqjhc nhms (contains dairy, fish)
trh fvjkl sbzzf mxmxvkd (contains dairy)
sqjhc fvjkl (contains soy)
sqjhc mxmxvkd sbzzf (contains fish)
#+end_example

The first food in the list has four ingredients (written in a language
you don't understand): mxmxvkd, kfcds, sqjhc, and nhms. While the food
might contain  other allergens,  a few  allergens the  food definitely
contains are listed afterward: dairy and fish.

The  first  step is  to  determine  which ingredients  can't  possibly
contain any of  the allergens in any  food in your list.  In the above
example,  none of  the  ingredients  kfcds, nhms,  sbzzf,  or trh  can
contain  an  allergen. Counting  the  number  of  times any  of  these
ingredients appear in any ingredients list produces 5: they all appear
once each except sbzzf, which appears twice.

Determine  which  ingredients  cannot  possibly  contain  any  of  the
allergens in  your list. How  many times  do any of  those ingredients
appear?
** TODO Day 21.2                                                  :noexport:

** TODO Day 22.1                                                  :noexport:

It only takes a  few hours of sailing the ocean on  a raft for boredom
to sink  in. Fortunately,  you brought  a small  deck of  space cards!
You'd like  to play  a game  of Combat, and  there's even  an opponent
available: a small crab that climbed aboard your raft before you left.

Fortunately, it doesn't take long to teach the crab the rules.

Before the game  starts, split the cards so each  player has their own
deck  (your puzzle  input). Then,  the game  consists of  a series  of
rounds: both  players draw  their top  card, and  the player  with the
higher-valued  card  wins the  round.  The  winner keeps  both  cards,
placing them on the bottom of their own deck so that the winner's card
is above the  other card. If this  causes a player to have  all of the
cards, they win, and the game ends.

For example, consider the following starting decks:
#+begin_example
Player 1:
9
2
6
3
1

Player 2:
5
8
4
7
10
#+end_example

This arrangement means  that player 1's deck contains 5  cards, with 9
on top  and 1 on  the bottom; player 2's  deck also contains  5 cards,
with 5 on top and 10 on the bottom.

The first round begins with both players drawing the top card of their
decks: 9 and  5. Player 1 has  the higher card, so both  cards move to
the bottom  of player 1's deck  such that 9  is above 5. In  total, it
takes 29 rounds before a player has all of the cards:
#+begin_example
-- Round 1 --
Player 1's deck: 9, 2, 6, 3, 1
Player 2's deck: 5, 8, 4, 7, 10
Player 1 plays: 9
Player 2 plays: 5
Player 1 wins the round!

-- Round 2 --
Player 1's deck: 2, 6, 3, 1, 9, 5
Player 2's deck: 8, 4, 7, 10
Player 1 plays: 2
Player 2 plays: 8
Player 2 wins the round!

-- Round 3 --
Player 1's deck: 6, 3, 1, 9, 5
Player 2's deck: 4, 7, 10, 8, 2
Player 1 plays: 6
Player 2 plays: 4
Player 1 wins the round!

-- Round 4 --
Player 1's deck: 3, 1, 9, 5, 6, 4
Player 2's deck: 7, 10, 8, 2
Player 1 plays: 3
Player 2 plays: 7
Player 2 wins the round!

-- Round 5 --
Player 1's deck: 1, 9, 5, 6, 4
Player 2's deck: 10, 8, 2, 7, 3
Player 1 plays: 1
Player 2 plays: 10
Player 2 wins the round!
#+end_example

...several more rounds pass...
#+begin_example
-- Round 27 --
Player 1's deck: 5, 4, 1
Player 2's deck: 8, 9, 7, 3, 2, 10, 6
Player 1 plays: 5
Player 2 plays: 8
Player 2 wins the round!

-- Round 28 --
Player 1's deck: 4, 1
Player 2's deck: 9, 7, 3, 2, 10, 6, 8, 5
Player 1 plays: 4
Player 2 plays: 9
Player 2 wins the round!

-- Round 29 --
Player 1's deck: 1
Player 2's deck: 7, 3, 2, 10, 6, 8, 5, 9, 4
Player 1 plays: 1
Player 2 plays: 7
Player 2 wins the round!


== Post-game results ==
Player 1's deck: 
Player 2's deck: 3, 2, 10, 6, 8, 5, 9, 4, 7, 1
#+end_example

Once the game ends, you can  calculate the winning player's score. The
bottom card in their deck is worth the value of the card multiplied by
1,  the second-from-the-bottom  card is  worth the  value of  the card
multiplied by 2, and  so on. With 10 cards, the top  card is worth the
value  on the  card multiplied  by 10.  In this  example, the  winning
player's score is:
#+begin_example
   3 * 10
+  2 *  9
+ 10 *  8
+  6 *  7
+  8 *  6
+  5 *  5
+  9 *  4
+  4 *  3
+  7 *  2
+  1 *  1
= 306
#+end_example

So, once the game ends, the winning player's score is 306.

Play the small crab  in a game of Combat using the  two decks you just
dealt. What is the winning player's score?
** TODO Day 22.2                                                  :noexport:

** TODO Day 23.1                                                  :noexport:

The small crab challenges  you to a game! The crab is  going to mix up
some cups, and you have to predict where they'll end up.

The cups  will be  arranged in  a circle  and labeled  clockwise (your
puzzle input). For  example, if your labeling were  32415, there would
be five cups in the circle; going clockwise around the circle from the
first cup, the cups would be labeled 3, 2, 4, 1, 5, and then back to 3
again.

Before the crab  starts, it will designate the first  cup in your list
as the current cup. The crab is then going to do 100 moves.

Each move, the crab does the following actions:
- The crab picks up the three cups that are immediately clockwise of
  the current cup. They are removed from the circle; cup spacing is
  adjusted as necessary to maintain the circle.
- The crab selects a destination cup: the cup with a label equal to
  the current cup's label minus one. If this would select one of the
  cups that was just picked up, the crab will keep subtracting one
  until it finds a cup that wasn't just picked up. If at any point in
  this process the value goes below the lowest value on any cup's
  label, it wraps around to the highest value on any cup's label
  instead.
- The crab places the cups it just picked up so that they are
  immediately clockwise of the destination cup. They keep the same
  order as when they were picked up.
- The crab selects a new current cup: the cup which is immediately
  clockwise of the current cup.
  
For example,  suppose your  cup labeling were  389125467. If  the crab
were to do merely 10 moves, the following changes would occur:
#+begin_example
-- move 1 --
cups: (3) 8  9  1  2  5  4  6  7 
pick up: 8, 9, 1
destination: 2

-- move 2 --
cups:  3 (2) 8  9  1  5  4  6  7 
pick up: 8, 9, 1
destination: 7

-- move 3 --
cups:  3  2 (5) 4  6  7  8  9  1 
pick up: 4, 6, 7
destination: 3

-- move 4 --
cups:  7  2  5 (8) 9  1  3  4  6 
pick up: 9, 1, 3
destination: 7

-- move 5 --
cups:  3  2  5  8 (4) 6  7  9  1 
pick up: 6, 7, 9
destination: 3

-- move 6 --
cups:  9  2  5  8  4 (1) 3  6  7 
pick up: 3, 6, 7
destination: 9

-- move 7 --
cups:  7  2  5  8  4  1 (9) 3  6 
pick up: 3, 6, 7
destination: 8

-- move 8 --
cups:  8  3  6  7  4  1  9 (2) 5 
pick up: 5, 8, 3
destination: 1

-- move 9 --
cups:  7  4  1  5  8  3  9  2 (6)
pick up: 7, 4, 1
destination: 5

-- move 10 --
cups: (5) 7  4  1  8  3  9  2  6 
pick up: 7, 4, 1
destination: 3

-- final --
cups:  5 (8) 3  7  4  1  9  2  6 
#+end_example

In the above  example, the cups' values are the  labels as they appear
moving clockwise around  the circle; the current cup is  marked with (
).

After the crab is done, what order will the cups be in? Starting after
the cup  labeled 1, collect  the other  cups' labels clockwise  into a
single string  with no extra  characters; each number except  1 should
appear exactly  once. In the above  example, after 10 moves,  the cups
clockwise   from  1   are   labeled   9,  2,   6,   5,   and  so   on,
producing 92658374.  If the crab were  to complete all 100  moves, the
order after cup 1 would be 67384529.

Using your  labeling, simulate 100 moves.  What are the labels  on the
cups after cup 1?
** TODO Day 23.2                                                  :noexport:

** TODO Day 24.1                                                  :noexport:

Your raft makes it to the tropical island; it turns out that the small
crab was an excellent navigator. You make your way to the resort.

As you  enter the lobby,  you discover a  small problem: the  floor is
being renovated. You can't even  reach the check-in desk until they've
finished installing the new tile floor.

The tiles are  all hexagonal; they need  to be arranged in  a hex grid
with a very specific color pattern. Not in the mood to wait, you offer
to help figure out the pattern.

The tiles are all white on one side and black on the other. They start
with  the white  side facing  up.  The lobby  is large  enough to  fit
whatever pattern might need to appear there.

A member  of the renovation  crew gives you a  list of the  tiles that
need to  be flipped over  (your puzzle input).  Each line in  the list
identifies a single  tile that needs to be flipped  by giving a series
of steps  starting from  a reference  tile in the  very center  of the
room. (Every line starts from the same reference tile.)

Because the tiles  are hexagonal, every tile has  six neighbors: east,
southeast, southwest, west, northwest, and northeast. These directions
are given in your  list, respectively, as e, se, sw, w,  nw, and ne. A
tile is identified by a series of these directions with no delimiters;
for example,  esenee identifies the tile  you land on if  you start at
the reference  tile and then move  one tile east, one  tile southeast,
one tile northeast, and one tile east.

Each time a tile  is identified, it flips from white  to black or from
black to white. Tiles might be  flipped more than once. For example, a
line  like esew  flips a  tile immediately  adjacent to  the reference
tile, and a line like nwwswee flips the reference tile itself.

Here is a larger example:
#+begin_example
sesenwnenenewseeswwswswwnenewsewsw
neeenesenwnwwswnenewnwwsewnenwseswesw
seswneswswsenwwnwse
nwnwneseeswswnenewneswwnewseswneseene
swweswneswnenwsewnwneneseenw
eesenwseswswnenwswnwnwsewwnwsene
sewnenenenesenwsewnenwwwse
wenwwweseeeweswwwnwwe
wsweesenenewnwwnwsenewsenwwsesesenwne
neeswseenwwswnwswswnw
nenwswwsewswnenenewsenwsenwnesesenew
enewnwewneswsewnwswenweswnenwsenwsw
sweneswneswneneenwnewenewwneswswnese
swwesenesewenwneswnwwneseswwne
enesenwswwswneneswsenwnewswseenwsese
wnwnesenesenenwwnenwsewesewsesesew
nenewswnwewswnenesenwnesewesw
eneswnwswnwsenenwnwnwwseeswneewsenese
neswnwewnwnwseenwseesewsenwsweewe
wseweeenwnesenwwwswnew
#+end_example

In the above example, 10 tiles are flipped once (to black), and 5 more
are flipped twice  (to black, then back to white).  After all of these
instructions have been followed, a total of 10 tiles are black.

Go through the  renovation crew's list and determine  which tiles they
need to  flip. After all of  the instructions have been  followed, how
many tiles are left with the black side up?
** TODO Day 24.2                                                  :noexport:

** TODO Day 25.1                                                  :noexport:

You finally reach the check-in desk. Unfortunately, their registration
systems are currently offline, and  they cannot check you in. Noticing
the look on  your face, they quickly add that  tech support is already
on the way! They even created all  the room keys this morning; you can
take yours now  and give them your room deposit  once the registration
system comes back online.

The room key is a small RFID card.  Your room is on the 25th floor and
the elevators  are also temporarily out  of service, so it  takes what
little energy you have left to  even climb the stairs and navigate the
halls. You finally reach the door to your room, swipe your card, and -
beep - the light turns red.

Examining the card more closely, you  discover a phone number for tech
support.

"Hello! How can we help you today?" You explain the situation.

"Well, it  sounds like  the card  isn't sending  the right  command to
unlock the door.  If you go back to the  check-in desk, surely someone
there can reset it for you."  Still catching your breath, you describe
the status of the elevator and the exact number of stairs you just had
to climb.

"I see! Well, your only other  option would be to reverse-engineer the
cryptographic handshake  the card does  with the door and  then inject
your  own  commands  into  the  data  stream,  but  that's  definitely
impossible." You thank them for their time.

Unfortunately  for   the  door,  you   know  a  thing  or   two  about
cryptographic handshakes.

The handshake used by the card and the door involves an operation that
transforms a subject number. To transform a subject number, start with
the value 1. Then, a number of times called the loop size, perform the
following steps:
- Set the value to itself multiplied by the subject number.
- Set the value to the remainder after dividing the value by 20201227.
  
The card always uses a specific, secret loop size when it transforms a
subject number. The door always uses a different, secret loop size.

The cryptographic handshake works like this:
- The card transforms the subject number of 7 according to the card's
  secret loop size. The result is called the card's public key.
- The door transforms the subject number of 7 according to the door's
  secret loop size. The result is called the door's public key.
- The card and door use the wireless RFID signal to transmit the two
  public keys (your puzzle input) to the other device. Now, the card
  has the door's public key, and the door has the card's public
  key. Because you can eavesdrop on the signal, you have both public
  keys, but neither device's loop size.
- The card transforms the subject number of the door's public key
  according to the card's loop size. The result is the encryption key.
- The door transforms the subject number of the card's public key
  according to the door's loop size. The result is the same encryption
  key as the card calculated.
  
If you  can use the  two public keys  to determine each  device's loop
size,  you  will  have  enough information  to  calculate  the  secret
encryption key that  the card and door use to  communicate; this would
let you send the unlock command directly to the door!

For   example,  suppose   you  know   that  the   card's  public   key
is 5764801. With a  little trial and error, you can  work out that the
card's loop size  must be 8, because transforming  the initial subject
number of 7 with a loop size of 8 produces 5764801.

Then, suppose you know that the  door's public key is 17807724. By the
same  process, you  can determine  that the  door's loop  size is  11,
because transforming the initial subject number  of 7 with a loop size
of 11 produces 17807724.

At this  point, you can use  either device's loop size  with the other
device's public key to calculate  the encryption key. Transforming the
subject number of 17807724 (the door's public key) with a loop size of
8    (the    card's    loop     size)    produces    the    encryption
key, 14897079. (Transforming the subject number of 5764801 (the card's
public key) with a loop size of 11 (the door's loop size) produces the
same encryption key: 14897079.)

What encryption key is the handshake trying to establish?
** TODO Day 25.2                                                  :noexport:

** Stats                                                          :noexport:

#+CAPTION: https://adventofcode.com/2020/stats
| 25 |  4 | ▉▉▉▉                                      |
| 24 |  5 | ▉▉▉▉▉                                     |
| 23 |  5 | ▉▉▉▉▉                                     |
| 22 |  5 | ▉▉▉▉▉                                     |
| 21 |  6 | ▉▉▉▉▉▉                                    |
| 20 |  6 | ▉▉▉▉▉▉                                    |
| 19 |  6 | ▉▉▉▉▉▉                                    |
| 18 |  7 | ▉▉▉▉▉▉▉                                   |
| 17 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 16 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 15 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
| 14 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
| 13 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
| 12 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
| 11 | 13 | ▉▉▉▉▉▉▉▉▉▉▉▉▉                             |
| 10 | 15 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                           |
|  9 | 15 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                           |
|  8 | 17 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                         |
|  7 | 17 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                         |
|  6 | 20 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                      |
|  5 | 21 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                     |
|  4 | 24 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                  |
|  3 | 27 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉               |
|  2 | 33 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉         |
|  1 | 41 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ |
#+TBLFM: $3='(orgtbl-uc-draw-grid $2 0 41 41)
* 2019 [14/50]
** DONE Day 1.1

Santa  has become  stranded  at the  edge of  the  Solar System  while
delivering  presents to  other  planets! To  accurately calculate  his
position in space, safely align his warp drive, and return to Earth in
time to  save Christmas, he needs  you to bring him  measurements from
fifty stars.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

The Elves quickly load you into a spacecraft and prepare to launch.

At  the first  Go  /  No Go  poll,  every Elf  is  Go  until the  Fuel
Counter-Upper.  They haven't  determined the  amount of  fuel required
yet.

Fuel   required  to   launch  a   given   module  is   based  on   its
mass. Specifically, to  find the fuel required for a  module, take its
mass, divide by three, round down, and subtract 2.

For example:
- For a mass of 12, divide by 3 and round down to get 4, then subtract
  2 to get 2.
- For a mass of 14, dividing by 3 and rounding down still yields 4, so
  the fuel required is also 2.
- For a mass of 1969, the fuel required is 654.
- For a mass of 100756, the fuel required is 33583.

The Fuel  Counter-Upper needs to  know the total fuel  requirement. To
find it, individually  calculate the fuel needed for the  mass of each
module (your puzzle input), then add together all the fuel values.

What is  the sum of  the fuel requirements for  all of the  modules on
your spacecraft?

#+begin_src fennel -n :session d1901 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["12" "14" "1969" "100756"])

(fn fuel [mass]
  (- (aoc.int/ mass 3) 2))

(fn solve [input]
  (let [xs (lume.map input tonumber)]
    (accumulate [sum 0 _ x (ipairs xs)]
      (+ sum (fuel x)))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test (+ 2 2 654 33583) test-input)

(solve (aoc.string-from "2019/01.inp"))
#+end_src

#+RESULTS:
: 3560353

** DONE Day 1.2

During the  second Go / No  Go poll, the  Elf in charge of  the Rocket
Equation  Double-Checker stops  the launch  sequence. Apparently,  you
forgot to include additional fuel for the fuel you just added.

Fuel itself requires  fuel just like a module -  take its mass, divide
by three, round down, and subtract 2. However, that fuel also requires
fuel, and  that fuel  requires fuel,  and so on.  Any mass  that would
require negative fuel should instead be treated as if it requires zero
fuel; the remaining mass, if any, is instead handled by wishing really
hard, which has no mass and is outside the scope of this calculation.

So,  for each  module  mass, calculate  its  fuel and  add  it to  the
total. Then,  treat the fuel amount  you just calculated as  the input
mass and  repeat the process,  continuing until a fuel  requirement is
zero or negative. For example:
- A module of  mass 14 requires 2 fuel. This  fuel requires no further
  fuel (2 divided by  3 and rounded down is 0, which  would call for a
  negative fuel), so the total fuel required is still just 2.
- At first, a  module of mass 1969 requires 654  fuel. Then, this fuel
  requires 216  more fuel  (654 / 3  - 2). 216  then requires  70 more
  fuel, which requires 21 fuel,  which requires 5 fuel, which requires
  no further  fuel. So, the total  fuel required for a  module of mass
  1969 is 654 + 216 + 70 + 21 + 5 = 966.
- The  fuel required  by a  module  of mass  100756 and  its fuel  is:
  33583 + 11192 + 3728 + 1240 + 411 + 135 + 43 + 12 + 2 = 50346.
  
What is  the sum of  the fuel requirements for  all of the  modules on
your spacecraft  when also taking into  account the mass of  the added
fuel?  (Calculate the  fuel requirements  for each  module separately,
then add them all up at the end.)

#+begin_src fennel -n :session d1901 :exports both
(fn added-fuel [mass]
  (let [res (aoc.lazy-seq [mass] fuel)]
    (aoc.table-sum (aoc.table-range res 2 (length res)))))

(fn solve2 [input]
  (let [xs (lume.map input tonumber)]
    (accumulate [sum 0 _ x (ipairs xs)]
      (+ sum (added-fuel x)))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 (+ 2 2 966 50346) test-input)

(solve2 (aoc.string-from "2019/01.inp"))
#+end_src

#+RESULTS:
: 5337642

** DONE Day 2.1

On the way to your gravity  assist around the Moon, your ship computer
beeps angrily  about a "1202 program  alarm". On the radio,  an Elf is
already explaining how  to handle the situation:  "Don't worry, that's
perfectly norma--" The ship computer bursts into flames.

You notify  the Elves that  the computer's  magic smoke seems  to have
escaped. "That computer  ran Intcode programs like  the gravity assist
program it  was working  on; surely  there are  enough spare  parts up
there to build a new Intcode computer!"

An Intcode  program is a  list of  integers separated by  commas (like
1,0,0,3,99). To run one, start by looking at the first integer (called
position 0). Here, you  will find an opcode - either 1,  2, or 99. The
opcode indicates what to do; for example, 99 means that the program is
finished and  should immediately halt. Encountering  an unknown opcode
means something went wrong.

Opcode 1 adds together numbers read  from two positions and stores the
result in a  third position. The three integers  immediately after the
opcode tell  you these three  positions -  the first two  indicate the
positions from which  you should read the input values,  and the third
indicates the position at which the output should be stored.

For example, if your Intcode computer encounters 1,10,20,30, it should
read the  values at positions  10 and 20,  add those values,  and then
overwrite the value at position 30 with their sum.

Opcode 2  works exactly like  opcode 1,  except it multiplies  the two
inputs instead  of adding  them. Again, the  three integers  after the
opcode indicate where the inputs and outputs are, not their values.

Once  you're done  processing  an  opcode, move  to  the  next one  by
stepping forward 4 positions.

For example, suppose you have the following program:

#+begin_example
1,9,10,3,2,3,11,0,99,30,40,50
#+end_example

For the purposes of illustration, here  is the same program split into
multiple lines:

#+begin_example
1,9,10,3,
2,3,11,0,
99,
30,40,50
#+end_example

The  first  four  integers,  1,9,10,3,  are  at  positions  0,  1,  2,
and 3.  Together, they represent  the first opcode (1,  addition), the
positions of the two inputs (9 and 10), and the position of the output
(3). To handle  this opcode, you first  need to get the  values at the
input   positions:   position  9   contains   30,   and  position   10
contains 40.  Add these numbers together  to get 70. Then,  store this
value at  the output  position; here,  the output  position (3)  is at
position 3, so it overwrites itself. Afterward, the program looks like
this:

#+begin_example
1,9,10,70,
2,3,11,0,
99,
30,40,50
#+end_example

Step forward  4 positions  to reach  the next  opcode, 2.  This opcode
works just like the previous, but it multiplies instead of adding. The
inputs are  at positions 3 and  11; these positions contain  70 and 50
respectively.  Multiplying  these produces  3500;  this  is stored  at
position 0:

#+begin_example
3500,9,10,70,
2,3,11,0,
99,
30,40,50
#+end_example

Stepping forward  4 more positions  arrives at opcode 99,  halting the
program.

Here are the initial and final states of a few more small programs:
- 1,0,0,0,99 becomes 2,0,0,0,99 (1 + 1 = 2).
- 2,3,0,3,99 becomes 2,3,0,6,99 (3 * 2 = 6).
- 2,4,4,5,99,0 becomes 2,4,4,5,99,9801 (99 * 99 = 9801).
- 1,1,1,4,99,5,6,0,99 becomes 30,1,1,4,2,5,6,0,99.

Once you  have a working  computer, the first  step is to  restore the
gravity assist program (your puzzle input) to the "1202 program alarm"
state it  had just before the  last computer caught fire.  To do this,
before running the  program, replace position 1 with the  value 12 and
replace position 2 with the value 2.  What value is left at position 0
after the program halts?

#+begin_src fennel -n :session d1902 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn return-code [xs]
  (var pos 1)
  (var done false)
  (while (not done)
    (if (= 99 (. xs pos))
        (set done true)
        (let [res (+ 1 (. xs (+ pos 3)))
              lar (. xs (+ 1 (. xs (+ pos 1)))) 
              rar (. xs (+ 1 (. xs (+ pos 2))))]
          (case (. xs pos)
            1  (aoc.table-swap xs res (+ lar rar))
            2  (aoc.table-swap xs res (* lar rar)))))
    (when (not done)
      (set pos (+ 4 pos))))
  (. xs 1))

(fn restore-gravity-assist [input]
  (let [xs (aoc.string-tonumarray input)]
    (aoc.table-swap xs 2 12)
    (aoc.table-swap xs 3 2)
    (return-code xs)))

(fn solve [input]
  (restore-gravity-assist (. input 1)))

(fn test [expected input]
  (let [xs (aoc.string-tonumarray input)]
    (assert (= expected (return-code xs)))))

(test 3500 "1,9,10,3,2,3,11,0,99,30,40,50")
(test 2 "1,0,0,0,99")
(test 2 "2,3,0,3,99")
(test 2 "2,4,4,5,99,0")
(test 30 "1,1,1,4,99,5,6,0,99")

(solve (aoc.string-from "2019/02.inp"))
#+end_src

#+RESULTS:
: 7594646

** DONE Day 2.2

"Good, the new computer seems to  be working correctly! Keep it nearby
during  this mission  - you'll  probably  use it  again. Real  Intcode
computers support many more features than  your new one, but we'll let
you know what they are as you need them."

"However, your  current priority  should be  to complete  your gravity
assist around the Moon. For this  mission to succeed, we should settle
on some terminology for the parts you've already built."

Intcode programs  are given as  a list  of integers; these  values are
used as the  initial state for the computer's =memory=.  When you run an
Intcode  program, make  sure to  start by  initializing memory  to the
program's  values. A  position in  memory  is called  an =address=  (for
example, the first value in memory is at "address 0").

Opcodes (like 1,  2, or 99) mark the beginning  of an instruction. The
values  used immediately  after  an  opcode, if  any,  are called  the
instruction's =parameters=.  For example,  in the instruction 1,2,3,4, 1
is the  opcode; 2,  3, and  4 are the  parameters. The  instruction 99
contains only an opcode and has no parameters.

The  address of  the  current instruction  is  called the  instruction
pointer;  it  starts  at  0.    After  an  instruction  finishes,  the
instruction  pointer  increases  by  the  =number  of  values  in  the
instruction=; until you add more instructions to the computer, this is
always  4  (1  opcode  +  3  parameters)  for  the  add  and  multiply
instructions.  (The  halt instruction  would increase  the instruction
pointer by 1, but it halts the program instead.)

"With terminology out of the way,  we're ready to proceed. To complete
the  gravity  assist, you  need  to  determine  =what pair  of  inputs
produces the output= 19690720."

The inputs  should still be provided  to the program by  replacing the
values at  addresses 1 and 2,  just like before. In  this program, the
value placed in address 1 is called  the =noun=, and the value placed in
address 2  is called the  =verb=. Each of the  two input values  will be
between 0 and 99, inclusive.

Once the  program has halted,  its output  is available at  address 0,
also just like before.  Each time you  try a pair of inputs, make sure
you first  =reset the computer's  memory to  the values in  the program=
(your  puzzle input)  -  in other  words, don't  reuse  memory from  a
previous attempt.

Find the  input noun and  verb that cause  the program to  produce the
output 19690720. =What is 100 *  noun + verb=?  (For example, if noun=12
and verb=2, the answer would be 1202.)

#+begin_src fennel -n :session d1902 :exports both
(fn complete-gravity-assist [input]
  (var done false)
  (for [i 0 99 &until done]
    (for [j 0 99 &until done]
      (let [xs (aoc.string-tonumarray input)]
        (aoc.table-swap xs 2 i)
        (aoc.table-swap xs 3 j)
        (when (= 19690720 (return-code xs))
          (set done (+ (* 100 i) j))))))
  done)

(fn solve2 [input]
  (complete-gravity-assist (. input 1)))

(solve2 (aoc.string-from "2019/02.inp"))
#+end_src

#+RESULTS:
: 3376

** DONE Day 3.1

The gravity assist was successful, and  you're well on your way to the
Venus  refuelling station.  During the  rush back  on Earth,  the fuel
management system wasn't  completely installed, so that's  next on the
priority list.

Opening the front  panel reveals a jumble of  wires. Specifically, two
wires  are  connected to  a  central  port  and  extend outward  on  a
grid. You  trace the  path each  wire takes as  it leaves  the central
port, one wire per line of text (your puzzle input).

The  wires  twist and  turn,  but  the  two wires  occasionally  cross
paths. To  fix the circuit,  you need  to find the  intersection point
closest to the central port. Because the  wires are on a grid, use the
Manhattan  distance   for  this   measurement.  While  the   wires  do
technically cross  right at  the central port  where they  both start,
this point  does not  count, nor  does a wire  count as  crossing with
itself.

For example,  if the first  wire's path is R8,U5,L5,D3,  then starting
from the central port (o), it goes  right 8, up 5, left 5, and finally
down 3:

#+begin_example
...........
...........
...........
....+----+.
....|....|.
....|....|.
....|....|.
.........|.
.o-------+.
...........
#+end_example

Then, if the second wire's path is U7,R6,D4,L4, it goes up 7, right 6,
down 4, and left 4:

#+begin_example
...........
.+-----+...
.|.....|...
.|..+--X-+.
.|..|..|.|.
.|.-X--+.|.
.|..|....|.
.|.......|.
.o-------+.
...........
#+end_example

These wires cross at two locations  (marked X), but the lower-left one
is closer to the central port: its distance is 3 + 3 = 6.

Here are a few more examples:
- R75,D30,R83,U83,L12,D49,R71,U7,L72
- U62,R66,U55,R34,D71,R55,D58,R83 = distance 159
- R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51
- U98,R91,D20,R16,D67,R40,U7,R15,U6,R7 = distance 135

What is  the Manhattan distance from  the central port to  the closest
intersection?

#+begin_src fennel -n :session d1903 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test1-input
       ["R8,U5,L5,D3"
        "U7,R6,D4,L4"])
(local test2-input
       ["R75,D30,R83,U83,L12,D49,R71,U7,L72"
        "U62,R66,U55,R34,D71,R55,D58,R83"])
(local test3-input
       ["R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51"
        "U98,R91,D20,R16,D67,R40,U7,R15,U6,R7"])

(fn find-cross [l1 l2]
  (let [res []]
    (for [i 3 (length l1)]
      (for [j 3 (length l2)]
        (let [s1 [(. l1 (- i 1)) (. l1 i)]
              s2 [(. l2 (- j 1)) (. l2 j)]
              found (aoc.intersection s1 s2)]
          (when found
            (table.insert res found)))))
    res))

(fn solve [input]
  (let [line1 (aoc.decartian (. input 1))
        line2 (aoc.decartian (. input 2))
        res (find-cross line1 line2)]
    (aoc.math-min (lume.map res (fn [e] (aoc.manhattan-dist [0 0] e))))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 6 test1-input)
(test 159 test2-input)
(test 135 test3-input)
(solve (aoc.string-from "2019/03.inp"))
#+end_src

#+RESULTS:
: 209

** DONE Day 3.2

It turns out that this  circuit is very timing-sensitive; you actually
need to =minimize the signal delay=.

To do  this, calculate the  number of steps  each wire takes  to reach
each  intersection; choose  the  intersection where  the  sum of  both
wires'  steps is  lowest. If  a  wire visits  a position  on the  grid
multiple times, use the steps value from the first time it visits that
position when calculating the total value of a specific intersection.

The number of steps  a wire takes is the total  number of grid squares
the  wire  has  entered  to   get  to  that  location,  including  the
intersection being considered. Again consider the example from above:

#+begin_example
...........
.+-----+...
.|.....|...
.|..+--X-+.
.|..|..|.|.
.|.-X--+.|.
.|..|....|.
.|.......|.
.o-------+.
...........
#+end_example

In the above example, the intersection  closest to the central port is
reached after 8+5+5+2  = 20 steps by  the first wire and  7+6+4+3 = 20
steps by the second wire for a total of 20+20 = 40 steps.

However, the  top-right intersection is  better: the first  wire takes
only 8+5+2 = 15 and the second wire  takes only 7+6+2 = 15, a total of
15+15 = 30 steps.

Here are the best steps for the extra examples from above:
- R75,D30,R83,U83,L12,D49,R71,U7,L72
- U62,R66,U55,R34,D71,R55,D58,R83 = 610 steps
- R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51
- U98,R91,D20,R16,D67,R40,U7,R15,U6,R7 = 410 steps

What is  the fewest  combined steps  the wires must  take to  reach an
intersection?


#+begin_src fennel -n :session d1903 :exports both
(fn linear-dist [p s]
  (var done false)
  (let [res []]
    (for [i 2 (length s) &until done]
      (let [s0 (. s (- i 1))
            s1 (. s i)]
        (set done (aoc.in-segment? p [s0 s1]))
        (if done
            (table.insert res (aoc.manhattan-dist s0 p))
            (table.insert res (aoc.manhattan-dist s0 s1)))))
    (aoc.table-sum res)))

(fn solve2 [input]
  (let [line1 (aoc.decartian (. input 1))
        line2 (aoc.decartian (. input 2))
        res (find-cross line1 line2)]
    (aoc.math-min
     (lume.map res (fn [e] (+ (linear-dist e line1)
                              (linear-dist e line2)))))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 30 test1-input)
(test2 610 test2-input)
(test2 410 test3-input)
(solve2 (aoc.string-from "2019/03.inp"))
#+end_src

#+RESULTS:
: 43258

** DONE Day 4.1

You arrive at the Venus fuel  depot only to discover it's protected by
a password. The  Elves had written the password on  a sticky note, but
someone threw it out.

However, they do remember a few key facts about the password:
- It is a six-digit number.
- The value is within the range given in your puzzle input.
- Two adjacent digits are the same (like 22 in 122345).
- Going from left to right, the digits never decrease; they only ever
  increase or stay the same (like 111123 or 135679).
  
Other than the range rule, the following are true:
- 111111 meets these criteria (double 11, never decreases).
- 223450 does not meet these criteria (decreasing pair of digits 50).
- 123789 does not meet these criteria (no double).

How many  different passwords  within 134792-675810 range meet these
criteria?

#+begin_src fennel -n :session d1904 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn identity [a b]
  (= a b))

(fn adjacent? [xs]
  (let [bins (aoc.partition-by xs identity)]
    (lume.any bins #(< 1 (length $)))))

(fn never-decrease? [xs]
  (var res true)
  (for [i 2 (length xs) &until (not res)]
    (when (< (. xs i)
             (. xs (- i 1)))
      (set res false)))
  res)

(fn solve [f t]
  (var res 0)
  (for [i f t]
    (let [xs (aoc.toarray i)]
      (when (and (adjacent? xs)
                 (never-decrease? xs))
        (set res (+ 1 res)))))
  res)

(solve 134792 675810)
#+end_src

#+RESULTS:
: 1955

** DONE Day 4.2

An Elf  just remembered  one more important  detail: the  two adjacent
matching digits are not part of a larger group of matching digits.

Given this  additional criterion, but  still ignoring the  range rule,
the following are now true:
- 112233 meets  these criteria because  the digits never  decrease and
  all repeated digits are exactly two digits long.
- 123444 no  longer meets the criteria  (the repeated 44 is  part of a
  larger group of 444).
- 111122  meets the  criteria (even  though  1 is  repeated more  than
  twice, it still contains a double 22).
  
How many  different passwords  within the range  given in  your puzzle
input meet all of the criteria?

#+begin_src fennel -n :session d1904 :exports both
(fn two-adjacent? [xs]
  (let [bins (aoc.partition-by xs identity)]
    (lume.any bins #(= 2 (length $)))))

(fn solve2 [f t]
  (var res 0)
  (for [i f t]
    (let [xs (aoc.toarray i)]
      (when (and (two-adjacent? xs)
                 (never-decrease? xs))
        (set res (+ 1 res)))))
  res)

(solve2 134792 675810)
#+end_src

#+RESULTS:
: 1319


** DONE Day 5.1

You're starting to sweat as the ship makes its way toward Mercury. The
Elves suggest  that you get  the air conditioner working  by upgrading
your  ship computer  to  support the  Thermal Environment  Supervision
Terminal.

The Thermal Environment Supervision  Terminal (TEST) starts by running
a diagnostic program (your puzzle  input). The TEST diagnostic program
will run on your existing Intcode computer after a few modifications:

First, you'll need to add two new instructions:
- Opcode 3 takes a single integer as input and saves it to the
  position given by its only parameter. For example, the instruction
  3,50 would take an input value and store it at address 50.
- Opcode 4 outputs the value of its only parameter. For example, the
  instruction 4,50 would output the value at address 50.
  
Programs that use these instructions will come with documentation that
explains what should be connected to the input and output. The program
3,0,4,0,99 outputs whatever it gets as input, then halts.

Second, you'll need to add support for parameter modes:

Each parameter  of an  instruction is handled  based on  its parameter
mode. Right now, your ship computer already understands parameter mode
0, position  mode, which causes the  parameter to be interpreted  as a
position - if  the parameter is 50,  its value is the  value stored at
address 50 in memory. Until now,  all parameters have been in position
mode.

Now, your ship computer will also need to handle parameters in mode 1,
immediate mode.  In immediate  mode, a parameter  is interpreted  as a
value - if the parameter is 50, its value is simply 50.

Parameter  modes are  stored in  the same  value as  the instruction's
opcode. The  opcode is a two-digit  number based only on  the ones and
tens digit  of the  value, that  is, the opcode  is the  rightmost two
digits  of the  first value  in  an instruction.  Parameter modes  are
single digits, one per parameter,  read right-to-left from the opcode:
the  first parameter's  mode  is  in the  hundreds  digit, the  second
parameter's mode is in the thousands digit, the third parameter's mode
is in the ten-thousands digit, and so on. Any missing modes are 0.

For example, consider the program 1002,4,3,4,33.

The first  instruction, 1002,4,3,4,  is a  multiply instruction  - the
rightmost  two digits  of  the  first value,  02,  indicate opcode  2,
multiplication. Then, going  right to left, the parameter  modes are 0
(hundreds digit), 1 (thousands digit), and 0 (ten-thousands digit, not
present and therefore zero):

#+begin_example
ABCDE
 1002

DE - two-digit opcode,      02 == opcode 2
 C - mode of 1st parameter,  0 == position mode
 B - mode of 2nd parameter,  1 == immediate mode
 A - mode of 3rd parameter,  0 == position mode,
                                  omitted due to being a leading zero
#+end_example

This  instruction  multiplies  its  first two  parameters.  The  first
parameter, 4 in position mode, works like it did before - its value is
the  value stored  at  address  4 (33).  The  second  parameter, 3  in
immediate mode, simply has value 3. The result of this operation, 33 *
3 =  99, is written  according to the  third parameter, 4  in position
mode,  which  also  works like  it  did  before  -  99 is  written  to
address 4.

Parameters that  an instruction writes  to will never be  in immediate
mode.

Finally, some notes:
- It  is important  to remember  that the  instruction pointer  should
  increase  by the  number  of  values in  the  instruction after  the
  instruction finishes.  Because of the new  instructions, this amount
  is no longer always 4.
- Integers can be  negative: 1101,100,-1,4,0 is a  valid program (find
  100 + -1, store the result in position 4).
  
The TEST diagnostic program will start by requesting from the user the
ID of the system to test by  running an input instruction - provide it
1, the ID for the ship's air conditioner unit.

It  will then  perform a  series of  diagnostic tests  confirming that
various parts of the Intcode  computer, like parameter modes, function
correctly. For each test, it will run an output instruction indicating
how far the  result of the test  was from the expected  value, where 0
means the test  was successful. Non-zero outputs mean  that a function
is not working correctly; check  the instructions that were run before
the output instruction to see which one failed.

Finally, the  program will  output a  diagnostic code  and immediately
halt. This final output isn't an error; an output followed immediately
by a halt means the program  finished. If all outputs were zero except
the diagnostic code, the diagnostic program ran successfully.

After providing  1 to the only  input instruction and passing  all the
tests, what diagnostic code does the program produce?

#+begin_src fennel -n :session d1905 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn intcode [xs input]
  (var pos 1)
  (var done false)
  (var output nil)
  (while (not done)
    (let [code (aoc.table-range xs pos (+ pos 3))]
      (case code
        [99]
        (set done true)
        [1 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ (. xs (+ 1 la)) (. xs (+ 1 ra))))
        [1001 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ (. xs (+ 1 la)) ra))
        [101 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ la (. xs (+ 1 ra))))
        [1101 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ la ra))
        [2 la ra re]
        (aoc.table-swap xs (+ 1 re) (* (. xs (+ 1 la)) (. xs (+ 1 ra))))
        [1002 la ra re]
        (aoc.table-swap xs (+ 1 re) (* (. xs (+ 1 la)) ra))
        [102 la ra re]
        (aoc.table-swap xs (+ 1 re) (* la (. xs (+ 1 ra))))
        [1102 la ra re]
        (aoc.table-swap xs (+ 1 re) (* la ra))
        [3 re _ _]
        (aoc.table-swap xs (+ 1 re) input)
        [4 re _ _]
        (set output (. xs (+ 1 re)))
        [104 re _ _]
        (set output re)
        _
        (do (set done true)
            (print (.. "W: no match at " pos ": " (. xs pos)))))
      (when (not done)
        (if (lume.any [3 4 104] #(= $ (. code 1)))
            (set pos (+ 2 pos))
            (set pos (+ 4 pos))))))
  output)

(fn solve [input]
  (let [xs (aoc.string-tonumarray (. input 1))]
    (intcode xs 1)))

(solve (aoc.string-from "2019/05.inp"))
#+end_src

#+RESULTS:
: 6069343


** DONE Day 5.2

The air conditioner comes online! Its cold air feels good for a while,
but then  the TEST alarms start  to go off. Since  the air conditioner
can't  vent its  heat  anywhere  but back  into  the spacecraft,  it's
actually making the air inside the ship =warmer=.

Instead,  you'll  need   to  use  the  TEST  to   extend  the  [[https://en.wikipedia.org/wiki/Spacecraft_thermal_control][thermal
radiators]]. Fortunately, the diagnostic  program (your puzzle input) is
already  equipped for  this. Unfortunately,  your Intcode  computer is
not.

Your computer is only missing a few opcodes:
- Opcode 5  is =jump-if-true=:  if the first  parameter is  =non-zero=, it
  sets  the  instruction   pointer  to  the  value   from  the  second
  parameter. Otherwise, it does nothing.
- Opcode 6 is  =jump-if-false=: if the first parameter =is  zero=, it sets
  the   instruction   pointer   to   the   value   from   the   second
  parameter. Otherwise, it does nothing.
- Opcode  7 is  =less than=:  if the  first parameter  =is less=  than the
  second parameter,  it stores 1  in the  position given by  the third
  parameter. Otherwise, it stores 0.
- Opcode 8  is =equals=: if the  first parameter is =equal  to= the second
  parameter,  it  stores  1  in   the  position  given  by  the  third
  parameter. Otherwise, it stores 0.
  
Like all  instructions, these instructions need  to support =parameter
modes= as described above.

Normally, after  an instruction  is finished, the  instruction pointer
increases by the number of values in that instruction. =However=, if the
instruction modifies the  instruction pointer, that value  is used and
the instruction pointer is =not automatically increased=.

For example, here are several programs that take one input, compare it
to the value 8, and then produce one output:
- 3,9,8,9,10,9,4,9,99,-1,8 - Using =position mode=, consider whether the
  input is =equal to= 8; output 1 (if it is) or 0 (if it is not).
- 3,9,7,9,10,9,4,9,99,-1,8 - Using =position mode=, consider whether the
  input is =less than= 8; output 1 (if it is) or 0 (if it is not).
- 3,3,1108,-1,8,3,4,3,99 - Using =immediate mode=, consider whether the
  input is =equal to= 8; output 1 (if it is) or 0 (if it is not).
- 3,3,1107,-1,8,3,4,3,99 - Using =immediate  mode=, consider whether the
  input is =less than= 8; output 1 (if it is) or 0 (if it is not).
  
Here are  some jump  tests that take  an input, then  output 0  if the
input was zero or 1 if the input was non-zero:
- 3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9 (using =position mode=)
- 3,3,1105,-1,9,1101,0,0,12,4,12,99,1 (using =immediate mode=)

Here's a larger example:

#+begin_example
3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99
#+end_example

The  above example  program uses  an input  instruction to  ask for  a
single number. The program will then  output 999 if the input value is
below 8, output 1000 if the input  value is equal to 8, or output 1001
if the input value is greater than 8.

This time, when the TEST diagnostic program runs its input instruction
to get  the ID of  the system to  test, =provide it  5=, the ID  for the
ship's thermal  radiator controller.  This diagnostic test  suite only
outputs one number, the =diagnostic code=.

What is the diagnostic code for system ID 5?

#+begin_src fennel -n :session d1905 :exports both
(fn intcode-v2 [xs input]
  (var pos 1)
  (var done false)
  (var output nil)
  (while (not done)
    (let [code (aoc.table-range xs pos (+ pos 3))]
      (case code
        [99]
        (set done true)
        [1 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ (. xs (+ 1 la)) (. xs (+ 1 ra))))
        [101 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ la (. xs (+ 1 ra))))
        [1001 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ (. xs (+ 1 la)) ra))
        [1101 la ra re]
        (aoc.table-swap xs (+ 1 re) (+ la ra))
        [2 la ra re]
        (aoc.table-swap xs (+ 1 re) (* (. xs (+ 1 la)) (. xs (+ 1 ra))))
        [102 la ra re]
        (aoc.table-swap xs (+ 1 re) (* la (. xs (+ 1 ra))))
        [1002 la ra re]
        (aoc.table-swap xs (+ 1 re) (* (. xs (+ 1 la)) ra))
        [1102 la ra re]
        (aoc.table-swap xs (+ 1 re) (* la ra))
        [3 re _ _]
        (aoc.table-swap xs (+ 1 re) input)
        [4 re _ _]
        (set output (. xs (+ 1 re)))
        [104 re _ _]
        (set output re)
        [5 la ra _]
        (when (not= 0 (. xs (+ 1 la)))
          (set pos (+ 1 (. xs (+ 1 ra))))
          (set pos (+ 3 pos)))
        [105 la ra _]
        (if (not= 0 la)
          (set pos (+ 1 (. xs (+ 1 ra))))
          (set pos (+ 3 pos)))
        [1005 la ra _]
        (if (not= 0 (. xs (+ 1 la)))
          (set pos (+ 1 ra))
          (set pos (+ 3 pos)))
        [1105 la ra _]
        (if (not= 0 la)
          (set pos (+ 1 ra))
          (set pos (+ 3 pos)))
        [6 la ra _]
        (if (= 0 (. xs (+ 1 la)))
          (set pos (+ 1 (. xs (+ 1 ra))))
          (set pos (+ 3 pos)))
        [106 la ra _]
        (if (= 0 la)
          (set pos (+ 1 (. xs (+ 1 ra))))
          (set pos (+ 3 pos)))
        [1006 la ra _]
        (if (= 0 (. xs (+ 1 la)))
            (set pos (+ 1 ra))
            (set pos (+ 3 pos)))
        [1106 la ra _]
        (if (= 0 la)
            (set pos (+ 1 ra))
            (set pos (+ 3 pos)))
        [7 la ra re]
        (if (< (. xs (+ 1 la)) (. xs (+ 1 ra)))
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [107 la ra re]
        (if (< la (. xs (+ 1 ra)))
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [1007 la ra re]
        (if (< (. xs (+ 1 la)) ra)
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [1107 la ra re]
        (if (< la ra)
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [8 la ra re]
        (if (= (. xs (+ 1 la)) (. xs (+ 1 ra)))
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [108 la ra re]
        (if (= la (. xs (+ 1 ra)))
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [1008 la ra re]
        (if (= (. xs (+ 1 la)) ra)
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        [1108 la ra re]
        (if (= la ra)
            (aoc.table-swap xs (+ 1 re) 1)
            (aoc.table-swap xs (+ 1 re) 0))
        _
        (do (set done true)
            (print (.. "W: no match at " pos ": " (. xs pos)))))
      (when (not done)
        (if (lume.any [3 4 104] #(= $ (. code 1)))
            (set pos (+ 2 pos))
            (lume.any [1005 1105 105 5 1006 1106 106 6]
                      #(= $ (. code 1)))
            nil
            (set pos (+ 4 pos))))))
  output)

(fn solve2 [lines input]
  (let [xs (aoc.string-tonumarray (. lines 1))]
    (intcode-v2 xs input)))

(fn test [expected lines input]
  (assert (= expected (solve2 lines input))))

(local test-input ["3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99"])
(test 999 test-input 7)
(test 1000 test-input 8)
(test 1001 test-input 9)

(local test2-input ["3,9,8,9,10,9,4,9,99,-1,8"])
(test 1 test2-input 8)
(test 0 test2-input 7)

(local test3-input ["3,9,7,9,10,9,4,9,99,-1,8"])
(test 0 test3-input 8)
(test 1 test3-input 7)

(local test4-input ["3,3,1108,-1,8,3,4,3,99"])
(test 1 test4-input 8)
(test 0 test4-input 7)

(local test5-input ["3,3,1107,-1,8,3,4,3,99"])
(test 0 test5-input 8)
(test 1 test5-input 7)

(local test6-input ["3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9"])
(test 0 test6-input 0)
(test 1 test6-input 1)

(local test7-input ["3,3,1105,-1,9,1101,0,0,12,4,12,99,1"])
(test 0 test7-input 0)
(test 1 test7-input 1)

(solve2 (aoc.string-from "2019/05.inp") 5)
#+end_src

#+RESULTS:
: 3188550

** DONE Day 6.1

You've landed at the Universal  Orbit Map facility on Mercury. Because
navigation in  space often  involves transferring between  orbits, the
orbit maps here  are useful for finding efficient  routes between, for
example, you and  Santa. You download a map of  the local orbits (your
puzzle input).

Except for the  universal Center of Mass (COM), every  object in space
is in  orbit around exactly one  other object. An orbit  looks roughly
like this:

#+begin_example
                  \
                   \
                    |
                    |
AAA--> o            o <--BBB
                    |
                    |
                   /
                  /
#+end_example

In this diagram, the object BBB is  in orbit around AAA. The path that
BBB takes around  AAA (drawn with lines) is only  partly shown. In the
map data,  this orbital relationship  is written AAA)BBB,  which means
"BBB is in orbit around AAA".

Before you use your  map data to plot a course, you  need to make sure
it wasn't corrupted during the download. To verify maps, the Universal
Orbit Map  facility uses orbit count  checksums - the total  number of
direct orbits (like the one shown above) and indirect orbits.

Whenever A orbits B  and B orbits C, then A  indirectly orbits C. This
chain can be  any number of objects  long: if A orbits B,  B orbits C,
and C orbits D, then A indirectly orbits D.

For example, suppose you have the following map:
#+begin_example
COM)B
B)C
C)D
D)E
E)F
B)G
G)H
D)I
E)J
J)K
K)L
#+end_example

Visually, the above map of orbits looks like this:

#+begin_example
        G - H       J - K - L
       /           /
COM - B - C - D - E - F
               \
                I
#+end_example

In this  visual representation,  when two objects  are connected  by a
line, the one on the right directly orbits the one on the left.

Here, we can count the total number of orbits as follows:
- D directly orbits C and indirectly orbits B and COM, a total of 3
  orbits.
- L directly orbits K and indirectly orbits J, E, D, C, B, and COM, a
  total of 7 orbits.
- COM orbits nothing.

The total number of direct and indirect orbits in this example is 42.

What is the total number of direct and indirect orbits in your map
data?

#+begin_src fennel -n :session d1906 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["COM)B"
                   "B)C"
                   "C)D"
                   "D)E"
                   "E)F"
                   "B)G"
                   "G)H"
                   "D)I"
                   "E)J"
                   "J)K"
                   "K)L"])

(fn paths [xs]
  (let [res {}]
    (each [_ [k v] (ipairs xs)]
      (tset res v k))
    res))

(fn solve [input]
  (let [xs (paths (lume.map input #(aoc.string-split $ ")")))
        ys (lume.map (aoc.keys xs) #(aoc.rank xs $))]
    (accumulate [sum 0 _ y (ipairs ys)]
      (+ sum y))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 42 test-input)

(solve (aoc.string-from "2019/06.inp"))
#+end_src

#+RESULTS:
: 151345

** DONE Day 6.2

Now, you just need to figure  out how many orbital transfers you (YOU)
need to take to get to Santa (SAN).

You start  at the  object YOU  are orbiting;  your destination  is the
object SAN  is orbiting. An  orbital transfer  lets you move  from any
object to an object orbiting or orbited by that object.

For example, suppose you have the following map:

#+begin_example
COM)B
B)C
C)D
D)E
E)F
B)G
G)H
D)I
E)J
J)K
K)L
K)YOU
I)SAN
#+end_example

Visually, the above map of orbits looks like this:

#+begin_example
                          YOU
                         /
        G - H       J - K - L
       /           /
COM - B - C - D - E - F
               \
                I - SAN
#+end_example

In this example, YOU are in orbit around K, and SAN is in orbit around
I. To move from K to I, a minimum of 4 orbital transfers are required:
- K to J
- J to E
- E to D
- D to I

Afterward, the map of orbits looks like this:

#+begin_example
        G - H       J - K - L
       /           /
COM - B - C - D - E - F
               \
                I - SAN
                 \
                  YOU
#+end_example

What is the minimum number of  orbital transfers required to move from
the object  YOU are orbiting to  the object SAN is  orbiting? (Between
the objects they are orbiting - not between YOU and SAN.)

#+begin_src fennel -n :session d1906 :exports both
(local test2-input
       ["COM)B"
        "B)C"
        "C)D"
        "D)E"
        "E)F"
        "B)G"
        "G)H"
        "D)I"
        "E)J"
        "J)K"
        "K)L"
        "K)YOU"
        "I)SAN"])

(fn partial-paths [xs x y]
  (let [x1 (. xs x)
        y1 (. xs y)]
    (if (= x y) x
        (= x1 y1) x1
        (<= (aoc.rank xs x1) (aoc.rank xs y1))
        (partial-paths xs x1 (. xs y1))
        (partial-paths xs (. xs x1) y1))))

(fn solve2 [input]
  (let [xs (paths (lume.map input #(aoc.string-split $ ")")))
        x (partial-paths xs :YOU :SAN)]
    (- (+ (aoc.rank xs (. xs :SAN))
          (aoc.rank xs (. xs :YOU)))
       (* 2 (aoc.rank xs x)))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 4 test2-input)

(solve2 (aoc.string-from "2019/06.inp"))
#+end_src

#+RESULTS:
: 391

** TODO Day 7.1                                                   :noexport:

Based on  the navigational  maps, you're  going to  need to  send more
power to  your ship's thrusters  to reach Santa  in time. To  do this,
you'll need to  configure a series of amplifiers  already installed on
the ship.

There are  five amplifiers connected  in series; each one  receives an
input signal  and produces an  output signal. They are  connected such
that  the first  amplifier's output  leads to  the second  amplifier's
input, the  second amplifier's output  leads to the  third amplifier's
input, and so on. The first amplifier's input value is 0, and the last
amplifier's output leads to your ship's thrusters.
#+begin_example
    O-------O  O-------O  O-------O  O-------O  O-------O
0 ->| Amp A |->| Amp B |->| Amp C |->| Amp D |->| Amp E |-> (to thrusters)
    O-------O  O-------O  O-------O  O-------O  O-------O
#+end_example

The  Elves have  sent  you some  Amplifier  Controller Software  (your
puzzle  input), a  program that  should run  on your  existing Intcode
computer. Each amplifier will need to run a copy of the program.

When a  copy of the  program starts running  on an amplifier,  it will
first use  an input instruction to  ask the amplifier for  its current
phase setting  (an integer from  0 to 4).  Each phase setting  is used
exactly once, but the Elves can't remember which amplifier needs which
phase setting.

The  program will  then  call  another input  instruction  to get  the
amplifier's  input  signal, compute  the  correct  output signal,  and
supply it  back to the amplifier  with an output instruction.  (If the
amplifier has  not yet received  an input  signal, it waits  until one
arrives.)

Your job is to find the largest  output signal that can be sent to the
thrusters by  trying every possible  combination of phase  settings on
the amplifiers. Make sure that memory  is not shared or reused between
copies of the program.

For  example, suppose  you  want  to try  the  phase setting  sequence
3,1,2,4,0, which  would mean setting  amplifier A to phase  setting 3,
amplifier B to setting 1, C to 2, D  to 4, and E to 0. Then, you could
determine the  output signal that  gets sent  from amplifier E  to the
thrusters with the following steps:
- Start the copy of the amplifier controller software that will run on
  amplifier A. At its first input instruction, provide it the
  amplifier's phase setting, 3. At its second input instruction,
  provide it the input signal, 0. After some calculations, it will use
  an output instruction to indicate the amplifier's output signal.
- Start the software for amplifier B. Provide it the phase setting (1)
  and then whatever output signal was produced from amplifier A. It
  will then produce a new output signal destined for amplifier C.
- Start the software for amplifier C, provide the phase setting (2)
  and the value from amplifier B, then collect its output signal.
- Run amplifier D's software, provide the phase setting (4) and input
  value, and collect its output signal.
- Run amplifier E's software, provide the phase setting (0) and input
  value, and collect its output signal.
  
The  final  output signal  from  amplifier  E  would  be sent  to  the
thrusters. However, this phase setting  sequence may not have been the
best one;  another sequence  might have  sent a  higher signal  to the
thrusters.

Here are some example programs:
#+begin_example
    Max thruster signal 43210 (from phase setting sequence 4,3,2,1,0):

    3,15,3,16,1002,16,10,16,1,16,15,15,4,15,99,0,0

    Max thruster signal 54321 (from phase setting sequence 0,1,2,3,4):

    3,23,3,24,1002,24,10,24,1002,23,-1,23,
    101,5,23,23,1,24,23,23,4,23,99,0,0

    Max thruster signal 65210 (from phase setting sequence 1,0,4,3,2):

    3,31,3,32,1002,32,10,32,1001,31,-2,31,1007,31,0,33,
    1002,33,7,33,1,33,31,31,1,32,31,31,4,31,99,0,0,0
#+end_example

Try every combination of phase settings on the amplifiers. What is the
highest signal that can be sent to the thrusters?
** TODO Day 7.2                                                   :noexport:

** DONE Day 8.1

The  Elves'  spirits  are  lifted   when  they  realize  you  have  an
opportunity  to reboot  one  of their  Mars rovers,  and  so they  are
curious if you would spend a brief sojourn on Mars. You land your ship
near the rover.

When  you reach  the  rover, you  discover that  it's  already in  the
process of  rebooting! It's just waiting  for someone to enter  a BIOS
password. The  Elf responsible for  the rover  takes a picture  of the
password  (your puzzle  input) and  sends it  to you  via the  Digital
Sending Network.

Unfortunately,  images sent  via  the Digital  Sending Network  aren't
encoded  with  any normal  encoding;  instead,  they're encoded  in  a
special Space  Image Format. None  of the  Elves seem to  remember why
this is the case. They send you the instructions to decode it.

Images are sent as a series of digits that each represent the color of
a single pixel.  The digits fill each row of  the image left-to-right,
then move downward  to the next row, filling  rows top-to-bottom until
every pixel of the image is filled.

Each image actually  consists of a series  of identically-sized layers
that are  filled in this way.  So, the first digit  corresponds to the
top-left pixel of the first layer, the second digit corresponds to the
pixel to the right of that on the same layer, and so on until the last
digit, which corresponds to the bottom-right pixel of the last layer.

For example, given an image 3 pixels wide and 2 pixels tall, the image
data 123456789012 corresponds to the following image layers:

#+begin_example
Layer 1: 123
         456

Layer 2: 789
         012
#+end_example

The image you received is 25 pixels wide and 6 pixels tall.

To make sure the image wasn't corrupted during transmission, the Elves
would like you to find the layer that contains the fewest 0 digits. On
that layer, what is the number of 1 digits multiplied by the number of
2 digits?

#+begin_src fennel -n :session d1908 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [input w h]
  (let [res {:k 100000000 :v 0}
        layers (aoc.table-group-by (aoc.string-toarray input) (* w h))]
    (each [_ layer (ipairs layers)]
      (let [zeros (length (lume.filter layer #(= "0" $)))
            ones (length (lume.filter layer #(= "1" $)))
            twos (length (lume.filter layer #(= "2" $)))]
        (when (< zeros (?. res :k))
            (tset res :k zeros)
            (tset res :v (* ones twos)))))
    (. res :v)))

(fn test [expected input w h]
  (assert (= expected (solve input w h))))

(test 1 "123456789012" 3 2)

(solve (. (aoc.string-from "2019/08.inp") 1) 25 6)
#+end_src

#+RESULTS:
: 1584



** DONE Day 8.2

Now  you're ready  to  decode  the image.  The  image  is rendered  by
stacking the layers and aligning the pixels with the same positions in
each layer. The digits indicate  the color of the corresponding pixel:
0 is black, 1 is white, and 2 is transparent.

The layers  are rendered with  the first layer  in front and  the last
layer in back. So, if a given  position has a transparent pixel in the
first and second layers, a black pixel in the third layer, and a white
pixel in the fourth layer, the final image would have a =black= pixel at
that position.

For example, given an image 2 pixels wide and 2 pixels tall, the image
data =0222112222120000= corresponds to the following image layers:

#+begin_example
Layer 1:>02
         22

Layer 2: 11<
         22

Layer 3: 22
        >12

Layer 4: 00
         00<
#+end_example

Then, the full image can be found by determining the top visible pixel
in each position:
- The top-left pixel is =black= because the top layer is 0.
- The  top-right   pixel  is  =white=   because  the  top  layer   is  2
  (transparent), but the second layer is 1.
- The bottom-left pixel is =white= because the top two layers are 2, but
  the third layer is 1.
- The bottom-right  pixel is =black=  because the only visible  pixel in
  that position is 0 (from layer 4).
  
So, the final image looks like this:

#+begin_example
01
10
#+end_example

What message is produced after decoding your image?

#+begin_src fennel -n :session d1908 :exports both :results output :wrap EXAMPLE
(fn color [xs]
  (var res false)
  (each [_ col (ipairs xs) &until res]
    (case col
      "1" (set res "1")
      "2" nil
      "0" (set res "0")))
  res)

(fn process [input w h]
  (let [res []
        layers (aoc.table-group-by
                (aoc.table-group-by
                 (aoc.string-toarray input) w) h)
        rows (lume.map
              (aoc.table-transpose layers)
              #(aoc.table-transpose $))]
    (each [_ columns (ipairs rows)]
      (each [_ pixels (ipairs columns)]
        (let [col (color pixels)]
          (table.insert res col))))
    (aoc.table-group-by res w)))

(fn test2 [expected input w h]
  (let [res (process input w h)
        str (aoc.table-tostring (lume.map res #(aoc.table-tostring $)))]
    (assert (= expected str))))

(test2 "0110" "0222112222120000" 2 2)

(fn solve2 [input w h]
  (let [inp (. input 1)
        res (process inp w h)]
    (aoc.matrix-print res)))

(solve2 (aoc.string-from "2019/08.inp") 25 6)
#+end_src

#+RESULTS:
#+begin_EXAMPLE
#..#..##...##..####..##..
#.#..#..#.#..#.#....#..#.
##...#....#....###..#....
#.#..#....#.##.#....#....
#.#..#..#.#..#.#....#..#.
#..#..##...###.####..##..
#+end_EXAMPLE

** TODO Day 9.1                                                   :noexport:

You've just said goodbye to the  rebooted rover and left Mars when you
receive a faint distress signal coming from the asteroid belt. It must
be the Ceres monitoring station!

In  order  to  lock on  to  the  signal,  you'll  need to  boost  your
sensors. The Elves send up the  latest BOOST program - Basic Operation
Of System Test.

While BOOST (your  puzzle input) is capable of  boosting your sensors,
for tenuous safety reasons, it refuses  to do so until the computer it
runs on  passes some checks  to demonstrate  it is a  complete Intcode
computer.

Your existing  Intcode computer is  missing one key feature:  it needs
support for parameters in relative mode.

Parameters  in  mode  2,  relative  mode,  behave  very  similarly  to
parameters  in  position  mode:  the parameter  is  interpreted  as  a
position. Like position mode, parameters  in relative mode can be read
from or written to.

The important difference is that  relative mode parameters don't count
from address 0.  Instead, they count from a value  called the relative
base. The relative base starts at 0.

The address  a relative mode  parameter refers  to is itself  plus the
current  relative base.  When the  relative base  is 0,  relative mode
parameters and position  mode parameters with the same  value refer to
the same address.

For example, given a relative base of 50, a relative mode parameter of
-7 refers to memory address 50 + -7 = 43.

The relative base is modified with the relative base offset instruction:
- Opcode 9 adjusts the relative base by the value of its only
  parameter. The relative base increases (or decreases, if the value
  is negative) by the value of the parameter.
  
For example, if the relative base  is 2000, then after the instruction
109,19, the relative base would be  2019. If the next instruction were
204,-34, then the value at address 1985 would be output.

Your Intcode computer will also need a few other capabilities:
- The computer's available memory should be much larger than the
  initial program. Memory beyond the initial program starts with the
  value 0 and can be read or written like any other memory. (It is
  invalid to try to access memory at a negative address, though.)
- The computer should have support for large numbers. Some
  instructions near the beginning of the BOOST program will verify
  this capability.
  
Here are some example programs that use these features:
- 109,1,204,-1,1001,100,1,100,1008,100,16,101,1006,101,0,99 takes no
  input and produces a copy of itself as output.
- 1102,34915192,34915192,7,4,7,99,0 should output a 16-digit number.
- 104,1125899906842624,99 should output the large number in the middle.

The BOOST program will ask for a  single input; run it in test mode by
providing it the value  1. It will perform a series  of checks on each
opcode, output any  opcodes (and the associated  parameter modes) that
seem  to  be  functioning  incorrectly, and  finally  output  a  BOOST
keycode.

Once  your Intcode  computer is  fully functional,  the BOOST  program
should  report no  malfunctioning opcodes  when run  in test  mode; it
should  only output  a single  value,  the BOOST  keycode. What  BOOST
keycode does it produce?
** TODO Day 9.2                                                   :noexport:

** TODO Day 10.1                                                  :noexport:

You  fly  into  the  asteroid  belt and  reach  the  Ceres  monitoring
station.  The Elves  here have  an emergency:  they're having  trouble
tracking all of the asteroids and can't be sure they're safe.

The Elves  would like to  build a new  monitoring station in  a nearby
area of  space; they hand you  a map of  all of the asteroids  in that
region (your puzzle input).

The map  indicates whether each position  is empty (.) or  contains an
asteroid (#). The  asteroids are much smaller than they  appear on the
map,  and every  asteroid  is  exactly in  the  center  of its  marked
position. The asteroids can be  described with X,Y coordinates where X
is the distance from the left edge  and Y is the distance from the top
edge (so  the top-left corner is  0,0 and the position  immediately to
its right is 1,0).

Your job is  to figure out which  asteroid would be the  best place to
build a  new monitoring station.  A monitoring station can  detect any
asteroid to which it has direct line  of sight - that is, there cannot
be another asteroid exactly between them. This line of sight can be at
any angle, not just lines aligned  to the grid or diagonally. The best
location is the  asteroid that can detect the largest  number of other
asteroids.

For example, consider the following map:
#+begin_example
.#..#
.....
#####
....#
...##
#+end_example

The best  location for  a new  monitoring station on  this map  is the
highlighted asteroid  at 3,4 because  it can detect 8  asteroids, more
than any  other location. (The only  asteroid it cannot detect  is the
one at 1,0;  its view of this  asteroid is blocked by  the asteroid at
2,2.) All  other asteroids are worse  locations; they can detect  7 or
fewer  other  asteroids. Here  is  the  number  of other  asteroids  a
monitoring station on each asteroid could detect:
#+begin_example
.7..7
.....
67775
....7
...87
#+end_example

Here is  an asteroid  (#) and some  examples of the  ways its  line of
sight might be blocked. If there were another asteroid at the location
of  a capital  letter,  the locations  marked  with the  corresponding
lowercase letter would be blocked and could not be detected:
#+begin_example
#.........
...A......
...B..a...
.EDCG....a
..F.c.b...
.....c....
..efd.c.gb
.......c..
....f...c.
...e..d..c
#+end_example

Here are some larger examples:
#+begin_example
    Best is 5,8 with 33 other asteroids detected:

    ......#.#.
    #..#.#....
    ..#######.
    .#.#.###..
    .#..#.....
    ..#....#.#
    #..#....#.
    .##.#..###
    ##...#..#.
    .#....####

    Best is 1,2 with 35 other asteroids detected:

    #.#...#.#.
    .###....#.
    .#....#...
    ##.#.#.#.#
    ....#.#.#.
    .##..###.#
    ..#...##..
    ..##....##
    ......#...
    .####.###.

    Best is 6,3 with 41 other asteroids detected:

    .#..#..###
    ####.###.#
    ....###.#.
    ..###.##.#
    ##.##.#.#.
    ....###..#
    ..#.#..#.#
    #..#.#.###
    .##...##.#
    .....#.#..

    Best is 11,13 with 210 other asteroids detected:

    .#..##.###...#######
    ##.############..##.
    .#.######.########.#
    .###.#######.####.#.
    #####.##.#.##.###.##
    ..#####..#.#########
    ####################
    #.####....###.#.#.##
    ##.#################
    #####.##.###..####..
    ..######..##.#######
    ####.##.####...##..#
    .#####..#.######.###
    ##...#.##########...
    #.##########.#######
    .####.#.###.###.#.##
    ....##.##.###..#####
    .#.#.###########.###
    #.#.#.#####.####.###
    ###.##.####.##.#..##
#+end_example

Find the  best location for a  new monitoring station. How  many other
asteroids can be detected from that location?
** TODO Day 10.2                                                  :noexport:

** TODO Day 11.1                                                  :noexport:

On the way to Jupiter, you're pulled over by the Space Police.

"Attention, unmarked  spacecraft! You are  in violation of  Space Law!
All spacecraft  must have  a clearly visible  registration identifier!
You have 24 hours to comply or be sent to Space Jail!"

Not wanting to be  sent to Space Jail, you radio back  to the Elves on
Earth for help.  Although it takes almost three hours  for their reply
signal to  reach you, they send  instructions for how to  power up the
emergency hull painting robot and even provide a small Intcode program
(your  puzzle   input)  that  will   cause  it  to  paint   your  ship
appropriately.

There's just  one problem: you  don't have an emergency  hull painting
robot.

You'll need  to build a new  emergency hull painting robot.  The robot
needs to be  able to move around  on the grid of square  panels on the
side of  your ship, detect the  color of its current  panel, and paint
its current  panel black or  white. (All  of the panels  are currently
black.)

The Intcode program will serve as  the brain of the robot. The program
uses input instructions to access the robot's camera: provide 0 if the
robot  is over  a  black panel  or  1 if  the robot  is  over a  white
panel. Then, the program will output two values:
- First, it will output a value indicating the color to paint the
  panel the robot is over: 0 means to paint the panel black, and 1
  means to paint the panel white.
- Second, it will output a value indicating the direction the robot
  should turn: 0 means it should turn left 90 degrees, and 1 means it
  should turn right 90 degrees.
  
After  the robot  turns, it  should  always move  forward exactly  one
panel. The robot starts facing up.

The robot will continue running for a while like this and halt when it
is finished  drawing. Do not  restart the Intcode computer  inside the
robot during this process.

For  example, suppose  the robot  is about  to start  running. Drawing
black  panels as  ., white  panels as  #, and  the robot  pointing the
direction it is  facing (< ^ >  v), the initial state  and region near
the robot looks like this:
#+begin_example
.....
.....
..^..
.....
.....
#+end_example

The  panel under  the robot  (not visible  here because  a ^  is shown
instead) is  also black, and so  any input instructions at  this point
should be  provided 0. Suppose  the robot eventually outputs  1 (paint
white) and then  0 (turn left). After taking these  actions and moving
forward one panel, the region now looks like this:
#+begin_example
.....
.....
.<#..
.....
.....
#+end_example

Input instructions should  still be provided 0. Next,  the robot might
output 0 (paint black) and then 0 (turn left):
#+begin_example
.....
.....
..#..
.v...
.....
#+end_example

After more outputs (1,0, 1,0):
#+begin_example
.....
.....
..^..
.##..
.....
#+end_example

The robot  is now back where  it started, but  because it is now  on a
white panel,  input instructions should  be provided 1.  After several
more outputs (0,1, 1,0, 1,0), the area looks like this:
#+begin_example
.....
..<#.
...#.
.##..
.....
#+end_example

Before you deploy  the robot, you should probably have  an estimate of
the area it  will cover: specifically, you need to  know the number of
panels it  paints at least once,  regardless of color. In  the example
above,  the robot  painted 6  panels at  least once.  (It painted  its
starting panel  twice, but that panel  is still only counted  once; it
also never painted the panel it ended on.)

Build a new emergency hull painting  robot and run the Intcode program
on it. How many panels does it paint at least once?
** TODO Day 11.2                                                  :noexport:

** TODO Day 12.1                                                  :noexport:

The  space near  Jupiter is  not a  very safe  place; you  need to  be
careful of a big distracting red  spot, extreme radiation, and a whole
lot of moons swirling around. You decide to start by tracking the four
largest moons: Io, Europa, Ganymede, and Callisto.

After a  brief scan,  you calculate  the position  of each  moon (your
puzzle input). You just need to simulate their motion so you can avoid
them.

Each  moon  has  a  3-dimensional  position   (x,  y,  and  z)  and  a
3-dimensional velocity.  The position  of each moon  is given  in your
scan; the x, y, and z velocity of each moon starts at 0.

Simulate the motion of the moons in time steps. Within each time step,
first update  the velocity  of every moon  by applying  gravity. Then,
once all moons'  velocities have been updated, update  the position of
every moon by applying velocity. Time  progresses by one step once all
of the positions are updated.

To apply  gravity, consider every pair  of moons. On each  axis (x, y,
and z), the velocity of each moon  changes by exactly +1 or -1 to pull
the moons together.  For example, if Ganymede has an  x position of 3,
and Callisto has a x position of 5, then Ganymede's x velocity changes
by +1 (because 5 > 3) and Callisto's x velocity changes by -1 (because
3 < 5).  However, if the positions  on a given axis are  the same, the
velocity on that axis does not change for that pair of moons.

Once  all gravity  has been  applied, apply  velocity: simply  add the
velocity of each moon to its  own position. For example, if Europa has
a position of x=1, y=2, z=3 and  a velocity of x=-2, y=0,z=3, then its
new position would be x=-1, y=2, z=6. This process does not modify the
velocity of any moon.

For example, suppose your scan reveals the following positions:
#+begin_example
<x=-1, y=0, z=2>
<x=2, y=-10, z=-7>
<x=4, y=-8, z=8>
<x=3, y=5, z=-1>
#+end_example

Simulating the motion of these moons would produce the following:
#+begin_example
After 0 steps:
pos=<x=-1, y=  0, z= 2>, vel=<x= 0, y= 0, z= 0>
pos=<x= 2, y=-10, z=-7>, vel=<x= 0, y= 0, z= 0>
pos=<x= 4, y= -8, z= 8>, vel=<x= 0, y= 0, z= 0>
pos=<x= 3, y=  5, z=-1>, vel=<x= 0, y= 0, z= 0>

After 1 step:
pos=<x= 2, y=-1, z= 1>, vel=<x= 3, y=-1, z=-1>
pos=<x= 3, y=-7, z=-4>, vel=<x= 1, y= 3, z= 3>
pos=<x= 1, y=-7, z= 5>, vel=<x=-3, y= 1, z=-3>
pos=<x= 2, y= 2, z= 0>, vel=<x=-1, y=-3, z= 1>

After 2 steps:
pos=<x= 5, y=-3, z=-1>, vel=<x= 3, y=-2, z=-2>
pos=<x= 1, y=-2, z= 2>, vel=<x=-2, y= 5, z= 6>
pos=<x= 1, y=-4, z=-1>, vel=<x= 0, y= 3, z=-6>
pos=<x= 1, y=-4, z= 2>, vel=<x=-1, y=-6, z= 2>

After 3 steps:
pos=<x= 5, y=-6, z=-1>, vel=<x= 0, y=-3, z= 0>
pos=<x= 0, y= 0, z= 6>, vel=<x=-1, y= 2, z= 4>
pos=<x= 2, y= 1, z=-5>, vel=<x= 1, y= 5, z=-4>
pos=<x= 1, y=-8, z= 2>, vel=<x= 0, y=-4, z= 0>

After 4 steps:
pos=<x= 2, y=-8, z= 0>, vel=<x=-3, y=-2, z= 1>
pos=<x= 2, y= 1, z= 7>, vel=<x= 2, y= 1, z= 1>
pos=<x= 2, y= 3, z=-6>, vel=<x= 0, y= 2, z=-1>
pos=<x= 2, y=-9, z= 1>, vel=<x= 1, y=-1, z=-1>

After 5 steps:
pos=<x=-1, y=-9, z= 2>, vel=<x=-3, y=-1, z= 2>
pos=<x= 4, y= 1, z= 5>, vel=<x= 2, y= 0, z=-2>
pos=<x= 2, y= 2, z=-4>, vel=<x= 0, y=-1, z= 2>
pos=<x= 3, y=-7, z=-1>, vel=<x= 1, y= 2, z=-2>

After 6 steps:
pos=<x=-1, y=-7, z= 3>, vel=<x= 0, y= 2, z= 1>
pos=<x= 3, y= 0, z= 0>, vel=<x=-1, y=-1, z=-5>
pos=<x= 3, y=-2, z= 1>, vel=<x= 1, y=-4, z= 5>
pos=<x= 3, y=-4, z=-2>, vel=<x= 0, y= 3, z=-1>

After 7 steps:
pos=<x= 2, y=-2, z= 1>, vel=<x= 3, y= 5, z=-2>
pos=<x= 1, y=-4, z=-4>, vel=<x=-2, y=-4, z=-4>
pos=<x= 3, y=-7, z= 5>, vel=<x= 0, y=-5, z= 4>
pos=<x= 2, y= 0, z= 0>, vel=<x=-1, y= 4, z= 2>

After 8 steps:
pos=<x= 5, y= 2, z=-2>, vel=<x= 3, y= 4, z=-3>
pos=<x= 2, y=-7, z=-5>, vel=<x= 1, y=-3, z=-1>
pos=<x= 0, y=-9, z= 6>, vel=<x=-3, y=-2, z= 1>
pos=<x= 1, y= 1, z= 3>, vel=<x=-1, y= 1, z= 3>

After 9 steps:
pos=<x= 5, y= 3, z=-4>, vel=<x= 0, y= 1, z=-2>
pos=<x= 2, y=-9, z=-3>, vel=<x= 0, y=-2, z= 2>
pos=<x= 0, y=-8, z= 4>, vel=<x= 0, y= 1, z=-2>
pos=<x= 1, y= 1, z= 5>, vel=<x= 0, y= 0, z= 2>

After 10 steps:
pos=<x= 2, y= 1, z=-3>, vel=<x=-3, y=-2, z= 1>
pos=<x= 1, y=-8, z= 0>, vel=<x=-1, y= 1, z= 3>
pos=<x= 3, y=-6, z= 1>, vel=<x= 3, y= 2, z=-3>
pos=<x= 2, y= 0, z= 4>, vel=<x= 1, y=-1, z=-1>
#+end_example

Then, it might  help to calculate the total energy  in the system. The
total energy for  a single moon is its potential  energy multiplied by
its  kinetic energy.  A  moon's potential  energy is  the  sum of  the
absolute values  of its  x, y,  and z  position coordinates.  A moon's
kinetic  energy is  the sum  of the  absolute values  of its  velocity
coordinates.  Below, each  line shows  the calculations  for a  moon's
potential energy (pot), kinetic energy (kin), and total energy:
#+begin_example
Energy after 10 steps:
pot: 2 + 1 + 3 =  6;   kin: 3 + 2 + 1 = 6;   total:  6 * 6 = 36
pot: 1 + 8 + 0 =  9;   kin: 1 + 1 + 3 = 5;   total:  9 * 5 = 45
pot: 3 + 6 + 1 = 10;   kin: 3 + 2 + 3 = 8;   total: 10 * 8 = 80
pot: 2 + 0 + 4 =  6;   kin: 1 + 1 + 1 = 3;   total:  6 * 3 = 18
Sum of total energy: 36 + 45 + 80 + 18 = 179
#+end_example

In the above  example, adding together the total energy  for all moons
after 10 steps produces the total energy in the system, 179.

Here's a second example:
#+begin_example
<x=-8, y=-10, z=0>
<x=5, y=5, z=10>
<x=2, y=-7, z=3>
<x=9, y=-8, z=-3>
#+end_example

Every ten steps of simulation for 100 steps produces:
#+begin_example
After 0 steps:
pos=<x= -8, y=-10, z=  0>, vel=<x=  0, y=  0, z=  0>
pos=<x=  5, y=  5, z= 10>, vel=<x=  0, y=  0, z=  0>
pos=<x=  2, y= -7, z=  3>, vel=<x=  0, y=  0, z=  0>
pos=<x=  9, y= -8, z= -3>, vel=<x=  0, y=  0, z=  0>

After 10 steps:
pos=<x= -9, y=-10, z=  1>, vel=<x= -2, y= -2, z= -1>
pos=<x=  4, y= 10, z=  9>, vel=<x= -3, y=  7, z= -2>
pos=<x=  8, y=-10, z= -3>, vel=<x=  5, y= -1, z= -2>
pos=<x=  5, y=-10, z=  3>, vel=<x=  0, y= -4, z=  5>

After 20 steps:
pos=<x=-10, y=  3, z= -4>, vel=<x= -5, y=  2, z=  0>
pos=<x=  5, y=-25, z=  6>, vel=<x=  1, y=  1, z= -4>
pos=<x= 13, y=  1, z=  1>, vel=<x=  5, y= -2, z=  2>
pos=<x=  0, y=  1, z=  7>, vel=<x= -1, y= -1, z=  2>

After 30 steps:
pos=<x= 15, y= -6, z= -9>, vel=<x= -5, y=  4, z=  0>
pos=<x= -4, y=-11, z=  3>, vel=<x= -3, y=-10, z=  0>
pos=<x=  0, y= -1, z= 11>, vel=<x=  7, y=  4, z=  3>
pos=<x= -3, y= -2, z=  5>, vel=<x=  1, y=  2, z= -3>

After 40 steps:
pos=<x= 14, y=-12, z= -4>, vel=<x= 11, y=  3, z=  0>
pos=<x= -1, y= 18, z=  8>, vel=<x= -5, y=  2, z=  3>
pos=<x= -5, y=-14, z=  8>, vel=<x=  1, y= -2, z=  0>
pos=<x=  0, y=-12, z= -2>, vel=<x= -7, y= -3, z= -3>

After 50 steps:
pos=<x=-23, y=  4, z=  1>, vel=<x= -7, y= -1, z=  2>
pos=<x= 20, y=-31, z= 13>, vel=<x=  5, y=  3, z=  4>
pos=<x= -4, y=  6, z=  1>, vel=<x= -1, y=  1, z= -3>
pos=<x= 15, y=  1, z= -5>, vel=<x=  3, y= -3, z= -3>

After 60 steps:
pos=<x= 36, y=-10, z=  6>, vel=<x=  5, y=  0, z=  3>
pos=<x=-18, y= 10, z=  9>, vel=<x= -3, y= -7, z=  5>
pos=<x=  8, y=-12, z= -3>, vel=<x= -2, y=  1, z= -7>
pos=<x=-18, y= -8, z= -2>, vel=<x=  0, y=  6, z= -1>

After 70 steps:
pos=<x=-33, y= -6, z=  5>, vel=<x= -5, y= -4, z=  7>
pos=<x= 13, y= -9, z=  2>, vel=<x= -2, y= 11, z=  3>
pos=<x= 11, y= -8, z=  2>, vel=<x=  8, y= -6, z= -7>
pos=<x= 17, y=  3, z=  1>, vel=<x= -1, y= -1, z= -3>

After 80 steps:
pos=<x= 30, y= -8, z=  3>, vel=<x=  3, y=  3, z=  0>
pos=<x= -2, y= -4, z=  0>, vel=<x=  4, y=-13, z=  2>
pos=<x=-18, y= -7, z= 15>, vel=<x= -8, y=  2, z= -2>
pos=<x= -2, y= -1, z= -8>, vel=<x=  1, y=  8, z=  0>

After 90 steps:
pos=<x=-25, y= -1, z=  4>, vel=<x=  1, y= -3, z=  4>
pos=<x=  2, y= -9, z=  0>, vel=<x= -3, y= 13, z= -1>
pos=<x= 32, y= -8, z= 14>, vel=<x=  5, y= -4, z=  6>
pos=<x= -1, y= -2, z= -8>, vel=<x= -3, y= -6, z= -9>

After 100 steps:
pos=<x=  8, y=-12, z= -9>, vel=<x= -7, y=  3, z=  0>
pos=<x= 13, y= 16, z= -3>, vel=<x=  3, y=-11, z= -5>
pos=<x=-29, y=-11, z= -1>, vel=<x= -3, y=  7, z=  4>
pos=<x= 16, y=-13, z= 23>, vel=<x=  7, y=  1, z=  1>

Energy after 100 steps:
pot:  8 + 12 +  9 = 29;   kin: 7 +  3 + 0 = 10;   total: 29 * 10 = 290
pot: 13 + 16 +  3 = 32;   kin: 3 + 11 + 5 = 19;   total: 32 * 19 = 608
pot: 29 + 11 +  1 = 41;   kin: 3 +  7 + 4 = 14;   total: 41 * 14 = 574
pot: 16 + 13 + 23 = 52;   kin: 7 +  1 + 1 =  9;   total: 52 *  9 = 468
Sum of total energy: 290 + 608 + 574 + 468 = 1940
#+end_example

What is the total energy in the system after simulating the moons
given in your scan for 1000 steps?
** TODO Day 12.2                                                  :noexport:

** TODO Day 13.1                                                  :noexport:

As you ponder the solitude of space and the ever-increasing three-hour
roundtrip  for messages  between you  and Earth,  you notice  that the
Space Mail  Indicator Light is  blinking. To  help keep you  sane, the
Elves have sent you a care package.

It's  a new  game for  the ship's  arcade cabinet!  Unfortunately, the
arcade is all the  way on the other end of the  ship. Surely, it won't
be  hard  to  build your  own  -  the  care  package even  comes  with
schematics.

The arcade cabinet runs Intcode software  like the game the Elves sent
(your  puzzle input).  It has  a primitive  screen capable  of drawing
square tiles  on a grid. The  software draws tiles to  the screen with
output  instructions: every  three output  instructions specify  the x
position (distance from the left), y position (distance from the top),
and tile id. The tile id is interpreted as follows:
- 0 is an empty tile. No game object appears in this tile.
- 1 is a wall tile. Walls are indestructible barriers.
- 2 is a block tile. Blocks can be broken by the ball.
- 3 is a horizontal paddle tile. The paddle is indestructible.
- 4 is a ball tile. The ball moves diagonally and bounces off objects.

For example, a sequence of output values like 1,2,3,6,5,4 would draw a
horizontal paddle tile (1 tile from the left and 2 tiles from the top)
and a ball tile (6 tiles from the left and 5 tiles from the top).

Start the game. How many block tiles are on the screen when the game
exits?
** TODO Day 13.2                                                  :noexport:

** TODO Day 14.1                                                  :noexport:

As you  approach the rings of  Saturn, your ship's low  fuel indicator
turns on. There isn't any fuel here,  but the rings have plenty of raw
material.  Perhaps  your  ship's Inter-Stellar  Refinery  Union  brand
nanofactory can turn these raw materials into fuel.

You ask  the nanofactory  to produce  a list of  the reactions  it can
perform that are  relevant to this process (your  puzzle input). Every
reaction turns some  quantities of specific input  chemicals into some
quantity of an  output chemical. Almost every chemical  is produced by
exactly one  reaction; the  only exception, ORE,  is the  raw material
input to the entire process and is not produced by a reaction.

You just need to  know how much ORE you'll need  to collect before you
can produce one unit of FUEL.

Each reaction  gives specific  quantities for  its inputs  and output;
reactions cannot be partially run,  so only whole integer multiples of
these quantities  can be used.  (It's okay to have  leftover chemicals
when you're done, though.) For example, the  reaction 1 A, 2 B, 3 C =>
2  D means  that exactly  2 units  of chemical  D can  be produced  by
consuming exactly 1 A,  2 B and 3 C. You can run  the full reaction as
many  times as  necessary;  for example,  you could  produce  10 D  by
consuming 5 A, 10 B, and 15 C.

Suppose your nanofactory produces the following list of reactions:
#+begin_example
10 ORE => 10 A
1 ORE => 1 B
7 A, 1 B => 1 C
7 A, 1 C => 1 D
7 A, 1 D => 1 E
7 A, 1 E => 1 FUEL
#+end_example

The first two reactions use only ORE as inputs; they indicate that you
can produce  as much of  chemical A as you  want (in increments  of 10
units, each 10 costing  10 ORE) and as much of chemical  B as you want
(each  costing 1  ORE).  To produce  1  FUEL,  a total  of  31 ORE  is
required: 1 ORE  to produce 1 B, then  30 more ORE to produce  the 7 +
7 + 7 + 7 = 28 A (with  2 extra A wasted) required in the reactions to
convert the B into C, C into D, D into E, and finally E into FUEL. (30
A is  produced because  its reaction  requires that  it is  created in
increments of 10.)

Or, suppose you have the following list of reactions:
#+begin_example
9 ORE => 2 A
8 ORE => 3 B
7 ORE => 5 C
3 A, 4 B => 1 AB
5 B, 7 C => 1 BC
4 C, 1 A => 1 CA
2 AB, 3 BC, 4 CA => 1 FUEL
#+end_example

The above list of reactions requires 165 ORE to produce 1 FUEL:
- Consume 45 ORE to produce 10 A.
- Consume 64 ORE to produce 24 B.
- Consume 56 ORE to produce 40 C.
- Consume 6 A, 8 B to produce 2 AB.
- Consume 15 B, 21 C to produce 3 BC.
- Consume 16 C, 4 A to produce 4 CA.
- Consume 2 AB, 3 BC, 4 CA to produce 1 FUEL.

Here are some larger examples:
#+begin_example
    13312 ORE for 1 FUEL:

    157 ORE => 5 NZVS
    165 ORE => 6 DCFZ
    44 XJWVT, 5 KHKGT, 1 QDVJ, 29 NZVS, 9 GPVTF, 48 HKGWZ => 1 FUEL
    12 HKGWZ, 1 GPVTF, 8 PSHF => 9 QDVJ
    179 ORE => 7 PSHF
    177 ORE => 5 HKGWZ
    7 DCFZ, 7 PSHF => 2 XJWVT
    165 ORE => 2 GPVTF
    3 DCFZ, 7 NZVS, 5 HKGWZ, 10 PSHF => 8 KHKGT

    180697 ORE for 1 FUEL:

    2 VPVL, 7 FWMGM, 2 CXFTF, 11 MNCFX => 1 STKFG
    17 NVRVD, 3 JNWZP => 8 VPVL
    53 STKFG, 6 MNCFX, 46 VJHF, 81 HVMC, 68 CXFTF, 25 GNMV => 1 FUEL
    22 VJHF, 37 MNCFX => 5 FWMGM
    139 ORE => 4 NVRVD
    144 ORE => 7 JNWZP
    5 MNCFX, 7 RFSQX, 2 FWMGM, 2 VPVL, 19 CXFTF => 3 HVMC
    5 VJHF, 7 MNCFX, 9 VPVL, 37 CXFTF => 6 GNMV
    145 ORE => 6 MNCFX
    1 NVRVD => 8 CXFTF
    1 VJHF, 6 MNCFX => 4 RFSQX
    176 ORE => 6 VJHF

    2210736 ORE for 1 FUEL:

    171 ORE => 8 CNZTR
    7 ZLQW, 3 BMBT, 9 XCVML, 26 XMNCP, 1 WPTQ, 2 MZWV, 1 RJRHP => 4 PLWSL
    114 ORE => 4 BHXH
    14 VRPVC => 6 BMBT
    6 BHXH, 18 KTJDG, 12 WPTQ, 7 PLWSL, 31 FHTLT, 37 ZDVW => 1 FUEL
    6 WPTQ, 2 BMBT, 8 ZLQW, 18 KTJDG, 1 XMNCP, 6 MZWV, 1 RJRHP => 6 FHTLT
    15 XDBXC, 2 LTCX, 1 VRPVC => 6 ZLQW
    13 WPTQ, 10 LTCX, 3 RJRHP, 14 XMNCP, 2 MZWV, 1 ZLQW => 1 ZDVW
    5 BMBT => 4 WPTQ
    189 ORE => 9 KTJDG
    1 MZWV, 17 XDBXC, 3 XCVML => 2 XMNCP
    12 VRPVC, 27 CNZTR => 2 XDBXC
    15 KTJDG, 12 BHXH => 5 XCVML
    3 BHXH, 2 VRPVC => 7 MZWV
    121 ORE => 7 VRPVC
    7 XCVML => 6 RJRHP
    5 BHXH, 4 VRPVC => 5 LTCX
#+end_example

Given the list of reactions in  your puzzle input, what is the minimum
amount of ORE required to produce exactly 1 FUEL?
** TODO Day 14.2                                                  :noexport:

** TODO Day 15.1                                                  :noexport:

Out here in deep space, many things can go wrong. Fortunately, many of
those things have indicator lights. Unfortunately, one of those lights
is lit: the oxygen system for part of the ship has failed!

According to the readouts, the oxygen system must have failed days ago
after  a rupture  in oxygen  tank two;  that section  of the  ship was
automatically sealed once oxygen levels went dangerously low. A single
remotely-operated  repair droid  is your  only option  for fixing  the
oxygen system.

The  Elves' care  package  included an  Intcode  program (your  puzzle
input)  that you  can use  to remotely  control the  repair droid.  By
running that  program, you can direct  the repair droid to  the oxygen
system and fix the problem.

The  remote control  program executes  the following  steps in  a loop
forever:
- Accept a movement command via an input instruction.
- Send the movement command to the repair droid.
- Wait for the repair droid to finish the movement operation.
- Report on the status of the repair droid via an output instruction.

Only four movement commands are understood: north (1), south (2), west
(3), and east (4). Any other  command is invalid. The movements differ
in direction, but not in distance: in a long enough east-west hallway,
a series of commands like 4,4,4,4,3,3,3,3 would leave the repair droid
back where it started.

The repair droid can reply with any of the following status codes:
- 0: The repair droid hit a wall. Its position has not changed.
- 1: The repair droid has moved one step in the requested direction.
- 2: The repair droid has moved one step in the requested direction;
  its new position is the location of the oxygen system.
  
You don't  know anything about the  area around the repair  droid, but
you can figure it out by watching the status codes.

For example, we can draw the area  using D for the droid, # for walls,
. for locations the droid can traverse, and empty space for unexplored
locations. Then, the initial state looks like this:
#+begin_example
      
      
   D  
      
      
#+end_example
To make the droid go north, send it  1. If it replies with 0, you know
that location is a wall and that the droid didn't move:
#+begin_example
      
   #  
   D  
      
      
#+end_example
To move east, send 4; a reply of 1 means the movement was successful:
#+begin_example
      
   #  
   .D 
      
      
#+end_example
Then, perhaps attempts to move north  (1), south (2), and east (4) are
all met with replies of 0:
#+begin_example
      
   ## 
   .D#
    # 
      
#+end_example
Now, you  know the  repair droid is  in a dead  end. Backtrack  with 3
(which you already know will get a reply of 1 because you already know
that location is open):
#+begin_example
      
   ## 
   D.#
    # 
      
#+end_example
Then, perhaps west (3) gets a reply of 0, south (2) gets a reply of 1,
south again (2) gets  a reply of 0, and then west (3)  gets a reply of
2:
#+begin_example
      
   ## 
  #..#
  D.# 
   #  
#+end_example
Now,  because of  the reply  of 2,  you know  you've found  the oxygen
system! In  this example,  it was  only 2 moves  away from  the repair
droid's starting position.

What is the fewest number of movement commands required to move the
repair droid from its starting position to the location of the oxygen
system?
** TODO Day 15.2                                                  :noexport:

** TODO Day 16.1                                                  :noexport:

You're 3/4ths of the way through the gas giants. Not only do roundtrip
signals to Earth take five hours,  but the signal quality is quite bad
as  well. You  can  clean  up the  signal  with  the Flawed  Frequency
Transmission algorithm, or FFT.

As input,  FFT takes  a list  of numbers. In  the signal  you received
(your puzzle  input), each number is  a single digit: data  like 15243
represents the sequence 1, 5, 2, 4, 3.

FFT  operates  in repeated  phases.  In  each  phase,  a new  list  is
constructed with the  same length as the input list.  This new list is
also used as the input for the next phase.

Each element  in the new list  is built by multiplying  every value in
the input list  by a value in  a repeating pattern and  then adding up
the results. So, if the input list were  9, 8, 7, 6, 5 and the pattern
for a  given element were  1, 2, 3,  the result would  be 9*1 +  8*2 +
7*3 + 6*1 + 5*2 (with each input element on the left and each value in
the repeating pattern on the right of each multiplication). Then, only
the ones digit is kept: 38 becomes 8, -17 becomes 7, and so on.

While each  element in  the output  array uses all  of the  same input
array elements, the  actual repeating pattern to use  depends on which
output  element is  being calculated.  The base  pattern is  0, 1,  0,
-1. Then, repeat each value in the  pattern a number of times equal to
the position in the output list  being considered. Repeat once for the
first element, twice for the second element, three times for the third
element, and  so on. So,  if the third element  of the output  list is
being calculated, repeating  the values would produce: 0, 0,  0, 1, 1,
1, 0, 0, 0, -1, -1, -1.

When applying the pattern, skip the very first value exactly once. (In
other words, offset the whole pattern left by one.) So, for the second
element of the output list, the actual pattern used would be: 0, 1, 1,
0, 0, -1, -1, 0, 0, 1, 1, 0, 0, -1, -1, ....

After using this process to calculate each element of the output list,
the phase is  complete, and the output  list of this phase  is used as
the new input list for the next phase, if any.

Given the input signal 12345678, below  are four phases of FFT. Within
each phase, each output digit is  calculated on a single line with the
result at the far right; each multiplication operation shows the input
digit on the left and the pattern value on the right:
#+begin_example
Input signal: 12345678

1*1  + 2*0  + 3*-1 + 4*0  + 5*1  + 6*0  + 7*-1 + 8*0  = 4
1*0  + 2*1  + 3*1  + 4*0  + 5*0  + 6*-1 + 7*-1 + 8*0  = 8
1*0  + 2*0  + 3*1  + 4*1  + 5*1  + 6*0  + 7*0  + 8*0  = 2
1*0  + 2*0  + 3*0  + 4*1  + 5*1  + 6*1  + 7*1  + 8*0  = 2
1*0  + 2*0  + 3*0  + 4*0  + 5*1  + 6*1  + 7*1  + 8*1  = 6
1*0  + 2*0  + 3*0  + 4*0  + 5*0  + 6*1  + 7*1  + 8*1  = 1
1*0  + 2*0  + 3*0  + 4*0  + 5*0  + 6*0  + 7*1  + 8*1  = 5
1*0  + 2*0  + 3*0  + 4*0  + 5*0  + 6*0  + 7*0  + 8*1  = 8

After 1 phase: 48226158

4*1  + 8*0  + 2*-1 + 2*0  + 6*1  + 1*0  + 5*-1 + 8*0  = 3
4*0  + 8*1  + 2*1  + 2*0  + 6*0  + 1*-1 + 5*-1 + 8*0  = 4
4*0  + 8*0  + 2*1  + 2*1  + 6*1  + 1*0  + 5*0  + 8*0  = 0
4*0  + 8*0  + 2*0  + 2*1  + 6*1  + 1*1  + 5*1  + 8*0  = 4
4*0  + 8*0  + 2*0  + 2*0  + 6*1  + 1*1  + 5*1  + 8*1  = 0
4*0  + 8*0  + 2*0  + 2*0  + 6*0  + 1*1  + 5*1  + 8*1  = 4
4*0  + 8*0  + 2*0  + 2*0  + 6*0  + 1*0  + 5*1  + 8*1  = 3
4*0  + 8*0  + 2*0  + 2*0  + 6*0  + 1*0  + 5*0  + 8*1  = 8

After 2 phases: 34040438

3*1  + 4*0  + 0*-1 + 4*0  + 0*1  + 4*0  + 3*-1 + 8*0  = 0
3*0  + 4*1  + 0*1  + 4*0  + 0*0  + 4*-1 + 3*-1 + 8*0  = 3
3*0  + 4*0  + 0*1  + 4*1  + 0*1  + 4*0  + 3*0  + 8*0  = 4
3*0  + 4*0  + 0*0  + 4*1  + 0*1  + 4*1  + 3*1  + 8*0  = 1
3*0  + 4*0  + 0*0  + 4*0  + 0*1  + 4*1  + 3*1  + 8*1  = 5
3*0  + 4*0  + 0*0  + 4*0  + 0*0  + 4*1  + 3*1  + 8*1  = 5
3*0  + 4*0  + 0*0  + 4*0  + 0*0  + 4*0  + 3*1  + 8*1  = 1
3*0  + 4*0  + 0*0  + 4*0  + 0*0  + 4*0  + 3*0  + 8*1  = 8

After 3 phases: 03415518

0*1  + 3*0  + 4*-1 + 1*0  + 5*1  + 5*0  + 1*-1 + 8*0  = 0
0*0  + 3*1  + 4*1  + 1*0  + 5*0  + 5*-1 + 1*-1 + 8*0  = 1
0*0  + 3*0  + 4*1  + 1*1  + 5*1  + 5*0  + 1*0  + 8*0  = 0
0*0  + 3*0  + 4*0  + 1*1  + 5*1  + 5*1  + 1*1  + 8*0  = 2
0*0  + 3*0  + 4*0  + 1*0  + 5*1  + 5*1  + 1*1  + 8*1  = 9
0*0  + 3*0  + 4*0  + 1*0  + 5*0  + 5*1  + 1*1  + 8*1  = 4
0*0  + 3*0  + 4*0  + 1*0  + 5*0  + 5*0  + 1*1  + 8*1  = 9
0*0  + 3*0  + 4*0  + 1*0  + 5*0  + 5*0  + 1*0  + 8*1  = 8

After 4 phases: 01029498
#+end_example

Here are  the first eight  digits of the  final output list  after 100
phases for some larger inputs:
- 80871224585914546619083218645595 becomes 24176176.
- 19617804207202209144916044189917 becomes 73745418.
- 69317163492948606335995924319873 becomes 52432133.

After 100 phases of FFT, what are  the first eight digits in the final
output list?
** TODO Day 16.2                                                  :noexport:

** TODO Day 17.1                                                  :noexport:

An  early  warning   system  detects  an  incoming   solar  flare  and
automatically      activates      the      ship's      electromagnetic
shield.  Unfortunately, this  has cut  off  the Wi-Fi  for many  small
robots  that, unaware  of the  impending  danger, are  now trapped  on
exterior scaffolding on the unsafe side of the shield. To rescue them,
you'll have to act quickly!

The only  tools at your  disposal are some  wired cameras and  a small
vacuum  robot currently  asleep  at its  charging  station. The  video
quality is poor, but the vacuum robot has a needlessly bright LED that
makes it easy to spot no matter where it is.

An  Intcode  program,  the  Aft Scaffolding  Control  and  Information
Interface (ASCII, your  puzzle input), provides access  to the cameras
and the vacuum  robot. Currently, because the vacuum  robot is asleep,
you can only access the cameras.

Running the  ASCII program on  your Intcode computer will  provide the
current view of the scaffolds.  This is output, purely coincidentally,
as ASCII code: 35 means #, 46 means  ., 10 starts a new line of output
below the current one, and so on. (Within a line, characters are drawn
left-to-right.)

In the  camera output, # represents  a scaffold and .  represents open
space. The  vacuum robot  is visible  as ^,  v, <,  or >  depending on
whether it is facing up, down, left, or right respectively. When drawn
like this,  the vacuum robot  is always on  a scaffold; if  the vacuum
robot ever walks  off of a scaffold and begins  tumbling through space
uncontrollably, it will instead be visible as X.

In general,  the scaffold forms  a path,  but it sometimes  loops back
onto itself. For example, suppose you  can see the following view from
the cameras:
#+begin_example
..#..........
..#..........
#######...###
#.#...#...#.#
#############
..#...#...#..
..#####...^..
#+end_example

Here, the vacuum robot,  ^ is facing up and sitting at  one end of the
scaffold near  the bottom-right of  the image. The  scaffold continues
up, loops across itself several times, and ends at the top-left of the
image.

The first  step is to calibrate  the cameras by getting  the alignment
parameters   of  some   well-defined  points.   Locate  all   scaffold
intersections;  for  each, its  alignment  parameter  is the  distance
between its left edge and the left  edge of the view multiplied by the
distance between its top edge and the  top edge of the view. Here, the
intersections from the above image are marked O:
#+begin_example
..#..........
..#..........
##O####...###
#.#...#...#.#
##O###O###O##
..#...#...#..
..#####...^..
#+end_example

For these intersections:
- The top-left intersection is 2 units from the left of the image and
  2 units from the top of the image, so its alignment parameter is 2 *
  2 = 4.
- The bottom-left intersection is 2 units from the left and 4 units
  from the top, so its alignment parameter is 2 * 4 = 8.
- The bottom-middle intersection is 6 from the left and 4 from the
  top, so its alignment parameter is 24.
- The bottom-right intersection's alignment parameter is 40.

To  calibrate  the  cameras,  you   need  the  sum  of  the  alignment
parameters. In the above example, this is 76.

Run your ASCII program. What is the sum of the alignment parameters
for the scaffold intersections?
** TODO Day 17.2                                                  :noexport:

** TODO Day 18.1                                                  :noexport:

As you approach  Neptune, a planetary security system  detects you and
activates a  giant tractor beam on  Triton! You have no  choice but to
land.

A  scan of  the local  area reveals  only one  interesting feature:  a
massive underground  vault. You  generate a map  of the  tunnels (your
puzzle input). The tunnels are too narrow to move diagonally.

Only  one entrance  (marked  @)  is present  among  the open  passages
(marked .) and  stone walls (#), but you also  detect an assortment of
keys  (shown  as lowercase  letters)  and  doors (shown  as  uppercase
letters). Keys of a  given letter open the door of  the same letter: a
opens A, b opens  B, and so on. You aren't sure which  key you need to
disable the tractor beam, so you'll need to collect all of them.

For example, suppose you have the following map:
#+begin_example
#########
#b.A.@.a#
#########
#+end_example

Starting from the  entrance (@), you can only access  a large door (A)
and a key  (a). Moving toward the  door doesn't help you,  but you can
move 2 steps to collect the key, unlocking A in the process:
#+begin_example
#########
#b.....@#
#########
#+end_example

Then, you can move 6 steps to collect the only other key, b:
#+begin_example
#########
#@......#
#########
#+end_example

So, collecting every key took a total of 8 steps.

Here is a larger example:
#+begin_example
########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################
#+end_example

The only reasonable move is to take key a and unlock door A:
#+begin_example
########################
#f.D.E.e.C.b.....@.B.c.#
######################.#
#d.....................#
########################
#+end_example

Then, do the same with key b:
#+begin_example
########################
#f.D.E.e.C.@.........c.#
######################.#
#d.....................#
########################
#+end_example

...and the same with key c:
#+begin_example
########################
#f.D.E.e.............@.#
######################.#
#d.....................#
########################
#+end_example

Now, you have  a choice between keys  d and e. While key  e is closer,
collecting it now would be slower  in the long run than collecting key
d first, so that's the best choice:
#+begin_example
########################
#f...E.e...............#
######################.#
#@.....................#
########################
#+end_example

Finally, collect key e to unlock door  E, then collect key f, taking a
grand total of 86 steps.

Here are a few more examples:
#+begin_example
    ########################
    #...............b.C.D.f#
    #.######################
    #.....@.a.B.c.d.A.e.F.g#
    ########################

    Shortest path is 132 steps: b, a, c, d, f, e, g

    #################
    #i.G..c...e..H.p#
    ########.########
    #j.A..b...f..D.o#
    ########@########
    #k.E..a...g..B.n#
    ########.########
    #l.F..d...h..C.m#
    #################

    Shortest paths are 136 steps;
    one is: a, f, b, j, g, n, h, d, l, o, e, p, c, i, k, m

    ########################
    #@..............ac.GI.b#
    ###d#e#f################
    ###A#B#C################
    ###g#h#i################
    ########################

    Shortest paths are 81 steps; one is: a, c, f, i, d, g, b, e, h
#+end_example

How many steps is the shortest path that collects all of the keys?
** TODO Day 18.2                                                  :noexport:

** TODO Day 19.1                                                  :noexport:

Unsure of  the state of  Santa's ship,  you borrowed the  tractor beam
technology from Triton. Time to test it out.

When you're safely  away from anything else, you  activate the tractor
beam, but nothing  happens. It's hard to tell whether  it's working if
there's nothing  to use it  on. Fortunately, your ship's  drone system
can be configured  to deploy a drone to specific  coordinates and then
check whether it's being pulled. There's even an Intcode program (your
puzzle input) that gives you access to the drone system.

The  program uses  two  input  instructions to  request  the  X and  Y
position to which  the drone should be deployed.  Negative numbers are
invalid and  will confuse  the drone;  all numbers  should be  zero or
positive.

Then, the program  will output whether the drone is  stationary (0) or
being pulled by something (1). For example, the coordinate X=0, Y=0 is
directly in  front of the tractor  beam emitter, so the  drone control
program will always report 1 at that location.

To better understand  the tractor beam, it is important  to get a good
picture of  the beam itself. For  example, suppose you scan  the 10x10
grid of points closest to the emitter:
#+begin_example
       X
  0->      9
 0#.........
 |.#........
 v..##......
  ...###....
  ....###...
Y .....####.
  ......####
  ......####
  .......###
 9........##
#+end_example

In this example, the number of  points affected by the tractor beam in
the 10x10 area closest to the emitter is 27.

However, you'll need to scan a  larger area to understand the shape of
the beam.  How many  points are  affected by the  tractor beam  in the
50x50 area closest to the emitter? (For  each of X and Y, this will be
0 through 49.)
** TODO Day 19.2                                                  :noexport:

** TODO Day 20.1                                                  :noexport:

You notice a  strange pattern on the surface of  Pluto and land nearby
to get a closer look. Upon  closer inspection, you realize you've come
across one  of the famous  space-warping mazes of the  long-lost Pluto
civilization!

Because there isn't much space on Pluto, the civilization that used to
live   here    thrived   by    inventing   a   method    for   folding
spacetime. Although the technology is no longer understood, mazes like
this one  provide a small  glimpse into the  daily life of  an ancient
Pluto citizen.

This maze  is shaped like a  donut. Portals along the  inner and outer
edge of  the donut  can instantly  teleport you from  one side  to the
other. For example:
#+begin_example
         A           
         A           
  #######.#########  
  #######.........#  
  #######.#######.#  
  #######.#######.#  
  #######.#######.#  
  #####  B    ###.#  
BC...##  C    ###.#  
  ##.##       ###.#  
  ##...DE  F  ###.#  
  #####    G  ###.#  
  #########.#####.#  
DE..#######...###.#  
  #.#########.###.#  
FG..#########.....#  
  ###########.#####  
             Z       
             Z       
#+end_example

This  map  of  the  maze  shows solid  walls  (#)  and  open  passages
(.). Every maze on Pluto has a start (the open tile next to AA) and an
end (the open tile next to ZZ). Mazes on Pluto also have portals; this
maze has three pairs of portals: BC,  DE, and FG. When on an open tile
next to one of  these labels, a single step can take  you to the other
tile with the  same label. (You can  only walk on .  tiles; labels and
empty space are not traversable.)

One path through the maze doesn't require any portals. Starting at AA,
you could go down 1, right 8, down 12, left 4, and down 1 to reach ZZ,
a total of 26 steps.

However, there is a shorter path: You  could walk from AA to the inner
BC portal (4 steps), warp to the outer BC portal (1 step), walk to the
inner DE (6 steps),  warp to the outer DE (1 step),  walk to the outer
FG (4 steps), warp to the inner FG (1 step), and finally walk to ZZ (6
steps). In total, this is only 23 steps.

Here is a larger example:
#+begin_example
                   A               
                   A               
  #################.#############  
  #.#...#...................#.#.#  
  #.#.#.###.###.###.#########.#.#  
  #.#.#.......#...#.....#.#.#...#  
  #.#########.###.#####.#.#.###.#  
  #.............#.#.....#.......#  
  ###.###########.###.#####.#.#.#  
  #.....#        A   C    #.#.#.#  
  #######        S   P    #####.#  
  #.#...#                 #......VT
  #.#.#.#                 #.#####  
  #...#.#               YN....#.#  
  #.###.#                 #####.#  
DI....#.#                 #.....#  
  #####.#                 #.###.#  
ZZ......#               QG....#..AS
  ###.###                 #######  
JO..#.#.#                 #.....#  
  #.#.#.#                 ###.#.#  
  #...#..DI             BU....#..LF
  #####.#                 #.#####  
YN......#               VT..#....QG
  #.###.#                 #.###.#  
  #.#...#                 #.....#  
  ###.###    J L     J    #.#.###  
  #.....#    O F     P    #.#...#  
  #.###.#####.#.#####.#####.###.#  
  #...#.#.#...#.....#.....#.#...#  
  #.#####.###.###.#.#.#########.#  
  #...#.#.....#...#.#.#.#.....#.#  
  #.###.#####.###.###.#.#.#######  
  #.#.........#...#.............#  
  #########.###.###.#############  
           B   J   C               
           U   P   P               
#+end_example

Here, AA  has no  direct path  to ZZ, but  it does  connect to  AS and
CP. By  passing through AS,  QG, BU,  and JO, you  can reach ZZ  in 58
steps.

In your maze,  how many steps does  it take to get from  the open tile
marked AA to the open tile marked ZZ?
** TODO Day 20.2                                                  :noexport:

** TODO Day 21.1                                                  :noexport:

You lift off from Pluto and start flying in the direction of Santa.

While experimenting  further with  the tractor beam,  you accidentally
pull an asteroid directly into  your ship! It deals significant damage
to your hull and causes your ship to begin tumbling violently.

You can send  a droid out to investigate, but  the tumbling is causing
enough artificial  gravity that  one wrong step  could send  the droid
through a hole in the hull and flying out into space.

The clear choice  for this mission is  a droid that can  jump over the
holes in the hull - a springdroid.

You  can use  an Intcode  program (your  puzzle input)  running on  an
ASCII-capable   computer   to   program  the   springdroid.   However,
springdroids  don't  run  Intcode;  instead,  they  run  a  simplified
assembly language called springscript.

While a springdroid is certainly  capable of navigating the artificial
gravity and giant holes, it has  one downside: it can only remember at
most 15 springscript instructions.

The springdroid  will move forward automatically,  constantly thinking
about whether to jump. The  springscript program defines the logic for
this decision.

Springscript  programs  only  use   Boolean  values,  not  numbers  or
strings. Two registers are available: T, the temporary value register,
and J, the jump  register. If the jump register is true  at the end of
the springscript  program, the springdroid  will try to jump.  Both of
these registers start with the value false.

Springdroids have a sensor that can  detect whether there is ground at
various  distances in  the direction  it is  facing; these  values are
provided in read-only registers. Your springdroid can detect ground at
four distances:  one tile away  (A), two  tiles away (B),  three tiles
away (C),  and four tiles  away (D). If there  is ground at  the given
distance, the register will be true;  if there is a hole, the register
will be false.

There are only three instructions available in springscript:
- AND X Y sets Y to true if both X and Y are true; otherwise, it sets
  Y to false.
- OR X Y sets Y to true if at least one of X or Y is true; otherwise,
  it sets Y to false.
- NOT X Y sets Y to true if X is false; otherwise, it sets Y to false.

In  all three  instructions, the  second argument  (Y) needs  to be  a
writable register (either  T or J). The first argument  (X) can be any
register (including A, B, C, or D).

For example,  the one-instruction program NOT  A J means "if  the tile
immediately in front of me is not ground, jump".

Or,  here is  a program  that jumps  if a  three-tile-wide hole  (with
ground on the other side of the hole) is detected:
#+begin_example
NOT A J
NOT B T
AND T J
NOT C T
AND T J
AND D J
#+end_example

The Intcode program expects ASCII inputs and outputs. It will begin by
displaying  a prompt;  then, input  the desired  instructions one  per
line. End  each line  with a  newline (ASCII code  10). When  you have
finished entering your program, provide the command WALK followed by a
newline to instruct the springdroid to begin surveying the hull.

If the  springdroid falls into space,  an ASCII rendering of  the last
moments  of   its  life  will  be   produced.  In  these,  @   is  the
springdroid, # is hull, and . is empty space. For example, suppose you
program the springdroid like this:
#+begin_example
NOT D J
WALK
#+end_example

This one-instruction program sets J to true if and only if there is no
ground four tiles  away. In other words, it attempts  to jump into any
hole it finds:
#+begin_example
.................
.................
@................
#####.###########

.................
.................
.@...............
#####.###########

.................
..@..............
.................
#####.###########

...@.............
.................
.................
#####.###########

.................
....@............
.................
#####.###########

.................
.................
.....@...........
#####.###########

.................
.................
.................
#####@###########
#+end_example

However, if the springdroid successfully  makes it across, it will use
an output instruction to indicate the  amount of damage to the hull as
a single giant integer outside the normal ASCII range.

Program the springdroid  with logic that allows it to  survey the hull
without falling into space. What amount of hull damage does it report?
** TODO Day 21.2                                                  :noexport:

** TODO Day 22.1                                                  :noexport:

There isn't much  to do while you  wait for the droids  to repair your
ship. At least  you're drifting in the right direction.  You decide to
practice a new card shuffle you've been working on.

Digging through  the ship's storage, you  find a deck of  space cards!
Just like any deck  of space cards, there are 10007  cards in the deck
numbered 0  through 10006.  The deck  must be new  - they're  still in
factory order, with 0  on the top, then 1, then 2, and  so on, all the
way through to 10006 on the bottom.

You've been practicing  three different techniques that  you use while
shuffling.  Suppose you  have  a deck  of only  10  cards (numbered  0
through 9):

To deal into new stack, create a new stack of cards by dealing the top
card of the  deck onto the top  of the new stack  repeatedly until you
run out of cards:
#+begin_example
Top          Bottom
0 1 2 3 4 5 6 7 8 9   Your deck
                      New stack

  1 2 3 4 5 6 7 8 9   Your deck
                  0   New stack

    2 3 4 5 6 7 8 9   Your deck
                1 0   New stack

      3 4 5 6 7 8 9   Your deck
              2 1 0   New stack

Several steps later...

                  9   Your deck
  8 7 6 5 4 3 2 1 0   New stack

                      Your deck
9 8 7 6 5 4 3 2 1 0   New stack
#+end_example

Finally, pick up the  new stack you've just created and  use it as the
deck for the next technique.

To cut N cards, take the top N  cards off the top of the deck and move
them  as a  single unit  to the  bottom of  the deck,  retaining their
order. For example, to cut 3:
#+begin_example
Top          Bottom
0 1 2 3 4 5 6 7 8 9   Your deck

      3 4 5 6 7 8 9   Your deck
0 1 2                 Cut cards

3 4 5 6 7 8 9         Your deck
              0 1 2   Cut cards

3 4 5 6 7 8 9 0 1 2   Your deck
#+end_example

You've also  been getting pretty good  at a version of  this technique
where N is negative! In that case, cut (the absolute value of) N cards
from the bottom of the deck onto the top. For example, to cut -4:
#+begin_example
Top          Bottom
0 1 2 3 4 5 6 7 8 9   Your deck

0 1 2 3 4 5           Your deck
            6 7 8 9   Cut cards

        0 1 2 3 4 5   Your deck
6 7 8 9               Cut cards

6 7 8 9 0 1 2 3 4 5   Your deck
#+end_example

To deal with increment N, start by clearing enough space on your table
to lay out all of the cards  individually in a long line. Deal the top
card into the  leftmost position. Then, move N positions  to the right
and deal the next  card there. If you would move  into a position past
the end of the space on your table, wrap around and keep counting from
the leftmost  card again. Continue this  process until you run  out of
cards.

For example, to deal with increment 3:

#+begin_example
0 1 2 3 4 5 6 7 8 9   Your deck
. . . . . . . . . .   Space on table
^                     Current position

Deal the top card to the current position:

  1 2 3 4 5 6 7 8 9   Your deck
0 . . . . . . . . .   Space on table
^                     Current position

Move the current position right 3:

  1 2 3 4 5 6 7 8 9   Your deck
0 . . . . . . . . .   Space on table
      ^               Current position

Deal the top card:

    2 3 4 5 6 7 8 9   Your deck
0 . . 1 . . . . . .   Space on table
      ^               Current position

Move right 3 and deal:

      3 4 5 6 7 8 9   Your deck
0 . . 1 . . 2 . . .   Space on table
            ^         Current position

Move right 3 and deal:

        4 5 6 7 8 9   Your deck
0 . . 1 . . 2 . . 3   Space on table
                  ^   Current position

Move right 3, wrapping around, and deal:

          5 6 7 8 9   Your deck
0 . 4 1 . . 2 . . 3   Space on table
    ^                 Current position

And so on:

0 7 4 1 8 5 2 9 6 3   Space on table
#+end_example

Positions on the table which  already contain cards are still counted;
they're not skipped.  Of course, this technique  is carefully designed
so  it will  never put  two  cards in  the  same position  or leave  a
position empty.

Finally, collect the cards on the table so that the leftmost card ends
up at the top  of your deck, the card to its right  ends up just below
the top  card, and  so on,  until the  rightmost card  ends up  at the
bottom of the deck.

The complete shuffle process (your  puzzle input) consists of applying
many  of  these  techniques.  Here  are  some  examples  that  combine
techniques; they all start with a factory order deck of 10 cards:
#+begin_example
deal with increment 7
deal into new stack
deal into new stack
Result: 0 3 6 9 2 5 8 1 4 7

cut 6
deal with increment 7
deal into new stack
Result: 3 0 7 4 1 8 5 2 9 6

deal with increment 7
deal with increment 9
cut -2
Result: 6 3 0 7 4 1 8 5 2 9

deal into new stack
cut -2
deal with increment 7
cut 8
cut -4
deal with increment 7
cut 3
deal with increment 9
deal with increment 3
cut -1
Result: 9 2 5 8 1 4 7 0 3 6
#+end_example

Positions within the deck count from 0 at the top, then 1 for the card
immediately below  the top card,  and so on  to the bottom.  (That is,
cards start in the position matching their number.)

After shuffling  your factory order deck  of 10007 cards, what  is the
position of card 2019?
** TODO Day 22.2                                                  :noexport:

** TODO Day 23.1                                                  :noexport:

The  droids have  finished  repairing  as much  of  the  ship as  they
can. Their report indicates that this  was a Category 6 disaster - not
because it  was that bad,  but because  it destroyed the  stockpile of
Category  6 network  cables  as well  as most  of  the ship's  network
infrastructure.

You'll need to rebuild the network from scratch.

The  computers on  the  network are  standard  Intcode computers  that
communicate by sending packets to each  other. There are 50 of them in
total, each  running a copy  of the same Network  Interface Controller
(NIC)  software  (your  puzzle  input).  The  computers  have  network
addresses 0 through  49; when each computer boots up,  it will request
its network  address via a single  input instruction. Be sure  to give
each computer a unique network address.

Once a computer has received its  network address, it will begin doing
work  and communicating  over  the network  by  sending and  receiving
packets. All packets contain two values named X and Y. Packets sent to
a computer are queued by the recipient  and read in the order they are
received.

To send  a packet to another  computer, the NIC will  use three output
instructions  that  provide  the  destination address  of  the  packet
followed by its X and Y values. For example, three output instructions
that provide the values  10, 20, 30 would send a  packet with X=20 and
Y=30 to the computer with address 10.

To receive a  packet from another computer, the NIC  will use an input
instruction.  If   the  incoming   packet  queue  is   empty,  provide
-1. Otherwise,  provide the X value  of the next packet;  the computer
will then  use a second input  instruction to receive the  Y value for
the same packet. Once both values of  the packet are read in this way,
the packet is removed from the queue.

Note    that   these    input    and    output   instructions    never
block.  Specifically, output  instructions do  not wait  for the  sent
packet  to be  received -  the  computer might  send multiple  packets
before receiving any. Similarly, input  instructions do not wait for a
packet to arrive - if no  packet is waiting, input instructions should
receive -1.

Boot up all 50 computers and attach  them to your network. What is the
Y value of the first packet sent to address 255?
** TODO Day 23.2                                                  :noexport:

** TODO Day 24.1                                                  :noexport:

You land on Eris, your last stop before reaching Santa. As soon as you
do, your  sensors start picking  up strange life forms  moving around:
Eris  is  infested with  bugs!  With  an  over 24-hour  roundtrip  for
messages between you and Earth, you'll  have to deal with this problem
on your own.

Eris isn't a very  large place; a scan of the entire  area fits into a
5x5 grid (your puzzle input). The scan shows bugs (#) and empty spaces
(.).

Each minute, The bugs live and die  based on the number of bugs in the
four adjacent tiles:
- A bug dies (becoming an empty space) unless there is exactly one bug
  adjacent to it.
- An empty space becomes infested with a bug if exactly one or two
  bugs are adjacent to it.
  
Otherwise, a bug or empty space  remains the same. (Tiles on the edges
of the  grid have fewer  than four  adjacent tiles; the  missing tiles
count  as  empty  space.)  This  process  happens  in  every  location
simultaneously;  that  is,  within  the same  minute,  the  number  of
adjacent bugs is counted for every  tile first, and then the tiles are
updated.

Here are the first few minutes of an example scenario:
#+begin_example
Initial state:
....#
#..#.
#..##
..#..
#....

After 1 minute:
#..#.
####.
###.#
##.##
.##..

After 2 minutes:
#####
....#
....#
...#.
#.###

After 3 minutes:
#....
####.
...##
#.##.
.##.#

After 4 minutes:
####.
....#
##..#
.....
##...
#+end_example

To  understand the  nature of  the bugs,  watch for  the first  time a
layout of  bugs and empty spaces  matches any previous layout.  In the
example above, the first layout to appear twice is:
#+begin_example
.....
.....
.....
#....
.#...
#+end_example

To calculate  the biodiversity rating  for this layout,  consider each
tile left-to-right  in the top  row, then left-to-right in  the second
row, and so on. Each of these tiles is worth biodiversity points equal
to increasing powers of two: 1, 2, 4, 8, 16, 32, and so on. Add up the
biodiversity points  for tiles  with bugs; in  this example,  the 16th
tile (32768 points) and 22nd tile  (2097152 points) have bugs, a total
biodiversity rating of 2129920.

What is the biodiversity rating for the first layout that appears
twice?
** TODO Day 24.2                                                  :noexport:

** TODO Day 25.1                                                  :noexport:

As  you  approach Santa's  ship,  your  sensors report  two  important
details:

First, that  you might be  too late:  the internal temperature  is -40
degrees.

Second, that one faint life signature is somewhere on the ship.

The airlock door is locked with a code; your best option is to send in
a small  droid to investigate the  situation. You attach your  ship to
Santa's, break  a small  hole in the  hull, and let  the droid  run in
before you  seal it up  again. Before  your ship starts  freezing, you
detach your  ship and  set it  to automatically  stay within  range of
Santa's ship.

This  droid   can  follow  basic   instructions  and  report   on  its
surroundings; you can  communicate with it through  an Intcode program
(your puzzle input) running on an ASCII-capable computer.

As the droid  moves through its environment, it will  describe what it
encounters.  When  it  says  Command?,   you  can  give  it  a  single
instruction  terminated  with  a  newline (ASCII  code  10).  Possible
instructions are:
- Movement via north, south, east, or west.
- To take an item the droid sees in the environment, use the command
  take <name of item>. For example, if the droid reports seeing a red
  ball, you can pick it up with take red ball.
- To drop an item the droid is carrying, use the command drop <name of
  item>. For example, if the droid is carrying a green ball, you can
  drop it with drop green ball.
- To get a list of all of the items the droid is currently carrying,
  use the command inv (for "inventory").
  
Extra spaces or other characters aren't allowed - instructions must be
provided precisely.

Santa's   ship  is   a  Reindeer-class   starship;  these   ships  use
pressure-sensitive floors to determine the identity of droids and crew
members. The  standard configuration  for these  starships is  for all
droids  to weigh  exactly  the  same amount  to  make  them easier  to
detect. If you  need to get past  such a sensor, you might  be able to
reach the correct weight by carrying items from the environment.

Look around the ship and see if you can find the password for the main
airlock.
** TODO Day 25.2                                                  :noexport:
** Stats                                                          :noexport:

#+CAPTION: https://adventofcode.com/2019/stats
| 25 |  3 | ▉▉▉                                       |
| 24 |  3 | ▉▉▉                                       |
| 23 |  3 | ▉▉▉                                       |
| 22 |  3 | ▉▉▉                                       |
| 21 |  3 | ▉▉▉                                       |
| 20 |  3 | ▉▉▉                                       |
| 19 |  4 | ▉▉▉▉                                      |
| 18 |  3 | ▉▉▉                                       |
| 17 |  4 | ▉▉▉▉                                      |
| 16 |  6 | ▉▉▉▉▉▉                                    |
| 15 |  5 | ▉▉▉▉▉                                     |
| 14 |  6 | ▉▉▉▉▉▉                                    |
| 13 |  6 | ▉▉▉▉▉▉                                    |
| 12 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 11 |  7 | ▉▉▉▉▉▉▉                                   |
| 10 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
|  9 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
|  8 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
|  7 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
|  6 | 13 | ▉▉▉▉▉▉▉▉▉▉▉▉▉                             |
|  5 | 14 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉                            |
|  4 | 20 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                      |
|  3 | 20 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                      |
|  2 | 30 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉            |
|  1 | 41 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ |
#+TBLFM: $3='(orgtbl-uc-draw-grid $2 0 41 41)


* 2018 [13/50]
** DONE Day 1.1

"We've detected some temporal anomalies,"  one of Santa's Elves at the
Temporal  Anomaly  Research  and Detection  Instrument  Station  tells
you. She  sounded pretty worried  when she  called you down  here. "At
500-year intervals  into the past,  someone has been  changing Santa's
history!"

"The good news is that the  changes won't propagate to our time stream
for another 25 days, and we have a device" - she attaches something to
your  wrist  -  "that will  let  you  fix  the  changes with  no  such
propagation delay. It's configured to  send you 500 years further into
the past every few  days; that was the best we could  do on such short
notice."

"The  bad  news is  that  we  are  detecting roughly  fifty  anomalies
throughout  time;  the  device  will  indicate  fixed  anomalies  with
stars. The other bad  news is that we only have  one device and you're
the best  person for  the job!  Good lu--"  She taps  a button  on the
device and you  suddenly feel like you're falling.  To save Christmas,
you need to get all fifty stars by December 25th.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

After feeling like you've been falling  for a few minutes, you look at
the device's  tiny screen.  "Error: Device  must be  calibrated before
first  use.  Frequency  drift detected.  Cannot  maintain  destination
lock." Below  the message, the device  shows a sequence of  changes in
frequency  (your puzzle  input). A  value  like +6  means the  current
frequency increases by 6; a value  like -3 means the current frequency
decreases by 3.

For example, if  the device displays frequency changes of  +1, -2, +3,
+1,  then starting  from a  frequency of  zero, the  following changes
would occur:
- Current frequency  0, change of +1; resulting frequency  1.
- Current frequency  1, change of -2; resulting frequency -1.
- Current frequency -1, change of +3; resulting frequency  2.
- Current frequency  2, change of +1; resulting frequency  3.

In this example, the resulting frequency is 3.

Here are other example situations:
#+begin_example
    +1, +1, +1 results in  3
    +1, +1, -2 results in  0
    -1, -2, -3 results in -6
#+end_example

Starting with  a frequency  of zero, what  is the  resulting frequency
after all of the changes in frequency have been applied?

#+begin_src fennel -n :session d1801 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["+1" "-2" "+3" "+1"])

(fn solve [input]
  (let [freq (lume.map input #(tonumber $))]
    (accumulate [sum 0 _ f (ipairs freq)]
      (+ sum f))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 3 test-input)

(solve (aoc.string-from "2018/01.inp"))
#+end_src

#+RESULTS:
: 574


** DONE Day 1.2

You notice that the device repeats the same frequency change list over
and  over.  To calibrate  the  device,  you  need  to find  the  first
frequency it reaches twice.

For example, using the same list of changes above, the device would
loop as follows:
- Current frequency  0, change of +1; resulting frequency  1.
- Current frequency  1, change of -2; resulting frequency -1.
- Current frequency -1, change of +3; resulting frequency  2.
- Current frequency  2, change of +1; resulting frequency  3.
- (At this point, the device continues from the start of the list.)
- Current frequency  3, change of +1; resulting frequency  4.
- Current frequency  4, change of -2; resulting frequency  2, which
  has already been seen.
  
In this  example, the first  frequency reached  twice is 2.  Note that
your device  might need to repeat  its list of frequency  changes many
times before a duplicate frequency is found, and that duplicates might
be found while in the middle of processing the list.

Here are other examples:
- +1, -1 first reaches 0 twice.
- +3, +3, +4, -2, -4 first reaches 10 twice.
- -6, +3, +8, +5, -6 first reaches 5 twice.
- +7, +7, -2, -7, -4 first reaches 14 twice.

What is the first frequency your device reaches twice?

#+begin_src fennel -n :session d1801 :exports both
(fn solve2 [input]
  (let [xs (lume.map input #(tonumber $))]
    (var pos 2)
    (var res [(. xs 1)])
    (var xi (+ (. xs pos) (. res (length res))))
    (while (= nil (lume.find res xi))
      (table.insert res xi)
      (set pos (aoc.modulo+ 1 pos (length xs)))
      (set xi (+ (. xs pos) (. res (length res)))))
    xi))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 2 test-input)
(test2 10 ["+3" "+3" "+4" "-2" "-4"])
(test2 5 ["-6" "+3" "+8" "+5" "-6"])
(test2 14 ["+7" "+7" "-2" "-7" "-4"])

(solve2 (aoc.string-from "2018/01.inp"))
#+end_src

#+RESULTS:
: 452


** DONE Day 2.1

You stop falling through time, catch your breath, and check the screen
on  the  device. "Destination  reached.  Current  Year: 1518.  Current
Location: North Pole Utility Closet 83N10."  You made it! Now, to find
those anomalies.

Outside the  utility closet, you  hear footsteps and a  voice. "...I'm
not sure either.  But now that so many people  have chimneys, maybe he
could sneak  in that  way?" Another  voice responds,  "Actually, we've
been working  on a  new kind of  suit that would  let him  fit through
tight spaces like  that. But, I heard  that a few days  ago, they lost
the prototype fabric, the design plans, everything! Nobody on the team
can even seem to remember important details of the project!"

"Wouldn't they  have had enough  fabric to  fill several boxes  in the
warehouse?  They'd  be stored  together,  so  the  box IDs  should  be
similar. Too bad it would take forever to search the warehouse for two
similar box IDs..." They walk too far away to hear any more.

Late at night,  you sneak to the  warehouse - who knows  what kinds of
paradoxes you could cause if you  were discovered - and use your fancy
wrist  device to  quickly scan  every box  and produce  a list  of the
likely candidates (your puzzle input).

To make sure you didn't miss  any, you scan the likely candidate boxes
again, counting the  number that have an ID containing  exactly two of
any letter  and then separately  counting those with exactly  three of
any  letter. You  can  multiply those  two counts  together  to get  a
rudimentary checksum and compare it to what your device predicts.

For example, if you see the following box IDs:
- abcdef contains no letters that appear exactly two or three times.
- bababc contains two a and three b, so it counts for both.
- abbcde contains two b, but no letter appears exactly three times.
- abcccd contains three c, but no letter appears exactly two times.
- aabcdd contains two a and two d, but it only counts once.
- abcdee contains two e.
- ababab contains three a and three b, but it only counts once.

Of these box IDs, four of  them contain a letter which appears exactly
twice, and three of them contain  a letter which appears exactly three
times. Multiplying these together produces a checksum of 4 * 3 = 12.

What is the checksum for your list of box IDs?

#+begin_src fennel -n :session d1802 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["abcdef"
        "bababc"
        "abbcde"
        "abcccd"
        "aabcdd"
        "abcdee"
        "ababab"])

(fn solve [input]
  (var doubles 0)
  (var triples 0)
  (each [_ line (ipairs input)]
    (let [xs (aoc.table-sort (aoc.string-toarray line))
          bins (aoc.partition-by xs #(= $1 $2))]
      (when (< 0 (length (lume.filter bins #(= 2 (length $)))))
        (set doubles (+ 1 doubles)))
      (when (< 0 (length (lume.filter bins #(= 3 (length $)))))
        (set triples (+ 1 triples)))))
  (* doubles triples))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 12 test-input)

(solve (aoc.string-from "2018/02.inp"))
#+end_src

#+RESULTS:
: 3952

** DONE Day 2.2

Confident that your list of box  IDs is complete, you're ready to find
the boxes full of prototype fabric.

The boxes will  have IDs which differ by exactly  one character at the
same position  in both strings.  For example, given the  following box
IDs:

#+begin_example
abcde
fghij
klmno
pqrst
fguij
axcye
wvxyz
#+end_example

The IDs abcde  and axcye are close, but they  differ by two characters
(the second  and fourth). However, the  IDs fghij and fguij  differ by
exactly one character, the third (h  and u). Those must be the correct
boxes.

What  letters are  common between  the two  correct box  IDs? (In  the
example above, this is found  by removing the differing character from
either ID, producing fgij.)

#+begin_src fennel -n :session d1802 :exports both
(local test2-input
       ["abcde"
        "fghij"
        "klmno"
        "pqrst"
        "fguij"
        "axcye"
        "wvxyz"])

(fn solve2 [input]
  (var done false)
  (for [i 1 (length input) &until done]
    (for [j i (length input) &until done]
      (when (= 1 (aoc.hamming-dist (. input i) (. input j)))
        (set done [(. input i) (. input j)]))))
  (aoc.table-tostring
   (lume.filter
    (aoc.string-toarray (. done 1))
    #(lume.find (aoc.string-toarray (. done 2)) $))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 "fgij" test2-input)

(solve2 (aoc.string-from "2018/02.inp"))
#+end_src

#+RESULTS:
: vtnikorkulbfejvyznqgdxpaw

** DONE Day 3.1

The Elves managed  to locate the chimney-squeeze  prototype fabric for
Santa's suit (thanks to someone who helpfully wrote its box IDs on the
wall  of the  warehouse in  the middle  of the  night). Unfortunately,
anomalies are still  affecting them - nobody can even  agree on how to
cut the fabric.

The whole piece of fabric they're working  on is a very large square -
at least 1000 inches on each side.

Each Elf has  made a claim about  which area of fabric  would be ideal
for  Santa's suit.  All claims  have  an ID  and consist  of a  single
rectangle with edges parallel to the edges of the fabric. Each claim's
rectangle is defined as follows:
- The number of inches between the left edge of the fabric and the
  left edge of the rectangle.
- The number of inches between the top edge of the fabric and the top
  edge of the rectangle.
- The width of the rectangle in inches.
- The height of the rectangle in inches.

A claim  like #123  @ 3,2:  5x4 means  that claim  ID 123  specifies a
rectangle 3 inches from  the left edge, 2 inches from  the top edge, 5
inches wide, and 4 inches tall.  Visually, it claims the square inches
of fabric  represented by # (and  ignores the square inches  of fabric
represented by .) in the diagram below:
#+begin_example
...........
...........
...#####...
...#####...
...#####...
...#####...
...........
...........
...........
#+end_example

The problem  is that many of  the claims overlap, causing  two or more
claims to  cover part  of the  same areas.  For example,  consider the
following claims:
#+begin_example
#1 @ 1,3: 4x4
#2 @ 3,1: 4x4
#3 @ 5,5: 2x2
#+end_example

Visually, these claim the following areas:
#+begin_example
........
...2222.
...2222.
.11XX22.
.11XX22.
.111133.
.111133.
........
#+end_example

The  four  square  inches  marked  with   X  are  claimed  by  both  1
and 2. (Claim 3, while adjacent to the others, does not overlap either
of them.)

If the Elves all proceed with their  own plans, none of them will have
enough fabric. How many square inches of fabric are within two or more
claims?

#+begin_src fennel -n :session d1803 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["#1 @ 1,3: 4x4"
        "#2 @ 3,1: 4x4"
        "#3 @ 5,5: 2x2"])

(fn read-lines [lines]
  (let [res []]
    (each [_ line (ipairs lines)]
      (let [[_ _ xy wh] (aoc.string-split line " ")
            [x y] (aoc.string-split (string.sub xy 1 (- (string.len xy) 1)) ",")
            [w h] (aoc.string-split wh "x")]
        (table.insert res [(tonumber x) (tonumber y) (+ w x -1) (+ h y -1)])))
    res))

(fn make-fabric [n]
  (let [rows []]
    (for [i 1 n]
      (let [cols []]
        (for [j 1 n]
          (table.insert cols 0))
        (table.insert rows cols)))
    rows))

(fn mark [fabric claim]
  (for [y (. claim 2) (. claim 4)]
    (for [x (. claim 1) (. claim 3)]
      (let [z (. (. fabric (+ 1 y)) (+ 1 x))]
        (aoc.table-replace fabric (+ 1 y) (+ 1 x) (+ 1 z))))))

(fn mark-fabric [claims]
  (let [fabric (make-fabric 1000)]
    (each [_ claim (ipairs claims)]
      (mark fabric claim))
    fabric))

(fn solve [input]
  (let [claims (read-lines input)
        fabric (mark-fabric claims)]
    (length (lume.filter (aoc.table-flatten fabric) #(< 1 $)))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 4 test-input)

(solve (aoc.string-from "2018/03.inp"))
#+end_src

#+RESULTS:
: 104241

** DONE Day 3.2

Amidst the chaos, you notice that exactly one claim doesn't overlap by
even a single square  inch of fabric with any other  claim. If you can
somehow draw  attention to it,  maybe the Elves  will be able  to make
Santa's suit after all!

For example,  in the claims  above, only claim  3 is intact  after all
claims are made.

What is the ID of the only claim that doesn't overlap?

#+begin_src fennel -n :session d1803 :exports both
(fn solve2 [input]
  (var done false)
  (let [claims (read-lines input)
        fabric (mark-fabric claims)]
    (each [i c (ipairs claims) &until done]
      (set done i)
      (for [y (. c 2) (. c 4)]
        (for [x (. c 1) (. c 3)]
          (when (not= 1 (. (. fabric (+ y 1)) (+ 1 x)))
            (set done false))))))
  done)

(solve2 (aoc.string-from "2018/03.inp"))
#+end_src

#+RESULTS:
: 806

** DONE Day 4.1

You've sneaked  into another  supply closet -  this time,  it's across
from the  prototype suit manufacturing  lab. You need to  sneak inside
and  fix the  issues  with the  suit, but  there's  a guard  stationed
outside the lab, so this is as close as you can safely get.

As you  search the closet for  anything that might help,  you discover
that you're  not the first  person to want  to sneak in.  Covering the
walls, someone has spent an hour  starting every midnight for the past
few months  secretly observing this  guard post! They've  been writing
down the ID  of the one guard on  duty that night - the  Elves seem to
have decided  that one guard was  enough for the overnight  shift - as
well as  when they fall  asleep or wake up  while at their  post (your
puzzle input).

For example, consider  the following records, which  have already been
organized into chronological order:

#+begin_example
[1518-11-01 00:00] Guard #10 begins shift
[1518-11-01 00:05] falls asleep
[1518-11-01 00:25] wakes up
[1518-11-01 00:30] falls asleep
[1518-11-01 00:55] wakes up
[1518-11-01 23:58] Guard #99 begins shift
[1518-11-02 00:40] falls asleep
[1518-11-02 00:50] wakes up
[1518-11-03 00:05] Guard #10 begins shift
[1518-11-03 00:24] falls asleep
[1518-11-03 00:29] wakes up
[1518-11-04 00:02] Guard #99 begins shift
[1518-11-04 00:36] falls asleep
[1518-11-04 00:46] wakes up
[1518-11-05 00:03] Guard #99 begins shift
[1518-11-05 00:45] falls asleep
[1518-11-05 00:55] wakes up
#+end_example

Timestamps are  written using  year-month-day hour:minute  format. The
guard falling asleep  or waking up is always the  one whose shift most
recently  started.  Because  all  asleep/awake times  are  during  the
midnight hour  (00:00 - 00:59), only  the minute portion (00  - 59) is
relevant for those events.

Visually, these records show that the guards are asleep at these times:
#+begin_example
Date   ID   Minute
            000000000011111111112222222222333333333344444444445555555555
            012345678901234567890123456789012345678901234567890123456789
11-01  #10  .....####################.....#########################.....
11-02  #99  ........................................##########..........
11-03  #10  ........................#####...............................
11-04  #99  ....................................##########..............
11-05  #99  .............................................##########.....
#+end_example

The  columns  are Date,  which  shows  the  month-day portion  of  the
relevant day; ID, which shows the  guard on duty that day; and Minute,
which shows the  minutes during which the guard was  asleep within the
midnight hour.  (The Minute column's  header shows the  minute's ten's
digit in the first  row and the one's digit in  the second row.) Awake
is shown as ., and asleep is shown as #.

Note that guards  count as asleep on the minute  they fall asleep, and
they count as  awake on the minute they wake  up. For example, because
Guard #10  wakes up  at 00:25  on 1518-11-01, minute  25 is  marked as
awake.

If you can figure out the guard most likely to be asleep at a specific
time, you  might be able to  trick that guard into  working tonight so
you can have  the best chance of sneaking in.  You have two strategies
for choosing the best guard/minute combination.

Strategy 1:  Find the  guard that  has the  most minutes  asleep. What
minute does that guard spend asleep the most?

In the example above, Guard #10 spent the most minutes asleep, a total
of 50 minutes (20+25+5), while Guard #99  only slept for a total of 30
minutes (10+10+10). Guard #10 was asleep most during minute 24 (on two
days, whereas any  other minute the guard was asleep  was only seen on
one day).

While this  example listed  the entries  in chronological  order, your
entries are in the order you  found them. You'll need to organize them
before they can be analyzed.

What is  the ID of  the guard you chose  multiplied by the  minute you
chose? (In the above example, the answer would be 10 * 24 = 240.)

#+begin_src fennel -n :session d1804 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["[1518-11-01 00:00] Guard #10 begins shift"
        "[1518-11-01 00:05] falls asleep"
        "[1518-11-01 00:25] wakes up"
        "[1518-11-01 00:30] falls asleep"
        "[1518-11-01 00:55] wakes up"
        "[1518-11-01 23:58] Guard #99 begins shift"
        "[1518-11-02 00:40] falls asleep"
        "[1518-11-02 00:50] wakes up"
        "[1518-11-03 00:05] Guard #10 begins shift"
        "[1518-11-03 00:24] falls asleep"
        "[1518-11-03 00:29] wakes up"
        "[1518-11-04 00:02] Guard #99 begins shift"
        "[1518-11-04 00:36] falls asleep"
        "[1518-11-04 00:46] wakes up"
        "[1518-11-05 00:03] Guard #99 begins shift"
        "[1518-11-05 00:45] falls asleep"
        "[1518-11-05 00:55] wakes up"])

(fn read-log [lines]
  (let [res []]
    (each [_ line (ipairs lines)]
      (match (aoc.string-split line " ")
        [d t "Guard" g "begins" "shift"]
        (do (when (< 0 (# res)) (table.insert res -1))
            (table.insert res (tonumber (string.sub g 2))))
        [d t "falls" "asleep"]
        (table.insert res (tonumber (string.match t ":(%d%d)%]")))
        [d t "wakes" "up"]
        (table.insert res (tonumber (string.match t ":(%d%d)%]")))))
    (aoc.partition-at res -1)))

(fn process-log [logs]
  (let [res {}]
    (each [_ log (ipairs logs)]
      (let [cur (or (. res (. log 1)) [])]
        (for [i 2 (length log) 2]
          (lume.map (aoc.range-to (. log i) (- (. log (+ 1 i)) 1))
                    #(table.insert cur $)))
        (tset res (. log 1) cur)))
    res))

(fn max-frequency [xs]
  (let [ids (aoc.keys xs)
        res []]
    (each [_ id (ipairs ids)]
      (let [ys (aoc.frequency (. xs id))]
        (table.insert res [id (length (. xs id)) (. ys 1) (length ys)])))
    (table.sort res #(< (. $1 2) (. $2 2)))
    (* (. (. res (# res)) 1)
       (. (. res (# res)) 3))))

(fn solve [input]
  (table.sort input)
  (-> input
      (read-log)
      (process-log)
      (max-frequency)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 240 test-input)

(solve (aoc.string-from "2018/04.inp"))
#+end_src

#+RESULTS:
: 84636


** DONE Day 4.2

Strategy 2:  Of all guards, which  guard is most frequently  asleep on
the same minute?

In the example  above, Guard #99 spent minute 45  asleep more than any
other guard or minute - three times in total. (In all other cases, any
guard spent any minute asleep at most twice.)

What is  the ID of  the guard you chose  multiplied by the  minute you
chose? (In the above example, the answer would be 99 * 45 = 4455.)

#+begin_src fennel -n :session d1804 :exports both
(fn max-frequency2 [xs]
  (let [ids (aoc.keys xs)
        res []]
    (each [_ id (ipairs ids)]
      (let [ys (aoc.frequency (. xs id))]
        (table.insert res [id ys])))
    (table.sort res #(< (# (. $1 2)) (# (. $2 2))))
    (* (. (. res (# res)) 1)
       (. (. (. res (# res)) 2) 1))))

(fn solve2 [input]
  (table.sort input)
  (-> input
      (read-log)
      (process-log)
      (max-frequency2)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 4455 test-input)

(solve2 (aoc.string-from "2018/04.inp"))
#+end_src

#+RESULTS:
: 91679

** DONE Day 5.1

You've  managed  to  sneak  in to  the  prototype  suit  manufacturing
lab. The  Elves are making  decent progress, but are  still struggling
with the suit's size reduction capabilities.

While the very latest in  1518 alchemical technology might have solved
their problem  eventually, you  can do better.  You scan  the chemical
composition of the  suit's material and discover that it  is formed by
extremely  long polymers  (one of  which is  available as  your puzzle
input).

The polymer  is formed by  smaller units which, when  triggered, react
with each  other such  that two  adjacent units of  the same  type and
opposite  polarity  are destroyed.  Units'  types  are represented  by
letters;  units'  polarity  is   represented  by  capitalization.  For
instance, r and R are units  with the same type but opposite polarity,
whereas r and s are entirely different types and do not react.

For example:
- In aA, a and A react, leaving nothing behind.
- In abBA, bB destroys itself, leaving aA. As above, this then
  destroys itself, leaving nothing.
- In abAB, no two adjacent units are of the same type, and so nothing
  happens.
- In aabAAB, even though aa and AA are of the same type, their
  polarities match, and so nothing happens.
  
Now, consider a larger example, dabAcCaCBAcCcaDA:

#+begin_example
dabAcCaCBAcCcaDA  The first 'cC' is removed.
dabAaCBAcCcaDA    This creates 'Aa', which is removed.
dabCBAcCcaDA      Either 'cC' or 'Cc' are removed (the result is the same).
dabCBAcaDA        No further actions can be taken.
#+end_example

After all possible reactions, the resulting polymer contains 10 units.

How many  units remain after  fully reacting the polymer  you scanned?
(Note:  in  this  puzzle  and  others, the  input  is  large;  if  you
copy/paste your input, make sure you get the whole thing.)

#+begin_src fennel -n :session d1805 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["dabAcCaCBAcCcaDA"])

(fn react [xs j]
  (var done false)
  (if (= j (length xs)) xs
      (do (for [i j (# xs) &until done]
            (when (and (not= (. xs i) (. xs (- i 1)))
                       (or (= (string.upper (. xs i)) (. xs (- i 1)))
                           (= (string.lower (. xs i)) (. xs (- i 1)))))
              (table.remove xs i)
              (table.remove xs (- i 1))
              (set done i)))
          (react xs (if done (- done 1) (# xs))))))

(fn solve [input]
  (-> (. input 1)
      (aoc.string-toarray)
      (react 2)
      (length)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 10 test-input)

(solve (aoc.string-from "2018/05.inp"))
#+end_src

#+RESULTS:
: 11476


** DONE Day 5.2

Time to improve the polymer.

One of the unit types is causing problems; it's preventing the polymer
from collapsing as much as it should. Your goal is to figure out which
unit type  is causing the  most problems,  remove all instances  of it
(regardless  of  polarity), fully  react  the  remaining polymer,  and
measure its length.

For example, again using the polymer dabAcCaCBAcCcaDA from above:
- Removing all A/a units produces dbcCCBcCcD. Fully reacting this
  polymer produces dbCBcD, which has length 6.
- Removing all B/b units produces daAcCaCAcCcaDA. Fully reacting this
  polymer produces daCAcaDA, which has length 8.
- Removing all C/c units produces dabAaBAaDA. Fully reacting this
  polymer produces daDA, which has length 4.
- Removing all D/d units produces abAcCaCBAcCcaA. Fully reacting this
  polymer produces abCBAc, which has length 6.

In this example, removing all C/c units was best, producing the
answer 4.

What is the length of the shortest polymer you can produce by removing
all units of exactly one type and fully reacting the result?

#+begin_src fennel -n :session d1805 :exports both
(fn solve2 [input]
  (let [line (. input 1)
        xs (aoc.string-toarray "abcdefghijklmnopqrstuvwxyz")]
    (aoc.math-min
     (icollect [_ x (ipairs xs)]
       (let [ys (string.gsub (string.gsub line x "") (string.upper x) "")]
         (length (react (aoc.string-toarray ys) 2)))))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 4 test-input)

(solve2 (aoc.string-from "2018/05.inp"))
#+end_src

#+RESULTS:
: 5446

** DONE Day 6.1

The device on your wrist beeps  several times, and once again you feel
like you're falling.

"Situation    critical,"    the   device    announces.    "Destination
indeterminate.  Chronal  interference  detected.  Please  specify  new
target coordinates."

The  device  then   produces  a  list  of   coordinates  (your  puzzle
input). Are they places it thinks are safe or dangerous? It recommends
you check manual page 729. The Elves did not give you a manual.

If they're dangerous, maybe you can minimize the danger by finding the
coordinate that gives the largest distance from the other points.

Using  only the  Manhattan distance,  determine the  area around  each
coordinate by  counting the number  of integer X,Y locations  that are
closest to that  coordinate (and aren't tied in distance  to any other
coordinate).

Your  goal  is  to find  the  size  of  the  largest area  that  isn't
infinite. For example, consider the following list of coordinates:

#+begin_example
1, 1
1, 6
8, 3
3, 4
5, 5
8, 9
#+end_example

If we name these coordinates A through  F, we can draw them on a grid,
putting 0,0 at the top left:

#+begin_example
..........
.A........
..........
........C.
...D......
.....E....
.B........
..........
..........
........F.
#+end_example

This  view is  partial -  the actual  grid extends  infinitely in  all
directions.  Using the  Manhattan  distance,  each location's  closest
coordinate can be determined, shown here in lowercase:

#+begin_example
aaaaa.cccc
aAaaa.cccc
aaaddecccc
aadddeccCc
..dDdeeccc
bb.deEeecc
bBb.eeee..
bbb.eeefff
bbb.eeffff
bbb.ffffFf
#+end_example

Locations shown as . are equally far from two or more coordinates, and
so they don't count as being closest to any.

In  this  example,  the areas  of  coordinates  A,  B,  C, and  F  are
infinite -  while not shown  here, their areas extend  forever outside
the  visible grid.  However,  the areas  of coordinates  D  and E  are
finite: D  is closest  to 9 locations,  and E is  closest to  17 (both
including  the  coordinate's  location  itself).  Therefore,  in  this
example, the size of the largest area is 17.

What is the size of the largest area that isn't infinite?

#+begin_src fennel -n :session d1806 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["1, 1" "1, 6" "8, 3" "3, 4" "5, 5" "8, 9"])

(fn min-uniq-index [xs]
  (let [res (aoc.min-index xs)]
    (if (< 1 (lume.count xs #(= (. xs res) $))) 0 res)))

(fn populate [plane points]
  (for [y 1 (# plane)]
    (for [x 1 (# (. plane y))]
      (let [distances (icollect [i j (ipairs points)]
                        (aoc.manhattan-dist [x y] j))]
        (aoc.table-replace plane y x (min-uniq-index distances)))))
  plane)

(fn area [plane index]
  (var res 0)
  (let [yx (aoc.table-transpose plane)
        x-edge (aoc.table-join (. plane 1) (. plane (# plane)))
        y-edge (aoc.table-join (. yx 1) (. yx (# yx)))
        edges (aoc.table-join x-edge y-edge)]
    (when (not (lume.find edges index))
      (for [y 1 (# plane)]
        (for [x 1 (# (. plane y))]
          (when (= index (. (. plane y) x))
            (set res (+ 1 res)))))))
  res)

(fn solve [input]
  (let [points (lume.map input #(aoc.string-tonumarray $))
        plane (populate (aoc.new-matrix 399 399 0) points)]
    (aoc.math-max (icollect [k v (ipairs points)] (area plane k)))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 17 test-input)

(solve (aoc.string-from "2018/06.inp"))
#+end_src

#+RESULTS:
: 3933


** DONE Day 6.2

On the other hand, =if the coordinates are safe=, maybe the best you can
do is try to find a =region= near as many coordinates as possible.

For example, suppose you want the sum of the [[https://en.wikipedia.org/wiki/Taxicab_geometry][Manhattan distance]] to all
of the coordinates to  be =less than 32=. For each  location, add up the
distances  to all  of the  given coordinates;  if the  total of  those
distances  is  less than  32,  that  location  is within  the  desired
region.  Using the  same coordinates  as above,  the resulting  region
looks like this:

#+begin_example
..........
.A........
..........
...###..C.
..#D###...
..###E#...
.B.###....
..........
..........
........F.
#+end_example

In particular,  consider the highlighted  location 4,3 located  at the
top middle of  the region. Its calculation is as  follows, where abs()
is the [[https://en.wikipedia.org/wiki/Absolute_value][absolute value]] function:

- Distance to coordinate A: abs(4-1) + abs(3-1) =  5
- Distance to coordinate B: abs(4-1) + abs(3-6) =  6
- Distance to coordinate C: abs(4-8) + abs(3-3) =  4
- Distance to coordinate D: abs(4-3) + abs(3-4) =  2
- Distance to coordinate E: abs(4-5) + abs(3-5) =  3
- Distance to coordinate F: abs(4-8) + abs(3-9) = 10
- Total distance: 5 + 6 + 4 + 2 + 3 + 10 = 30

Because the  total distance to all  coordinates (30) is less  than 32,
the location is =within= the region.

This region, which also includes coordinates D and E, has a total size
of 16.

Your actual  region will  need to  be much  larger than  this example,
though, instead including all locations  with a total distance of less
than 10000.

What is the  size of the region containing all  locations which have a
total distance to all given coordinates of less than 10000?

#+begin_src fennel -n :session d1806 :exports both
(fn populate2 [plane points]
  (for [y 1 (# plane)]
    (for [x 1 (# (. plane y))]
      (let [dist (icollect [i j (ipairs points)]
                   (aoc.manhattan-dist [x y] j))
            dist-sum (accumulate [s 0 _ dist (ipairs dist)]
                       (+ s dist))]
        (aoc.table-replace plane y x dist-sum))))
  plane)

(fn area2 [plane max-dist]
  (var res 0)
  (for [y 1 (# plane)]
    (for [x 1 (# (. plane y))]
      (when (< (. (. plane y) x) max-dist)
        (set res (+ 1 res)))))
  res)

(fn solve2 [input max]
  (let [points (lume.map input #(aoc.string-tonumarray $))
        plane (populate2 (aoc.new-matrix 399 399 0) points)]
    (area2 plane max)))

(fn test2 [expected input max]
  (assert (= expected (solve2 input max))))

(test2 16 test-input 32)

(solve2 (aoc.string-from "2018/06.inp") 10000)
#+end_src

#+RESULTS:
: 41145


** DONE Day 7.1

You find  yourself standing  on a snow-covered  coastline; apparently,
you landed  a little off  course. The region is  too hilly to  see the
North Pole  from here,  but you  do spot  some Elves  that seem  to be
trying to unpack something that washed ashore. It's quite cold out, so
you decide to risk creating a paradox by asking them for directions.

"Oh, are you  the search party?" Somehow, you  can understand whatever
Elves  from  the year  1018  speak;  you  assume it's  Ancient  Nordic
Elvish. Could  the device on your  wrist also be a  translator? "Those
clothes don't look very warm; take this." They hand you a heavy coat.

"We do need to find our way back to the North Pole, but we have higher
priorities  at the  moment.  You  see, believe  it  or  not, this  box
contains  something  that will  solve  all  of Santa's  transportation
problems -  at least, that's what  it looks like from  the pictures in
the  instructions."  It  doesn't  seem like  they  can  read  whatever
language it's in, but you can: "Sleigh kit. Some assembly required."

"'Sleigh'?  What a  wonderful name!  You  must help  us assemble  this
'sleigh' at once!" They start excitedly  pulling more parts out of the
box.

The  instructions specify  a series  of steps  and requirements  about
which  steps must  be finished  before others  can begin  (your puzzle
input).  Each step  is designated  by  a single  letter. For  example,
suppose you have the following instructions:
#+begin_example
Step C must be finished before step A can begin.
Step C must be finished before step F can begin.
Step A must be finished before step B can begin.
Step A must be finished before step D can begin.
Step B must be finished before step E can begin.
Step D must be finished before step E can begin.
Step F must be finished before step E can begin.
#+end_example

Visually, these requirements look like this:
#+begin_example
  -->A--->B--
 /    \      \
C      -->D----->E
 \           /
  ---->F-----
#+end_example

Your first goal is to determine the order in which the steps should be
completed. If  more than one step  is ready, choose the  step which is
first alphabetically. In this example, the steps would be completed as
follows:
- Only C is available, and so it is done first.
- Next, both A and F are available. A is first alphabetically, so it
  is done next.
- Then, even though F was available earlier, steps B and D are now
  also available, and B is the first alphabetically of the three.
- After that, only D and F are available. E is not available because
  only some of its prerequisites are complete. Therefore, D is
  completed next.
- F is the only choice, so it is done next.
- Finally, E is completed.

So, in this example, the correct order is CABDFE.

In what order should the steps in your instructions be completed?

#+begin_src fennel -n :session d1807 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["Step C must be finished before step A can begin."
        "Step C must be finished before step F can begin."
        "Step A must be finished before step B can begin."
        "Step A must be finished before step D can begin."
        "Step B must be finished before step E can begin."
        "Step D must be finished before step E can begin."
        "Step F must be finished before step E can begin."])

(fn read-lines [lines]
  (let [res []]
    (each [_ line (ipairs lines)]
      (let [[_ f _ _ _ _ _ t _ _] (aoc.string-split line " ")]
        (table.insert res [f t])))
    res))

(fn topo-sort [edges]
  (let [dag (aoc.adjacency-list edges)
        len (# (aoc.keys dag))
        ind {}
        queue []
        res []]
    (each [_ [f t] (ipairs edges)]
      (if (. ind f) nil (tset ind f 0))
      (if (. ind t)
          (tset ind t (+ 1 (. ind t)))
          (tset ind t 1)))
    (lume.each (aoc.keys (lume.filter ind #(= 0 $) true))
               (fn [e] (aoc.qpush queue e)))
    (while (aoc.not-empty? queue)
      (table.sort queue)
      (let [w (aoc.qpop queue)
            adj (. dag w)]
        (table.insert res w)
        (each [_ v (ipairs adj)]
          (let [decr (- (. ind v) 1)]
            (when (= 0 decr) (aoc.qpush queue v))
            (tset ind v decr)))))
    (if (not= (# res) len) nil res)))

(fn solve [input]
  (-> input
      (read-lines)
      (topo-sort)
      (aoc.table-tostring)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test "CABDFE" test-input)

(solve (aoc.string-from "2018/07.inp"))
#+end_src

#+RESULTS:
: ACHOQRXSEKUGMYIWDZLNBFTJVP

** TODO Day 7.2                                                   :noexport:

As you're  about to  begin construction,  four of  the Elves  offer to
help. "The  sun will set soon;  it'll go faster if  we work together."
Now,  you  need  to  account  for multiple  people  working  on  steps
simultaneously. If multiple steps  are available, workers should still
begin them in alphabetical order.

Each step takes 60 seconds plus an amount corresponding to its letter:
A=1, B=2, C=3, and so on. So, step A takes 60+1=61 seconds, while step
Z takes 60+26=86 seconds. No time is required between steps.

To simplify  things for  the example, however,  suppose you  only have
help from one Elf (a total of two workers) and that each step takes 60
fewer seconds  (so that  step A  takes 1  second and  step Z  takes 26
seconds). Then, using the same instructions as above, this is how each
second would be spent:

| Second | Worker1 | Worker2 | Done   |
|--------+---------+---------+--------|
|      0 | C       | .       |        |
|      1 | C       | .       |        |
|      2 | C       | .       |        |
|      3 | A       | F       | C      |
|      4 | B       | F       | CA     |
|      5 | B       | F       | CA     |
|      6 | D       | F       | CAB    |
|      7 | D       | F       | CAB    |
|      8 | D       | F       | CAB    |
|      9 | D       | .       | CABF   |
|     10 | E       | .       | CABFD  |
|     11 | E       | .       | CABFD  |
|     12 | E       | .       | CABFD  |
|     13 | E       | .       | CABFD  |
|     14 | E       | .       | CABFD  |
|     15 | .       | .       | CABFDE |

Each row represents  one second of time. The  Second column identifies
how many seconds have passed as  of the beginning of that second. Each
worker column shows  the step that worker is currently  doing (or . if
they are idle). The Done column shows completed steps.

Note that  the order of the  steps has changed; this  is because steps
now take time to finish and  multiple workers can begin multiple steps
simultaneously.

In this example, it would take  15 seconds for two workers to complete
these steps.

With 5 workers and the 60+  second step durations described above, how
long will it take to complete all of the steps?
** TODO Day 8.1                                                   :noexport:

The sleigh is much easier to  pull than you'd expect for something its
weight. Unfortunately,  neither you nor  the Elves know which  way the
North Pole is from here.

You check your wrist device for  anything that might help. It seems to
have some kind of navigation  system! Activating the navigation system
produces more bad news: "Failed  to start navigation system. Could not
read software license file."

The navigation  system's license  file consists of  a list  of numbers
(your puzzle input).  The numbers define a data  structure which, when
processed, produces  some kind of tree  that can be used  to calculate
the license number.

The  tree is  made up  of nodes;  a single,  outermost node  forms the
tree's root, and it contains all  other nodes in the tree (or contains
nodes that contain nodes, and so on).

Specifically, a node consists of:
#+begin_example
    A header, which is always exactly two numbers:
        The quantity of child nodes.
        The quantity of metadata entries.
    Zero or more child nodes (as specified in the header).
    One or more metadata entries (as specified in the header).
#+end_example

Each child node is itself a node that has its own header, child nodes,
and metadata. For example:
#+begin_example
2 3 0 3 10 11 12 1 1 0 1 99 2 1 1 2
A----------------------------------
    B----------- C-----------
                     D-----
#+end_example

In  this  example, each  node  of  the tree  is  also  marked with  an
underline starting  with a  letter for  easier identification.  In it,
there are four nodes:
- A, which has 2 child nodes (B, C) and 3 metadata entries (1, 1, 2).
- B, which has 0 child nodes and 3 metadata entries (10, 11, 12).
- C, which has 1 child node (D) and 1 metadata entry (2).
- D, which has 0 child nodes and 1 metadata entry (99).

The first check  done on the license  file is to simply add  up all of
the    metadata   entries.    In   this    example,   that    sum   is
1+1+2+10+11+12+2+99=138.

What is the sum of all metadata entries?
** TODO Day 8.2                                                   :noexport:

** TODO Day 9.1                                                   :noexport:

You talk  to the Elves  while you wait  for your navigation  system to
initialize. To  pass the  time, they introduce  you to  their favorite
marble game.

The Elves  play this game by  taking turns arranging the  marbles in a
circle according  to very particular  rules. The marbles  are numbered
starting with 0 and increasing by 1 until every marble has a number.

First, the marble  numbered 0 is placed in the  circle. At this point,
while it  contains only  a single  marble, it is  still a  circle: the
marble  is  both  clockwise  from itself  and  counter-clockwise  from
itself. This marble is designated the current marble.

Then,  each Elf  takes a  turn placing  the lowest-numbered  remaining
marble into  the circle between the  marbles that are 1  and 2 marbles
clockwise of  the current  marble. (When the  circle is  large enough,
this means that  there is one marble between the  marble that was just
placed and the  current marble.) The marble that was  just placed then
becomes the current marble.

However, if the marble  that is about to be placed  has a number which
is a multiple of 23,  something entirely different happens. First, the
current player keeps  the marble they would have placed,  adding it to
their score. In addition, the  marble 7 marbles counter-clockwise from
the current  marble is removed from  the circle and also  added to the
current player's  score. The  marble located immediately  clockwise of
the marble that was removed becomes the new current marble.

For example, suppose there are 9  players. After the marble with value
0 is  placed in  the middle,  each player  (shown in  square brackets)
takes a turn. The result of  each of those turns would produce circles
of  marbles  like this,  where  clockwise  is  to  the right  and  the
resulting current marble is in parentheses:
#+begin_example
[-] (0)
[1]  0 (1)
[2]  0 (2) 1 
[3]  0  2  1 (3)
[4]  0 (4) 2  1  3 
[5]  0  4  2 (5) 1  3 
[6]  0  4  2  5  1 (6) 3 
[7]  0  4  2  5  1  6  3 (7)
[8]  0 (8) 4  2  5  1  6  3  7 
[9]  0  8  4 (9) 2  5  1  6  3  7 
[1]  0  8  4  9  2(10) 5  1  6  3  7 
[2]  0  8  4  9  2 10  5(11) 1  6  3  7 
[3]  0  8  4  9  2 10  5 11  1(12) 6  3  7 
[4]  0  8  4  9  2 10  5 11  1 12  6(13) 3  7 
[5]  0  8  4  9  2 10  5 11  1 12  6 13  3(14) 7 
[6]  0  8  4  9  2 10  5 11  1 12  6 13  3 14  7(15)
[7]  0(16) 8  4  9  2 10  5 11  1 12  6 13  3 14  7 15 
[8]  0 16  8(17) 4  9  2 10  5 11  1 12  6 13  3 14  7 15 
[9]  0 16  8 17  4(18) 9  2 10  5 11  1 12  6 13  3 14  7 15 
[1]  0 16  8 17  4 18  9(19) 2 10  5 11  1 12  6 13  3 14  7 15 
[2]  0 16  8 17  4 18  9 19  2(20)10  5 11  1 12  6 13  3 14  7 15 
[3]  0 16  8 17  4 18  9 19  2 20 10(21) 5 11  1 12  6 13  3 14  7 15 
[4]  0 16  8 17  4 18  9 19  2 20 10 21  5(22)11  1 12  6 13  3 14  7 15 
[5]  0 16  8 17  4 18(19) 2 20 10 21  5 22 11  1 12  6 13  3 14  7 15 
[6]  0 16  8 17  4 18 19  2(24)20 10 21  5 22 11  1 12  6 13  3 14  7 15 
[7]  0 16  8 17  4 18 19  2 24 20(25)10 21  5 22 11  1 12  6 13  3 14  7 15
#+end_example

The goal  is to be  the player with the  highest score after  the last
marble is  used up. Assuming the  example above ends after  the marble
numbered  25, the  winning score  is  23+9=32 (because  player 5  kept
marble 23 and  removed marble 9, while no other  player got any points
in this very short example game).

Here are a few more examples:
- 10 players; last marble is worth 1618 points: high score is 8317
- 13 players; last marble is worth 7999 points: high score is 146373
- 17 players; last marble is worth 1104 points: high score is 2764
- 21 players; last marble is worth 6111 points: high score is 54718
- 30 players; last marble is worth 5807 points: high score is 37305

What is the winning Elf's score?
** TODO Day 9.2                                                   :noexport:



** TODO Day 10.1                                                  :noexport:

It's no use; your navigation system simply isn't capable of providing
walking directions in the arctic circle, and certainly not in 1018.

The  Elves suggest  an alternative.  In times  like these,  North Pole
rescue operations  will arrange points  of light  in the sky  to guide
missing  Elves back  to base.  Unfortunately, the  message is  easy to
miss: the points move slowly enough that it takes hours to align them,
but have so much momentum that they only stay aligned for a second. If
you blink at the wrong time,  it might be hours before another message
appears.

You can see these points of light floating in the distance, and record
their position in  the sky and their velocity, the  relative change in
position per second (your puzzle input). The coordinates are all given
from  your  perspective;  given   enough  time,  those  positions  and
velocities will move the points into a cohesive message!

Rather than wait, you decide to fast-forward the process and calculate
what the points will eventually spell.

For example, suppose you note the following points:
#+begin_example
position=< 9,  1> velocity=< 0,  2>
position=< 7,  0> velocity=<-1,  0>
position=< 3, -2> velocity=<-1,  1>
position=< 6, 10> velocity=<-2, -1>
position=< 2, -4> velocity=< 2,  2>
position=<-6, 10> velocity=< 2, -2>
position=< 1,  8> velocity=< 1, -1>
position=< 1,  7> velocity=< 1,  0>
position=<-3, 11> velocity=< 1, -2>
position=< 7,  6> velocity=<-1, -1>
position=<-2,  3> velocity=< 1,  0>
position=<-4,  3> velocity=< 2,  0>
position=<10, -3> velocity=<-1,  1>
position=< 5, 11> velocity=< 1, -2>
position=< 4,  7> velocity=< 0, -1>
position=< 8, -2> velocity=< 0,  1>
position=<15,  0> velocity=<-2,  0>
position=< 1,  6> velocity=< 1,  0>
position=< 8,  9> velocity=< 0, -1>
position=< 3,  3> velocity=<-1,  1>
position=< 0,  5> velocity=< 0, -1>
position=<-2,  2> velocity=< 2,  0>
position=< 5, -2> velocity=< 1,  2>
position=< 1,  4> velocity=< 2,  1>
position=<-2,  7> velocity=< 2, -2>
position=< 3,  6> velocity=<-1, -1>
position=< 5,  0> velocity=< 1,  0>
position=<-6,  0> velocity=< 2,  0>
position=< 5,  9> velocity=< 1, -2>
position=<14,  7> velocity=<-2,  0>
position=<-3,  6> velocity=< 2, -1>
#+end_example

Each line represents one point. Positions are given as <X, Y> pairs: X
represents  how far  left  (negative) or  right  (positive) the  point
appears, while Y  represents how far up (negative)  or down (positive)
the point appears.

At 0  seconds, each point  has the  position given. Each  second, each
point's velocity is  added to its position. So, a  point with velocity
<1,  -2>  is moving  to  the  right, but  is  moving  upward twice  as
quickly.  If  this point's  initial  position  were  <3, 9>,  after  3
seconds, its position would become <6, 3>.

Over time, the points listed above would move like this:
#+begin_example
Initially:
........#.............
................#.....
.........#.#..#.......
......................
#..........#.#.......#
...............#......
....#.................
..#.#....#............
.......#..............
......#...............
...#...#.#...#........
....#..#..#.........#.
.......#..............
...........#..#.......
#...........#.........
...#.......#..........

After 1 second:
......................
......................
..........#....#......
........#.....#.......
..#.........#......#..
......................
......#...............
....##.........#......
......#.#.............
.....##.##..#.........
........#.#...........
........#...#.....#...
..#...........#.......
....#.....#.#.........
......................
......................

After 2 seconds:
......................
......................
......................
..............#.......
....#..#...####..#....
......................
........#....#........
......#.#.............
.......#...#..........
.......#..#..#.#......
....#....#.#..........
.....#...#...##.#.....
........#.............
......................
......................
......................

After 3 seconds:
......................
......................
......................
......................
......#...#..###......
......#...#...#.......
......#...#...#.......
......#####...#.......
......#...#...#.......
......#...#...#.......
......#...#...#.......
......#...#..###......
......................
......................
......................
......................

After 4 seconds:
......................
......................
......................
............#.........
........##...#.#......
......#.....#..#......
.....#..##.##.#.......
.......##.#....#......
...........#....#.....
..............#.......
....#......#...#......
.....#.....##.........
...............#......
...............#......
......................
......................
#+end_example

After 3  seconds, the  message appeared briefly:  HI. Of  course, your
message will be much longer and will take many more seconds to appear.

What message will eventually appear in the sky?
** TODO Day 10.2                                                  :noexport:

** TODO Day 11.1                                                  :noexport:

You watch  the Elves and their  sleigh fade into the  distance as they
head toward the North Pole.

Actually, you're the one fading. The falling sensation returns.

The  low  fuel warning  light  is  illuminated on  your  wrist-mounted
device.  Tapping it  once  causes  it to  project  a  hologram of  the
situation:  a 300x300  grid  of  fuel cells  and  their current  power
levels, some  negative. You're not  sure what negative power  means in
the context of time travel, but it can't be good.

Each fuel cell  has a coordinate ranging  from 1 to 300 in  both the X
(horizontal) and Y (vertical) direction. In X,Y notation, the top-left
cell is 1,1, and the top-right cell is 300,1.

The  interface lets  you  select  any 3x3  square  of  fuel cells.  To
increase your  chances of getting  to your destination, you  decide to
choose the 3x3 square with the largest total power.

The  power  level in  a  given  fuel cell  can  be  found through  the
following process:
- Find the fuel cell's rack ID, which is its X coordinate plus 10.
- Begin with a power level of the rack ID times the Y coordinate.
- Increase the power level by the value of the grid serial number
  (your puzzle input).
- Set the power level to itself multiplied by the rack ID.
- Keep only the hundreds digit of the power level (so 12345 becomes 3;
  numbers with no hundreds digit become 0).
- Subtract 5 from the power level.

For example, to find the power level of the fuel cell at 3,5 in a grid
with serial number 8:
- The rack ID is 3 + 10 = 13.
- The power level starts at 13 * 5 = 65.
- Adding the serial number produces 65 + 8 = 73.
- Multiplying by the rack ID produces 73 * 13 = 949.
- The hundreds digit of 949 is 9.
- Subtracting 5 produces 9 - 5 = 4.

So, the power level of this fuel cell is 4.

Here are some more example power levels:
- Fuel cell at  122,79, grid serial number 57: power level -5.
- Fuel cell at 217,196, grid serial number 39: power level  0.
- Fuel cell at 101,153, grid serial number 71: power level  4.

Your  goal is  to find  the  3x3 square  which has  the largest  total
power. The square  must be entirely within the  300x300 grid. Identify
this square  using the X,Y coordinate  of its top-left fuel  cell. For
example:

For grid serial number 18, the largest total 3x3 square has a top-left
corner of 33,45 (with a total power of 29); these fuel cells appear in
the middle of this 5x5 region:
#+begin_example
-2  -4   4   4   4
-4   4   4   4  -5
 4   3   3   4  -4
 1   1   2   4  -3
-1   0   2  -5  -2
#+end_example

For grid serial number 42, the  largest 3x3 square's top-left is 21,61
(with a total power of 30); they are in the middle of this region:
#+begin_example
-3   4   2   2   2
-4   4   3   3   4
-5   3   3   4  -4
 4   3   3   4  -3
 3   3   3  -5  -1
#+end_example

What is the X,Y coordinate of the top-left fuel cell of the 3x3 square
with the largest total power?
** TODO Day 11.2                                                  :noexport:

** TODO Day 12.1                                                  :noexport:

The year 518 is significantly more underground than your history books
implied. Either that, or you've arrived in a vast cavern network under
the North Pole.

After exploring a  little, you discover a long tunnel  that contains a
row of small pots as far as you  can see to your left and right. A few
of them  contain plants -  someone is trying  to grow things  in these
geothermally-heated caves.

The pots are numbered,  with 0 in front of you. To  the left, the pots
are numbered  -1, -2, -3, and  so on; to  the right, 1, 2,  3.... Your
puzzle input contains a  list of pots from 0 to  the right and whether
they  do (#)  or do  not (.)  currently contain  a plant,  the initial
state.  (No other  pots  currently contain  plants.)  For example,  an
initial state of  #..##.... indicates that pots 0, 3,  and 4 currently
contain plants.

Your puzzle input also contains some notes you find on a nearby table:
someone  has been  trying to  figure out  how these  plants spread  to
nearby pots.  Based on  the notes,  for each  generation of  plants, a
given pot has or does not have  a plant based on whether that pot (and
the  two  pots  on  either  side  of it)  had  a  plant  in  the  last
generation. These are written  as LLCRR => N, where L  are pots to the
left, C  is the current  pot being considered, R  are the pots  to the
right, and N is whether the current  pot will have a plant in the next
generation. For example:
- A note like ..#.. => . means that a pot that contains a plant but
  with no plants within two pots of it will not have a plant in it
  during the next generation.
- A note like ##.## => . means that an empty pot with two plants on
  each side of it will remain empty in the next generation.
- A note like .##.# => # means that a pot has a plant in a given
  generation if, in the previous generation, there were plants in that
  pot, the one immediately to the left, and the one two pots to the
  right, but not in the ones immediately to the right and two to the
  left.
  
It's  not clear  what  these  plants are  for,  but  you're sure  it's
important, so  you'd like  to make sure  the current  configuration of
plants  is  sustainable  by  determining what  will  happen  after  20
generations.

For example, given the following input:
#+begin_example
initial state: #..#.#..##......###...###

...## => #
..#.. => #
.#... => #
.#.#. => #
.#.## => #
.##.. => #
.#### => #
#.#.# => #
#.### => #
##.#. => #
##.## => #
###.. => #
###.# => #
####. => #
#+end_example

For brevity, in this example, only the combinations which do produce a
plant  are listed.  (Your input  includes all  possible combinations.)
Then, the next 20 generations will look like this:

#+begin_example
                 1         2         3     
       0         0         0         0     
 0: ...#..#.#..##......###...###...........
 1: ...#...#....#.....#..#..#..#...........
 2: ...##..##...##....#..#..#..##..........
 3: ..#.#...#..#.#....#..#..#...#..........
 4: ...#.#..#...#.#...#..#..##..##.........
 5: ....#...##...#.#..#..#...#...#.........
 6: ....##.#.#....#...#..##..##..##........
 7: ...#..###.#...##..#...#...#...#........
 8: ...#....##.#.#.#..##..##..##..##.......
 9: ...##..#..#####....#...#...#...#.......
10: ..#.#..#...#.##....##..##..##..##......
11: ...#...##...#.#...#.#...#...#...#......
12: ...##.#.#....#.#...#.#..##..##..##.....
13: ..#..###.#....#.#...#....#...#...#.....
14: ..#....##.#....#.#..##...##..##..##....
15: ..##..#..#.#....#....#..#.#...#...#....
16: .#.#..#...#.#...##...#...#.#..##..##...
17: ..#...##...#.#.#.#...##...#....#...#...
18: ..##.#.#....#####.#.#.#...##...##..##..
19: .#..###.#..#.#.#######.#.#.#..#.#...#..
20: .#....##....#####...#######....#.#..##.
#+end_example

The  generation is  shown  along  the left,  where  0  is the  initial
state. The  pot numbers are  shown along the  top, where 0  labels the
center pot,  negative-numbered pots extend  to the left,  and positive
pots extend  toward the right.  Remember, the initial state  begins at
pot 0, which is not the leftmost pot used in this example.

After  one generation,  only seven  plants remain.  The one  in pot  0
matched the rule looking for ..#.., the  one in pot 4 matched the rule
looking for .#.#., pot 9 matched .##.., and so on.

In this  example, after 20  generations, the  pots shown as  # contain
plants, the furthest  left of which is pot -2,  and the furthest right
of which is pot 34. Adding up all the numbers of plant-containing pots
after the 20th generation produces 325.

After 20 generations, what is the sum of the numbers of all pots which
contain a plant?
** TODO Day 12.2                                                  :noexport:

** TODO Day 13.1                                                  :noexport:

A  crop  of this  size  requires  significant logistics  to  transport
produce, soil, fertilizer, and so on.  The Elves are very busy pushing
things around  in carts on some  kind of rudimentary system  of tracks
they've come up with.

Seeing as how cart-and-track systems  don't appear in recorded history
for another 1000 years, the Elves seem to be making this up as they go
along. They haven't even figured out how to avoid collisions yet.

You map out the tracks (your puzzle input) and see where you can help.

Tracks consist  of straight  paths (|  and -), curves  (/ and  \), and
intersections (+). Curves connect  exactly two perpendicular pieces of
track; for example, this is a closed loop:
#+begin_example
/----\
|    |
|    |
\----/
#+end_example

Intersections  occur  when  two   perpendicular  paths  cross.  At  an
intersection, a  cart is  capable of turning  left, turning  right, or
continuing   straight.   Here  are   two   loops   connected  by   two
intersections:
#+begin_example
/-----\
|     |
|  /--+--\
|  |  |  |
\--+--/  |
   |     |
   \-----/
#+end_example

Several carts are also on the tracks. Carts always face either up (^),
down (v),  left (<),  or right  (>). (On your  initial map,  the track
under each cart is a straight  path matching the direction the cart is
facing.)

Each  time  a  cart  has  the  option to  turn  (by  arriving  at  any
intersection), it turns left the  first time, goes straight the second
time, turns  right the third  time, and then repeats  those directions
starting again with left the fourth time, straight the fifth time, and
so on. This  process is independent of the  particular intersection at
which the cart has arrived - that is, the cart has no per-intersection
memory.

Carts all move at the same speed; they take turns moving a single step
at a time. They do this based  on their current location: carts on the
top row  move first  (acting from  left to right),  then carts  on the
second row  move (again from left  to right), then carts  on the third
row,  and so  on.  Once each  cart  has moved  one  step, the  process
repeats; each of these loops is called a tick.

For example, suppose there are two carts on a straight track:
#+begin_example
|  |  |  |  |
v  |  |  |  |
|  v  v  |  |
|  |  |  v  X
|  |  ^  ^  |
^  ^  |  |  |
|  |  |  |  |
#+end_example

First, the top cart moves. It is facing down (v), so it moves down one
square. Second,  the bottom  cart moves.  It is facing  up (^),  so it
moves up  one square.  Because all  carts have  moved, the  first tick
ends. Then,  the process  repeats, starting with  the first  cart. The
first cart moves down, then the second  cart moves up - right into the
first cart,  colliding with it! (The  location of the crash  is marked
with an X.) This ends the second and last tick.

Here is a longer example:
#+begin_example
/->-\        
|   |  /----\
| /-+--+-\  |
| | |  | v  |
\-+-/  \-+--/
  \------/   

/-->\        
|   |  /----\
| /-+--+-\  |
| | |  | |  |
\-+-/  \->--/
  \------/   

/---v        
|   |  /----\
| /-+--+-\  |
| | |  | |  |
\-+-/  \-+>-/
  \------/   

/---\        
|   v  /----\
| /-+--+-\  |
| | |  | |  |
\-+-/  \-+->/
  \------/   

/---\        
|   |  /----\
| /->--+-\  |
| | |  | |  |
\-+-/  \-+--^
  \------/   

/---\        
|   |  /----\
| /-+>-+-\  |
| | |  | |  ^
\-+-/  \-+--/
  \------/   

/---\        
|   |  /----\
| /-+->+-\  ^
| | |  | |  |
\-+-/  \-+--/
  \------/   

/---\        
|   |  /----<
| /-+-->-\  |
| | |  | |  |
\-+-/  \-+--/
  \------/   

/---\        
|   |  /---<\
| /-+--+>\  |
| | |  | |  |
\-+-/  \-+--/
  \------/   

/---\        
|   |  /--<-\
| /-+--+-v  |
| | |  | |  |
\-+-/  \-+--/
  \------/   

/---\        
|   |  /-<--\
| /-+--+-\  |
| | |  | v  |
\-+-/  \-+--/
  \------/   

/---\        
|   |  /<---\
| /-+--+-\  |
| | |  | |  |
\-+-/  \-<--/
  \------/   

/---\        
|   |  v----\
| /-+--+-\  |
| | |  | |  |
\-+-/  \<+--/
  \------/   

/---\        
|   |  /----\
| /-+--v-\  |
| | |  | |  |
\-+-/  ^-+--/
  \------/   

/---\        
|   |  /----\
| /-+--+-\  |
| | |  X |  |
\-+-/  \-+--/
  \------/   
#+end_example

After  following  their  respective  paths  for  a  while,  the  carts
eventually  crash. To  help prevent  crashes, you'd  like to  know the
location of the  first crash. Locations are given  in X,Y coordinates,
where the furthest left column is X=0 and the furthest top row is Y=0:
#+begin_example
           111
 0123456789012
0/---\        
1|   |  /----\
2| /-+--+-\  |
3| | |  X |  |
4\-+-/  \-+--/
5  \------/   
#+end_example

In this example, the location of the first crash is 7,3.
** TODO Day 13.2                                                  :noexport:

** TODO Day 14.1                                                  :noexport:

You  finally have  a  chance to  look  at all  of  the produce  moving
around.   Chocolate,   cinnamon,    mint,   chili   peppers,   nutmeg,
vanilla...  the  Elves  must  be  growing these  plants  to  make  hot
chocolate!  As  you realize  this,  you  hear  a conversation  in  the
distance. When you  go to investigate, you discover two  Elves in what
appears to be a makeshift underground kitchen/laboratory.

The  Elves are  trying  to come  up with  the  ultimate hot  chocolate
recipe; they're even maintaining a scoreboard which tracks the quality
score (0-9) of each recipe.

Only two recipes are on the board:  the first recipe got a score of 3,
the second, 7. Each  of the two Elves has a  current recipe: the first
Elf starts with  the first recipe, and the second  Elf starts with the
second recipe.

To  create   new  recipes,  the   two  Elves  combine   their  current
recipes. This  creates new recipes from  the digits of the  sum of the
current recipes' scores. With the current  recipes' scores of 3 and 7,
their sum is  10, and so two  new recipes would be  created: the first
with score  1 and  the second  with score 0.  If the  current recipes'
scores were 2 and 3, the sum,  5, would only create one recipe (with a
score of 5) with its single digit.

The new recipes  are added to the  end of the scoreboard  in the order
they are created.  So, after the first round, the  scoreboard is 3, 7,
1, 0.

After all  new recipes are added  to the scoreboard, each  Elf picks a
new current  recipe. To  do this,  the Elf  steps forward  through the
scoreboard a  number of  recipes equal  to 1 plus  the score  of their
current recipe. So, after the first round, the first Elf moves forward
1  + 3  = 4  times, while  the  second Elf  moves forward  1 +  7 =  8
times.  If they  run out  of  recipes, they  loop back  around to  the
beginning. After  the first  round, both Elves  happen to  loop around
until they land on the same recipe  that they had in the beginning; in
general, they will move to different recipes.

Drawing the  first Elf  as parentheses  and the  second Elf  as square
brackets, they continue this process:
#+begin_example
(3)[7]
(3)[7] 1  0 
 3  7  1 [0](1) 0 
 3  7  1  0 [1] 0 (1)
(3) 7  1  0  1  0 [1] 2 
 3  7  1  0 (1) 0  1  2 [4]
 3  7  1 [0] 1  0 (1) 2  4  5 
 3  7  1  0 [1] 0  1  2 (4) 5  1 
 3 (7) 1  0  1  0 [1] 2  4  5  1  5 
 3  7  1  0  1  0  1  2 [4](5) 1  5  8 
 3 (7) 1  0  1  0  1  2  4  5  1  5  8 [9]
 3  7  1  0  1  0  1 [2] 4 (5) 1  5  8  9  1  6 
 3  7  1  0  1  0  1  2  4  5 [1] 5  8  9  1 (6) 7 
 3  7  1  0 (1) 0  1  2  4  5  1  5 [8] 9  1  6  7  7 
 3  7 [1] 0  1  0 (1) 2  4  5  1  5  8  9  1  6  7  7  9 
 3  7  1  0 [1] 0  1  2 (4) 5  1  5  8  9  1  6  7  7  9  2 
#+end_example

The Elves  think their skill will  improve after making a  few recipes
(your puzzle input). However, that could take ages; you can speed this
up considerably  by identifying  the scores of  the ten  recipes after
that. For example:
- If the Elves think their skill will improve after making 9 recipes,
  the scores of the ten recipes after the first nine on the scoreboard
  would be 5158916779 (highlighted in the last line of the diagram).
- After 5 recipes, the scores of the next ten would be 0124515891.
- After 18 recipes, the scores of the next ten would be 9251071085.
- After 2018 recipes, the scores of the next ten would be 5941429882.

What are the scores of the ten recipes immediately after the number of
recipes in your puzzle input?
** TODO Day 14.2                                                  :noexport:

** TODO Day 15.1                                                  :noexport:

Having perfected  their hot chocolate,  the Elves have a  new problem:
the  Goblins that  live  in  these caves  will  do  anything to  steal
it. Looks like they're here for a fight.

You scan the area, generating a map of the walls (#), open cavern (.),
and starting  position of every  Goblin (G)  and Elf (E)  (your puzzle
input).

Combat proceeds  in rounds;  in each  round, each  unit that  is still
alive  takes a  turn, resolving  all of  its actions  before the  next
unit's turn begins.  On each unit's turn, it tries  to move into range
of an enemy (if it isn't already) and then attack (if it is in range).

All units  are very disciplined  and always follow very  strict combat
rules. Units  never move or  attack diagonally,  as doing so  would be
dishonorable. When multiple choices are equally valid, ties are broken
in reading order: top-to-bottom, then left-to-right. For instance, the
order in  which units take their  turns within a round  is the reading
order of  their starting  positions in that  round, regardless  of the
type  of unit  or  whether  other units  have  moved  after the  round
started. For example:
#+begin_example
                 would take their
These units:   turns in this order:
  #######           #######
  #.G.E.#           #.1.2.#
  #E.G.E#           #3.4.5#
  #.G.E.#           #.6.7.#
  #######           #######
#+end_example

Each unit begins  its turn by identifying all  possible targets (enemy
units). If no targets remain, combat ends.

Then, the  unit identifies  all of  the open squares  (.) that  are in
range  of  each target;  these  are  the  squares which  are  adjacent
(immediately up, down, left, or right)  to any target and which aren't
already occupied  by a wall  or another unit. Alternatively,  the unit
might already be in  range of a target. If the unit  is not already in
range of a target, and there are no open squares which are in range of
a target, the unit ends its turn.

If the  unit is already in  range of a  target, it does not  move, but
continues its turn with an attack. Otherwise, since it is not in range
of a target, it moves.

To move,  the unit first considers  the squares that are  in range and
determines  which  of those  squares  it  could  reach in  the  fewest
steps. A  step is a single  movement to any adjacent  (immediately up,
down, left, or right) open (.) square. Units cannot move into walls or
other  units.  The  unit  does  this  while  considering  the  current
positions of  units and does not  do any prediction about  where units
will be later. If the unit cannot  reach (find an open path to) any of
the squares that  are in range, it ends its  turn. If multiple squares
are in  range and tied  for being reachable  in the fewest  steps, the
square which is first in reading order is chosen. For example:
#+begin_example
Targets:      In range:     Reachable:    Nearest:      Chosen:
#######       #######       #######       #######       #######
#E..G.#       #E.?G?#       #E.@G.#       #E.!G.#       #E.+G.#
#...#.#  -->  #.?.#?#  -->  #.@.#.#  -->  #.!.#.#  -->  #...#.#
#.G.#G#       #?G?#G#       #@G@#G#       #!G.#G#       #.G.#G#
#######       #######       #######       #######       #######
#+end_example

In the above scenario, the Elf has three targets (the three Goblins):
- Each of the Goblins has open, adjacent squares which are in range
  (marked with a ? on the map).
- Of those squares, four are reachable (marked @); the other two (on
  the right) would require moving through a wall or unit to reach.
- Three of these reachable squares are nearest, requiring the fewest
  steps (only 2) to reach (marked !).
- Of those, the square which is first in reading order is chosen (+).

The unit then  takes a single step toward the  chosen square along the
shortest path  to that square.  If multiple  steps would put  the unit
equally closer to its destination, the  unit chooses the step which is
first in reading order. (This requires knowing when there is more than
one shortest path so that you can consider the first step of each such
path.) For example:
#+begin_example
In range:     Nearest:      Chosen:       Distance:     Step:
#######       #######       #######       #######       #######
#.E...#       #.E...#       #.E...#       #4E212#       #..E..#
#...?.#  -->  #...!.#  -->  #...+.#  -->  #32101#  -->  #.....#
#..?G?#       #..!G.#       #...G.#       #432G2#       #...G.#
#######       #######       #######       #######       #######
#+end_example

The Elf sees three squares in range  of a target (?), two of which are
nearest (!),  and so the first  in reading order is  chosen (+). Under
"Distance",  each open  square is  marked with  its distance  from the
destination square;  the two squares  to which  the Elf could  move on
this turn  (down and  to the  right) are both  equally good  moves and
would leave the Elf 2 steps from being in range of the Goblin. Because
the step  which is  first in  reading order is  chosen, the  Elf moves
right one square.

Here's a larger example of movement:
#+begin_example
Initially:
#########
#G..G..G#
#.......#
#.......#
#G..E..G#
#.......#
#.......#
#G..G..G#
#########

After 1 round:
#########
#.G...G.#
#...G...#
#...E..G#
#.G.....#
#.......#
#G..G..G#
#.......#
#########

After 2 rounds:
#########
#..G.G..#
#...G...#
#.G.E.G.#
#.......#
#G..G..G#
#.......#
#.......#
#########

After 3 rounds:
#########
#.......#
#..GGG..#
#..GEG..#
#G..G...#
#......G#
#.......#
#.......#
#########
#+end_example

Once  the Goblins  and Elf  reach the  positions above,  they all  are
either in range  of a target or  cannot find any square in  range of a
target, and so none of the units can move until a unit dies.

After moving (or if the unit began its turn in range of a target), the
unit attacks.

To attack,  the unit first determines  all of the targets  that are in
range of it by being immediately adjacent  to it. If there are no such
targets, the unit  ends its turn. Otherwise, the  adjacent target with
the fewest hit points is selected;  in a tie, the adjacent target with
the fewest hit points which is first in reading order is selected.

The  unit deals  damage  equal to  its attack  power  to the  selected
target, reducing  its hit points by  that amount. If this  reduces its
hit points to 0 or fewer, the selected target dies: its square becomes
. and it takes no further turns.

Each unit,  either Goblin or Elf,  has 3 attack power  and starts with
200 hit points.

For example, suppose the only Elf is about to attack:
#+begin_example
       HP:            HP:
G....  9       G....  9  
..G..  4       ..G..  4  
..EG.  2  -->  ..E..     
..G..  2       ..G..  2  
...G.  1       ...G.  1  
#+end_example

The "HP" column shows the hit points  of the Goblin to the left in the
corresponding row.  The Elf is in  range of three targets:  the Goblin
above it  (with 4  hit points), the  Goblin to its  right (with  2 hit
points), and  the Goblin below  it (also  with 2 hit  points). Because
three targets  are in range, the  ones with the lowest  hit points are
selected: the two Goblins with 2 hit  points each (one to the right of
the Elf and one below the Elf).  Of those, the Goblin first in reading
order (the  one to  the right  of the Elf)  is selected.  The selected
Goblin's hit  points (2) are  reduced by  the Elf's attack  power (3),
reducing its hit points to -1, killing it.

After attacking,  the unit's turn  ends. Regardless of how  the unit's
turn ends,  the next unit  in the round takes  its turn. If  all units
have  taken turns  in this  round,  the round  ends, and  a new  round
begins.

The Elves look quite outnumbered. You need to determine the outcome of
the  battle:  the number  of  full  rounds  that were  completed  (not
counting the round in which combat  ends) multiplied by the sum of the
hit points of  all remaining units at the moment  combat ends. (Combat
only ends when a unit finds no targets during its turn.)

Below is an entire sample combat.  Next to each map, each row's units'
hit points are listed from left to right.
#+begin_example
Initially:
#######   
#.G...#   G(200)
#...EG#   E(200), G(200)
#.#.#G#   G(200)
#..G#E#   G(200), E(200)
#.....#   
#######   

After 1 round:
#######   
#..G..#   G(200)
#...EG#   E(197), G(197)
#.#G#G#   G(200), G(197)
#...#E#   E(197)
#.....#   
#######   

After 2 rounds:
#######   
#...G.#   G(200)
#..GEG#   G(200), E(188), G(194)
#.#.#G#   G(194)
#...#E#   E(194)
#.....#   
#######   
#+end_example

Combat ensues; eventually, the top Elf dies:
#+begin_example
After 23 rounds:
#######   
#...G.#   G(200)
#..G.G#   G(200), G(131)
#.#.#G#   G(131)
#...#E#   E(131)
#.....#   
#######   

After 24 rounds:
#######   
#..G..#   G(200)
#...G.#   G(131)
#.#G#G#   G(200), G(128)
#...#E#   E(128)
#.....#   
#######   

After 25 rounds:
#######   
#.G...#   G(200)
#..G..#   G(131)
#.#.#G#   G(125)
#..G#E#   G(200), E(125)
#.....#   
#######   

After 26 rounds:
#######   
#G....#   G(200)
#.G...#   G(131)
#.#.#G#   G(122)
#...#E#   E(122)
#..G..#   G(200)
#######   

After 27 rounds:
#######   
#G....#   G(200)
#.G...#   G(131)
#.#.#G#   G(119)
#...#E#   E(119)
#...G.#   G(200)
#######   

After 28 rounds:
#######   
#G....#   G(200)
#.G...#   G(131)
#.#.#G#   G(116)
#...#E#   E(113)
#....G#   G(200)
#######   
#+end_example

More combat ensues; eventually, the bottom Elf dies:
#+begin_example
After 47 rounds:
#######   
#G....#   G(200)
#.G...#   G(131)
#.#.#G#   G(59)
#...#.#   
#....G#   G(200)
#######   
#+end_example

Before the 48th round can finish, the top-left Goblin finds that there
are no targets  remaining, and so combat ends. So,  the number of full
rounds that were completed is 47, and the sum of the hit points of all
remaining units  is 200+131+59+200 =  590. From these, the  outcome of
the battle is 47 * 590 = 27730.

Here are a few example summarized combats:
#+begin_example
#######       #######
#G..#E#       #...#E#   E(200)
#E#E.E#       #E#...#   E(197)
#G.##.#  -->  #.E##.#   E(185)
#...#E#       #E..#E#   E(200), E(200)
#...E.#       #.....#
#######       #######

Combat ends after 37 full rounds
Elves win with 982 total hit points left
Outcome: 37 * 982 = 36334

#######       #######   
#E..EG#       #.E.E.#   E(164), E(197)
#.#G.E#       #.#E..#   E(200)
#E.##E#  -->  #E.##.#   E(98)
#G..#.#       #.E.#.#   E(200)
#..E#.#       #...#.#   
#######       #######   

Combat ends after 46 full rounds
Elves win with 859 total hit points left
Outcome: 46 * 859 = 39514

#######       #######   
#E.G#.#       #G.G#.#   G(200), G(98)
#.#G..#       #.#G..#   G(200)
#G.#.G#  -->  #..#..#   
#G..#.#       #...#G#   G(95)
#...E.#       #...G.#   G(200)
#######       #######   

Combat ends after 35 full rounds
Goblins win with 793 total hit points left
Outcome: 35 * 793 = 27755

#######       #######   
#.E...#       #.....#   
#.#..G#       #.#G..#   G(200)
#.###.#  -->  #.###.#   
#E#G#G#       #.#.#.#   
#...#G#       #G.G#G#   G(98), G(38), G(200)
#######       #######   

Combat ends after 54 full rounds
Goblins win with 536 total hit points left
Outcome: 54 * 536 = 28944

#########       #########   
#G......#       #.G.....#   G(137)
#.E.#...#       #G.G#...#   G(200), G(200)
#..##..G#       #.G##...#   G(200)
#...##..#  -->  #...##..#   
#...#...#       #.G.#...#   G(200)
#.G...G.#       #.......#   
#.....G.#       #.......#   
#########       #########   

Combat ends after 20 full rounds
Goblins win with 937 total hit points left
Outcome: 20 * 937 = 18740
#+end_example

What is the outcome of the combat described in your puzzle input?
** TODO Day 15.2                                                  :noexport:

** TODO Day 16.1                                                  :noexport:

As you see  the Elves defend their hot chocolate  successfully, you go
back to falling through time. This is going to become a problem.

If  you're  ever  going to  return  to  your  own  time, you  need  to
understand how  this device  on your  wrist works.  You have  a little
while before you reach your next  destination, and with a bit of trial
and error, you manage to pull  up a programming manual on the device's
tiny screen.

According to  the manual,  the device has  four registers  (numbered 0
through 3) that  can be manipulated by instructions  containing one of
16 opcodes. The registers start with the value 0.

Every  instruction consists  of  four values:  an  opcode, two  inputs
(named A and  B), and an output  (named C), in that  order. The opcode
specifies  the behavior  of the  instruction  and how  the inputs  are
interpreted. The output, C, is always treated as a register.

In  the opcode  descriptions below,  if something  says "value  A", it
means to take the number given as A literally. (This is also called an
"immediate" value.)  If something says  "register A", it means  to use
the number  given as A  to read from (or  write to) the  register with
that  number. So,  if the  opcode addi  adds register  A and  value B,
storing the result  in register C, and  the instruction addi 0  7 3 is
encountered, it would  add 7 to the value contained  by register 0 and
store the sum in  register 3, never modifying registers 0,  1, or 2 in
the process.

Many  opcodes  are  similar  except   for  how  they  interpret  their
arguments. The opcodes fall into seven general categories:

Addition:
- addr (add register) stores into register C the result of adding
  register A and register B.
- addi (add immediate) stores into register C the result of adding
  register A and value B.
  
Multiplication:
- mulr (multiply register) stores into register C the result of
  multiplying register A and register B.
- muli (multiply immediate) stores into register C the result of
  multiplying register A and value B.
  
Bitwise AND:
- banr (bitwise AND register) stores into register C the result of the
  bitwise AND of register A and register B.
- bani (bitwise AND immediate) stores into register C the result of
  the bitwise AND of register A and value B.
  
Bitwise OR:
- borr (bitwise OR register) stores into register C the result of the
  bitwise OR of register A and register B.
- bori (bitwise OR immediate) stores into register C the result of the
  bitwise OR of register A and value B.
  
Assignment:
- setr (set register) copies the contents of register A into register
  C. (Input B is ignored.)
- seti (set immediate) stores value A into register C. (Input B is
  ignored.)
  
Greater-than testing:
- gtir (greater-than immediate/register) sets register C to 1 if value
  A is greater than register B. Otherwise, register C is set to 0.
- gtri (greater-than register/immediate) sets register C to 1 if
  register A is greater than value B. Otherwise, register C is set
  to 0.
- gtrr (greater-than register/register) sets register C to 1 if
  register A is greater than register B. Otherwise, register C is set
  to 0.
  
Equality testing:
- eqir (equal immediate/register) sets register C to 1 if value A is
  equal to register B. Otherwise, register C is set to 0.
- eqri (equal register/immediate) sets register C to 1 if register A
  is equal to value B. Otherwise, register C is set to 0.
- eqrr (equal register/register) sets register C to 1 if register A is
  equal to register B. Otherwise, register C is set to 0.
  
Unfortunately,  while the  manual gives  the name  of each  opcode, it
doesn't seem to indicate the number.  However, you can monitor the CPU
to see the contents of the registers before and after instructions are
executed to  try to  work them out.  Each opcode has  a number  from 0
through 15,  but the manual doesn't  say which is which.  For example,
suppose you capture the following sample:
#+begin_example
Before: [3, 2, 1, 1]
9 2 1 2
After:  [3, 2, 2, 1]
#+end_example

This  sample shows  the effect  of  the instruction  9  2 1  2 on  the
registers. Before the instruction is executed, register 0 has value 3,
register 1 has value 2, and registers  2 and 3 have value 1. After the
instruction is executed, register 2's value becomes 2.

The instruction itself, 9 2 1 2, means that opcode 9 was executed with
A=2, B=1,  and C=2.  Opcode 9 could  be any of  the 16  opcodes listed
above, but  only three of  them behave in a  way that would  cause the
result shown in the sample:
- Opcode 9 could be mulr: register 2 (which has a value of 1) times
  register 1 (which has a value of 2) produces 2, which matches the
  value stored in the output register, register 2.
- Opcode 9 could be addi: register 2 (which has a value of 1) plus
  value 1 produces 2, which matches the value stored in the output
  register, register 2.
- Opcode 9 could be seti: value 2 matches the value stored in the
  output register, register 2; the number given for B is irrelevant.
  
None  of  the  other  opcodes  produce  the  result  captured  in  the
sample. Because of this, the sample above behaves like three opcodes.

You collect  many of these samples  (the first section of  your puzzle
input).  The manual  also includes  a small  test program  (the second
section of your puzzle input) - you can ignore it for now.

Ignoring the  opcode numbers,  how many samples  in your  puzzle input
behave like three or more opcodes?
** TODO Day 16.2                                                  :noexport:

** TODO Day 17.1                                                  :noexport:

You arrive in the year 18. If it weren't for the coat you got in 1018,
you  would  be  very  cold:  the North  Pole  base  hasn't  even  been
constructed.

Rather, it hasn't been constructed yet.  The Elves are making a little
progress, but  there's not a lot  of liquid water in  this climate, so
they're getting very dehydrated. Maybe there's more underground?

You scan  a two-dimensional  vertical slice of  the ground  nearby and
discover that  it is  mostly sand  with veins of  clay. The  scan only
provides data  with a granularity of  square meters, but it  should be
good enough to determine how much water is trapped there. In the scan,
x represents the distance to the  right, and y represents the distance
down.  There is  also a  spring of  water near  the surface  at x=500,
y=0. The  scan identifies  which square meters  are clay  (your puzzle
input).

For example, suppose your scan shows the following veins of clay:
#+begin_example
x=495, y=2..7
y=7, x=495..501
x=501, y=3..7
x=498, y=2..4
x=506, y=1..2
x=498, y=10..13
x=504, y=10..13
y=13, x=498..504
#+end_example

Rendering clay as #, sand as ., and  the water spring as +, and with x
increasing to the right and y increasing downward, this becomes:
#+begin_example
   44444455555555
   99999900000000
   45678901234567
 0 ......+.......
 1 ............#.
 2 .#..#.......#.
 3 .#..#..#......
 4 .#..#..#......
 5 .#.....#......
 6 .#.....#......
 7 .#######......
 8 ..............
 9 ..............
10 ....#.....#...
11 ....#.....#...
12 ....#.....#...
13 ....#######...
#+end_example

The spring of water will produce water forever. Water can move through
sand, but is  blocked by clay. Water always moves  down when possible,
and spreads  to the left and  right otherwise, filling space  that has
clay on both sides and falling out otherwise.

For example,  if five  squares of  water are  created, they  will flow
downward until  they reach the clay  and settle there. Water  that has
come to rest  is shown here as  ~, while sand through  which water has
passed (but which is now dry again) is shown as |:
#+begin_example
......+.......
......|.....#.
.#..#.|.....#.
.#..#.|#......
.#..#.|#......
.#....|#......
.#~~~~~#......
.#######......
..............
..............
....#.....#...
....#.....#...
....#.....#...
....#######...
#+end_example

Two squares of  water can't occupy the same location.  If another five
squares of  water are  created, they  will settle  on the  first five,
filling the clay reservoir a little more:
#+begin_example
......+.......
......|.....#.
.#..#.|.....#.
.#..#.|#......
.#..#.|#......
.#~~~~~#......
.#~~~~~#......
.#######......
..............
..............
....#.....#...
....#.....#...
....#.....#...
....#######...
#+end_example

Water  pressure does  not  apply  in this  scenario.  If another  four
squares of water are created, they will  stay on the right side of the
barrier, and no water will reach the left side:
#+begin_example
......+.......
......|.....#.
.#..#.|.....#.
.#..#~~#......
.#..#~~#......
.#~~~~~#......
.#~~~~~#......
.#######......
..............
..............
....#.....#...
....#.....#...
....#.....#...
....#######...
#+end_example

At this point, the top reservoir  overflows. While water can reach the
tiles above the  surface of the water, it cannot  settle there, and so
the next five squares of water settle like this:
#+begin_example
......+.......
......|.....#.
.#..#||||...#.
.#..#~~#|.....
.#..#~~#|.....
.#~~~~~#|.....
.#~~~~~#|.....
.#######|.....
........|.....
........|.....
....#...|.#...
....#...|.#...
....#~~~~~#...
....#######...
#+end_example

Note especially  the leftmost |:  the new  squares of water  can reach
this tile, but  cannot stop there. Instead, eventually,  they all fall
to the right and settle in the reservoir below.

After 10 more squares of water, the bottom reservoir is also full:
#+begin_example
......+.......
......|.....#.
.#..#||||...#.
.#..#~~#|.....
.#..#~~#|.....
.#~~~~~#|.....
.#~~~~~#|.....
.#######|.....
........|.....
........|.....
....#~~~~~#...
....#~~~~~#...
....#~~~~~#...
....#######...
#+end_example

Finally, while there  is nowhere left for the water  to settle, it can
reach a  few more tiles  before overflowing  beyond the bottom  of the
scanned data:
#+begin_example
......+.......    (line not counted: above minimum y value)
......|.....#.
.#..#||||...#.
.#..#~~#|.....
.#..#~~#|.....
.#~~~~~#|.....
.#~~~~~#|.....
.#######|.....
........|.....
...|||||||||..
...|#~~~~~#|..
...|#~~~~~#|..
...|#~~~~~#|..
...|#######|..
...|.......|..    (line not counted: below maximum y value)
...|.......|..    (line not counted: below maximum y value)
...|.......|..    (line not counted: below maximum y value)
#+end_example

How  many tiles  can  be reached  by the  water?  To prevent  counting
forever, ignore tiles with a y  coordinate smaller than the smallest y
coordinate in  your scan data  or larger than  the largest one.  Any x
coordinate is valid. In this example, the lowest y coordinate given is
1, and the highest is 13, causing  the water spring (in row 0) and the
water  falling off  the  bottom  of the  render  (in  rows 14  through
infinity) to be ignored.

So, in  the example above, counting  both water at rest  (~) and other
sand tiles the water can hypothetically reach (|), the total number of
tiles the water can reach is 57.

How many tiles can the water reach within the range of y values in
your scan?
** TODO Day 17.2                                                  :noexport:

** TODO Day 18.1                                                  :noexport:

On the  outskirts of  the North Pole  base construction  project, many
Elves are collecting lumber.

The lumber collection area  is 50 acres by 50 acres;  each acre can be
either open  ground (.), trees  (|), or a  lumberyard (#). You  take a
scan of the area (your puzzle input).

Strange  magic is  at  work  here: each  minute,  the landscape  looks
entirely different. In exactly one minute,  an open acre can fill with
trees, a wooded acre can be converted to a lumberyard, or a lumberyard
can be  cleared to open ground  (the lumber having been  sent to other
projects).

The change to each acre is based entirely on the contents of that acre
as well as the number of open, wooded, or lumberyard acres adjacent to
it at  the start  of each  minute. Here, "adjacent"  means any  of the
eight acres surrounding  that acre. (Acres on the edges  of the lumber
collection  area  might have  fewer  than  eight adjacent  acres;  the
missing acres aren't counted.)

In particular:
- An open acre will become filled with trees if three or more adjacent
  acres contained trees. Otherwise, nothing happens.
- An acre filled with trees will become a lumberyard if three or more
  adjacent acres were lumberyards. Otherwise, nothing happens.
- An acre containing a lumberyard will remain a lumberyard if it was
  adjacent to at least one other lumberyard and at least one acre
  containing trees. Otherwise, it becomes open.
  
These changes  happen across  all acres  simultaneously, each  of them
using  the state  of all  acres  at the  beginning of  the minute  and
changing to  their new form  by the end  of that same  minute. Changes
that happen during the minute don't affect each other.

For example, suppose the lumber collection  area is instead only 10 by
10 acres with this initial configuration:
#+begin_example
Initial state:
.#.#...|#.
.....#|##|
.|..|...#.
..|#.....#
#.#|||#|#|
...#.||...
.|....|...
||...#|.#|
|.||||..|.
...#.|..|.

After 1 minute:
.......##.
......|###
.|..|...#.
..|#||...#
..##||.|#|
...#||||..
||...|||..
|||||.||.|
||||||||||
....||..|.

After 2 minutes:
.......#..
......|#..
.|.|||....
..##|||..#
..###|||#|
...#|||||.
|||||||||.
||||||||||
||||||||||
.|||||||||

After 3 minutes:
.......#..
....|||#..
.|.||||...
..###|||.#
...##|||#|
.||##|||||
||||||||||
||||||||||
||||||||||
||||||||||

After 4 minutes:
.....|.#..
...||||#..
.|.#||||..
..###||||#
...###||#|
|||##|||||
||||||||||
||||||||||
||||||||||
||||||||||

After 5 minutes:
....|||#..
...||||#..
.|.##||||.
..####|||#
.|.###||#|
|||###||||
||||||||||
||||||||||
||||||||||
||||||||||

After 6 minutes:
...||||#..
...||||#..
.|.###|||.
..#.##|||#
|||#.##|#|
|||###||||
||||#|||||
||||||||||
||||||||||
||||||||||

After 7 minutes:
...||||#..
..||#|##..
.|.####||.
||#..##||#
||##.##|#|
|||####|||
|||###||||
||||||||||
||||||||||
||||||||||

After 8 minutes:
..||||##..
..|#####..
|||#####|.
||#...##|#
||##..###|
||##.###||
|||####|||
||||#|||||
||||||||||
||||||||||

After 9 minutes:
..||###...
.||#####..
||##...##.
||#....###
|##....##|
||##..###|
||######||
|||###||||
||||||||||
||||||||||

After 10 minutes:
.||##.....
||###.....
||##......
|##.....##
|##.....##
|##....##|
||##.####|
||#####|||
||||#|||||
||||||||||
#+end_example

After   10   minutes,    there   are   37   wooded    acres   and   31
lumberyards. Multiplying the  number of wooded acres by  the number of
lumberyards gives the total resource value  after ten minutes: 37 * 31
= 1147.

What will  the total resource value  of the lumber collection  area be
after 10 minutes?
** TODO Day 18.2                                                  :noexport:

** TODO Day 19.1                                                  :noexport:

With the Elves well on their way constructing the North Pole base, you
turn  your  attention back  to  understanding  the inner  workings  of
programming the device.

You can't help but notice that  the device's opcodes don't contain any
flow control  like jump instructions.  The device's manual goes  on to
explain:

"In programs where  flow control is required,  the instruction pointer
can  be   bound  to  a  register   so  that  it  can   be  manipulated
directly.  This  way,  setr/seti   can  function  as  absolute  jumps,
addr/addi can function as relative  jumps, and other opcodes can cause
truly fascinating effects."

This mechanism  is achieved  through a declaration  like #ip  1, which
would  modify register  1  so  that accesses  to  it  let the  program
indirectly access  the instruction  pointer itself. To  compensate for
this kind of binding, there are  now six registers (numbered 0 through
5);  the  five  not  bound   to  the  instruction  pointer  behave  as
normal. Otherwise,  the same rules apply  as the last time  you worked
with this device.

When the  instruction pointer  is bound  to a  register, its  value is
written to that register just before each instruction is executed, and
the value of that register is  written back to the instruction pointer
immediately after each instruction finishes execution. Afterward, move
to the next instruction by adding one to the instruction pointer, even
if  the value  in  the  instruction pointer  was  just  updated by  an
instruction. (Because  of this, instructions must  effectively set the
instruction  pointer  to the  instruction  before  the one  they  want
executed next.)

The instruction  pointer is 0  during the first instruction,  1 during
the second,  and so  on. If  the instruction  pointer ever  causes the
device  to attempt  to load  an instruction  outside the  instructions
defined in  the program,  the program  instead immediately  halts. The
instruction pointer starts at 0.

It turns out that this new  information is already proving useful: the
CPU in  the device is not  very powerful, and a  background process is
occupying  most  of  its  time.   You  dump  the  background  process'
declarations and  instructions to a  file (your puzzle  input), making
sure to use the names of the opcodes rather than the numbers.

For example, suppose you have the following program:
#+begin_example
#ip 0
seti 5 0 1
seti 6 0 2
addi 0 1 0
addr 1 2 3
setr 1 0 0
seti 8 0 4
seti 9 0 5
#+end_example

When  executed, the  following  instructions are  executed. Each  line
contains  the  value  of  the  instruction pointer  at  the  time  the
instruction started, the values of  the six registers before executing
the instructions (in square brackets), the instruction itself, and the
values of the  six registers after executing the  instruction (also in
square brackets).
#+begin_example
ip=0 [0, 0, 0, 0, 0, 0] seti 5 0 1 [0, 5, 0, 0, 0, 0]
ip=1 [1, 5, 0, 0, 0, 0] seti 6 0 2 [1, 5, 6, 0, 0, 0]
ip=2 [2, 5, 6, 0, 0, 0] addi 0 1 0 [3, 5, 6, 0, 0, 0]
ip=4 [4, 5, 6, 0, 0, 0] setr 1 0 0 [5, 5, 6, 0, 0, 0]
ip=6 [6, 5, 6, 0, 0, 0] seti 9 0 5 [6, 5, 6, 0, 0, 9]
#+end_example

In detail, when running this program, the following events occur:
- The first line (#ip 0) indicates that the instruction pointer should
  be bound to register 0 in this program. This is not an instruction,
  and so the value of the instruction pointer does not change during
  the processing of this line.
- The instruction pointer contains 0, and so the first instruction is
  executed (seti 5 0 1). It updates register 0 to the current
  instruction pointer value (0), sets register 1 to 5, sets the
  instruction pointer to the value of register 0 (which has no effect,
  as the instruction did not modify register 0), and then adds one to
  the instruction pointer.
- The instruction pointer contains 1, and so the second instruction,
  seti 6 0 2, is executed. This is very similar to the instruction
  before it: 6 is stored in register 2, and the instruction pointer is
  left with the value 2.
- The instruction pointer is 2, which points at the instruction addi 0
  1 0. This is like a relative jump: the value of the instruction
  pointer, 2, is loaded into register 0. Then, addi finds the result
  of adding the value in register 0 and the value 1, storing the
  result, 3, back in register 0. Register 0 is then copied back to the
  instruction pointer, which will cause it to end up 1 larger than it
  would have otherwise and skip the next instruction (addr 1 2 3)
  entirely. Finally, 1 is added to the instruction pointer.
- The instruction pointer is 4, so the instruction setr 1 0 0 is
  run. This is like an absolute jump: it copies the value contained in
  register 1, 5, into register 0, which causes it to end up in the
  instruction pointer. The instruction pointer is then incremented,
  leaving it at 6.
- The instruction pointer is 6, so the instruction seti 9 0 5 stores 9
  into register 5. The instruction pointer is incremented, causing it
  to point outside the program, and so the program ends.

What value is left in register 0 when the background process halts?
** TODO Day 19.2                                                  :noexport:

** TODO Day 20.1                                                  :noexport:

While you  were learning  about instruction  pointers, the  Elves made
considerable progress. When  you look up, you discover  that the North
Pole base construction project has completely surrounded you.

The area you are in is made  up entirely of rooms and doors. The rooms
are arranged in a grid, and  rooms only connect to adjacent rooms when
a door is present between them.

For example,  drawing rooms as .,  walls as #,  doors as | or  -, your
current position as X, and where north is up, the area you're in might
look like this:
#+begin_example
#####
#.|.#
#-###
#.|X#
#####
#+end_example

You get  the attention  of a  passing construction Elf  and ask  for a
map.  "I don't  have time  to draw  out  a map  of this  place -  it's
huge.  Instead,  I can  give  you  directions  to  every room  in  the
facility!" He writes down some directions  on a piece of parchment and
runs  off. In  the example  above,  the instructions  might have  been
^WNE$, a regular expression or "regex" (your puzzle input).

The regex matches routes (like WNE  for "west, north, east") that will
take  you  from  your  current  room  through  various  doors  in  the
facility. In aggregate, the routes will take you through every door in
the facility at  least once; mapping out all of  these routes will let
you build a proper map and find your way around.

^ and $  are at the beginning  and end of your regex;  these just mean
that  the  regex   doesn't  match  anything  outside   the  routes  it
describes.  (Specifically, ^  matches the  start of  the route,  and $
matches the end of it.) These  characters will not appear elsewhere in
the regex.

The rest  of the regex matches  various sequences of the  characters N
(north), S  (south), E  (east), and  W (west).  In the  example above,
^WNE$ matches only one route, WNE, which means you can move west, then
north, then east from your current position. Sequences of letters like
this always match that exact route in the same order.

Sometimes,  the route  can branch.  A  branch is  given by  a list  of
options  separated  by  pipes  (|) and  wrapped  in  parentheses.  So,
^N(E|W)N$ contains a branch: after going  north, you must choose to go
either  east  or west  before  finishing  your  route by  going  north
again. By  tracing out  the possible routes  after branching,  you can
determine where the  doors are and, therefore, where the  rooms are in
the facility.

For example, consider this regex: ^ENWWW(NEEE|SSE(EE|N))$

This  regex begins  with ENWWW,  which  means that  from your  current
position, all routes  must begin by moving east, north,  and then west
three times, in that order. After  this, there is a branch. Before you
consider the branch, this is what you  know about the map so far, with
doors you aren't sure about marked with a ?:
#+begin_example
#?#?#?#?#
?.|.|.|.?
#?#?#?#-#
    ?X|.?
    #?#?#
#+end_example

After this  point, there is  (NEEE|SSE(EE|N)). This gives  you exactly
two options: NEEE and SSE(EE|N). By  following NEEE, the map now looks
like this:
#+begin_example
#?#?#?#?#
?.|.|.|.?
#-#?#?#?#
?.|.|.|.?
#?#?#?#-#
    ?X|.?
    #?#?#
#+end_example

Now, only SSE(EE|N)  remains. Because it is in  the same parenthesized
group as NEEE, it starts from the same room NEEE started in. It states
that starting from that point, there  exist doors which will allow you
to move south twice, then east;  this ends up at another branch. After
that, you can  either move east twice or north  once. This information
fills in the rest of the doors:
#+begin_example
#?#?#?#?#
?.|.|.|.?
#-#?#?#?#
?.|.|.|.?
#-#?#?#-#
?.?.?X|.?
#-#-#?#?#
?.|.|.|.?
#?#?#?#?#
#+end_example

Once  you've followed  all  possible routes,  you  know the  remaining
unknown parts are all walls, producing a finished map of the facility:
#+begin_example
#########
#.|.|.|.#
#-#######
#.|.|.|.#
#-#####-#
#.#.#X|.#
#-#-#####
#.|.|.|.#
#########
#+end_example

Sometimes,  a  list  of  options   can  have  an  empty  option,  like
(NEWS|WNSE|). This means  that routes at this  point could effectively
skip the options in parentheses  and move on immediately. For example,
consider this regex and the corresponding map:
#+begin_example
^ENNWSWW(NEWS|)SSSEEN(WNSE|)EE(SWEN|)NNN$

###########
#.|.#.|.#.#
#-###-#-#-#
#.|.|.#.#.#
#-#####-#-#
#.#.#X|.#.#
#-#-#####-#
#.#.|.|.|.#
#-###-###-#
#.|.|.#.|.#
###########
#+end_example

This  regex  has  one  main  route  which,  at  three  locations,  can
optionally include additional detours  and be valid: (NEWS|), (WNSE|),
and (SWEN|). Regardless of which  option is taken, the route continues
from the  position it  is left  at after taking  those steps.  So, for
example, this regex matches all of the following routes (and more that
aren't listed here):
- ENNWSWWSSSEENEENNN
- ENNWSWWNEWSSSSEENEENNN
- ENNWSWWNEWSSSSEENEESWENNNN
- ENNWSWWSSSEENWNSEEENNN

By following the  various routes the regex matches, a  full map of all
of the doors and rooms in the facility can be assembled.

To get a sense for the size  of this facility, you'd like to determine
which room is furthest from you:  specifically, you would like to find
the  room for  which  the shortest  path to  that  room would  require
passing through the most doors.
- In the first example (^WNE$), this would be the north-east corner 3
  doors away.
- In the second example (^ENWWW(NEEE|SSE(EE|N))$), this would be the
  south-east corner 10 doors away.
- In the third example (^ENNWSWW(NEWS|)SSSEEN(WNSE|)EE(SWEN|)NNN$),
  this would be the north-east corner 18 doors away.
  
Here are a few more examples:
#+begin_example
Regex: ^ESSWWN(E|NNENN(EESS(WNSE|)SSS|WWWSSSSE(SW|NNNE)))$
Furthest room requires passing 23 doors

#############
#.|.|.|.|.|.#
#-#####-###-#
#.#.|.#.#.#.#
#-#-###-#-#-#
#.#.#.|.#.|.#
#-#-#-#####-#
#.#.#.#X|.#.#
#-#-#-###-#-#
#.|.#.|.#.#.#
###-#-###-#-#
#.|.#.|.|.#.#
#############

Regex: ^WSSEESWWWNW(S|NENNEEEENN(ESSSSW(NWSW|SSEN)|WSWWN(E|WWS(E|SS))))$
Furthest room requires passing 31 doors

###############
#.|.|.|.#.|.|.#
#-###-###-#-#-#
#.|.#.|.|.#.#.#
#-#########-#-#
#.#.|.|.|.|.#.#
#-#-#########-#
#.#.#.|X#.|.#.#
###-#-###-#-#-#
#.|.#.#.|.#.|.#
#-###-#####-###
#.|.#.|.|.#.#.#
#-#-#####-#-#-#
#.#.|.|.|.#.|.#
###############
#+end_example

What is  the largest  number of  doors you would  be required  to pass
through to reach a room? That is, find the room for which the shortest
path from  your starting location  to that room would  require passing
through the most doors; what is  the fewest doors you can pass through
to reach it?
** TODO Day 20.2                                                  :noexport:

** TODO Day 21.1                                                  :noexport:

You should  have been watching  where you  were going, because  as you
wander the  new North Pole  base, you trip and  fall into a  very deep
hole!

Just kidding. You're falling through time again.

If you keep up your current pace,  you should have resolved all of the
temporal anomalies  by the next  time the device activates.  Since you
have very little  interest in browsing history  in 500-year increments
for the rest of your life, you need  to find a way to get back to your
present time.

After a  little research, you  discover two important facts  about the
behavior of the device:

First, you discover  that the device is hard-wired to  always send you
back in  time in  500-year increments. Changing  this is  probably not
feasible.

Second, you discover the activation system (your puzzle input) for the
time  travel module.  Currently,  it appears  to  run forever  without
halting.

If you can  cause the activation system to halt  at a specific moment,
maybe you can  make the device send  you so far back in  time that you
cause an integer underflow in time itself and wrap around back to your
current time!

The device executes the program as specified in manual section one and
manual section two.

Your goal  is to  figure out  how the  program works  and cause  it to
halt. You can only control register  0; every other register begins at
0 as usual.

Because time  travel is  a dangerous  activity, the  activation system
begins  with a  few instructions  which verify  that bitwise  AND (via
bani) does a  numeric operation and not an operation  as if the inputs
were interpreted as strings. If the  test fails, it enters an infinite
loop re-running  the test instead  of allowing the program  to execute
normally. If the test passes,  the program continues, and assumes that
all other  bitwise operations  (banr, bori,  and borr)  also interpret
their inputs  as numbers.  (Clearly, the Elves  who wrote  this system
were  worried that  someone  might  introduce a  bug  while trying  to
emulate this system with a scripting language.)

What  is the  lowest non-negative  integer value  for register  0 that
causes the  program to halt  after executing the  fewest instructions?
(Executing  the same  instruction  multiple times  counts as  multiple
instructions executed.)
** TODO Day 21.2                                                  :noexport:

** TODO Day 22.1                                                  :noexport:

This is  it, your  final stop:  the year -483.  It's snowing  and dark
outside; the only light you can see  is coming from a small cottage in
the distance. You make your way there and knock on the door.

A portly  man with a large,  white beard answers the  door and invites
you inside.  For someone living near  the North Pole in  -483, he must
not  get  many   visitors,  but  he  doesn't  act   surprised  to  see
you. Instead, he offers you some milk and cookies.

After talking for a  while, he asks a favor of  you. His friend hasn't
come back in a few hours, and  he's not sure where he is. Scanning the
region briefly, you discover one life  signal in a cave system nearby;
his friend must have  taken shelter there. The man asks  if you can go
there to retrieve his friend.

The cave  is divided into  square regions which are  either dominantly
rocky, narrow, or wet (called  its type). Each region occupies exactly
one coordinate in  X,Y format where X  and Y are integers  and zero or
greater. (Adjacent regions can be the same type.)

The scan (your puzzle input) is not very detailed: it only reveals the
depth of the  cave system and the coordinates of  the target. However,
it does not reveal  the type of each region. The mouth  of the cave is
at 0,0.

The man explains that due to the unusual geology in the area, there is
a  method  to  determine  any  region's  type  based  on  its  erosion
level.  The erosion  level  of a  region can  be  determined from  its
geologic index. The  geologic index can be determined  using the first
rule that applies from the list below:
- The region at 0,0 (the mouth of the cave) has a geologic index of 0.
- The region at the coordinates of the target has a geologic index of 0.
- If the region's Y coordinate is 0, the geologic index is its X
  coordinate times 16807.
- If the region's X coordinate is 0, the geologic index is its Y
  coordinate times 48271.
- Otherwise, the region's geologic index is the result of multiplying
  the erosion levels of the regions at X-1,Y and X,Y-1.
  
A region's erosion level is its geologic index plus the cave system's
depth, all modulo 20183. Then:
- If the erosion level modulo 3 is 0, the region's type is rocky.
- If the erosion level modulo 3 is 1, the region's type is wet.
- If the erosion level modulo 3 is 2, the region's type is narrow.

For example, suppose the cave system's depth is 510 and the target's
coordinates are 10,10. Using % to represent the modulo operator, the
cavern would look as follows:
- At 0,0, the geologic index is 0. The erosion level is (0 + 510) %
  20183 = 510. The type is 510 % 3 = 0, rocky.
- At 1,0, because the Y coordinate is 0, the geologic index is 1 *
  16807 = 16807. The erosion level is (16807 + 510) % 20183
  = 17317. The type is 17317 % 3 = 1, wet.
- At 0,1, because the X coordinate is 0, the geologic index is 1 *
  48271 = 48271. The erosion level is (48271 + 510) % 20183
  = 8415. The type is 8415 % 3 = 0, rocky.
- At 1,1, neither coordinate is 0 and it is not the coordinate of the
  target, so the geologic index is the erosion level of 0,1 (8415)
  times the erosion level of 1,0 (17317), 8415 * 17317
  = 145722555. The erosion level is (145722555 + 510) % 20183
  = 1805. The type is 1805 % 3 = 2, narrow.
- At 10,10, because they are the target's coordinates, the geologic
  index is 0. The erosion level is (0 + 510) % 20183 = 510. The type
  is 510 % 3 = 0, rocky.
  
Drawing this same cave system with rocky  as ., wet as =, narrow as |,
the mouth as  M, the target as  T, with 0,0 in the  top-left corner, X
increasing  to the  right,  and Y  increasing  downward, the  top-left
corner of the map looks like this:
#+begin_example
M=.|=.|.|=.|=|=.
.|=|=|||..|.=...
.==|....||=..|==
=.|....|.==.|==.
=|..==...=.|==..
=||.=.=||=|=..|=
|.=.===|||..=..|
|..==||=.|==|===
.=..===..=|.|||.
.======|||=|=.|=
.===|=|===T===||
=|||...|==..|=.|
=.=|=.=..=.||==|
||=|=...|==.=|==
|=.=||===.|||===
||.|==.|.|.||=||
#+end_example

Before you go in, you should determine the risk level of the area. For
the  rectangle  that  has  a  top-left corner  of  region  0,0  and  a
bottom-right corner  of the region  containing the target, add  up the
risk level of  each individual region: 0 for rocky  regions, 1 for wet
regions, and 2 for narrow regions.

In the cave system  above, because the mouth is at  0,0 and the target
is  at 10,10,  adding up  the  risk level  of  all regions  with an  X
coordinate from 0  to 10 and a  Y coordinate from 0 to  10, this total
is 114.

What is the total risk level  for the smallest rectangle that includes
0,0 and the target's coordinates?
** TODO Day 22.2                                                  :noexport:

** TODO Day 23.1                                                  :noexport:

Using  your torch  to search  the darkness  of the  rocky cavern,  you
finally locate the man's friend: a small reindeer.

You're not sure  how it got so far  in this cave. It looks  sick - too
sick  to  walk  -  and  too  heavy  for  you  to  carry  all  the  way
back. Sleighs won't be invented for another 1500 years, of course.

The only option is experimental emergency teleportation.

You  hit  the "experimental  emergency  teleportation"  button on  the
device  and push  I accept  the  risk on  no fewer  than 18  different
warning  messages. Immediately,  the device  deploys hundreds  of tiny
nanobots which fly around the cavern, apparently assembling themselves
into a  very specific formation.  The device lists the  X,Y,Z position
(pos) for each  nanobot as well as  its signal radius (r)  on its tiny
screen (your puzzle input).

Each nanobot can transmit signals to any integer coordinate which is a
distance away  from it  less than  or equal to  its signal  radius (as
measured by Manhattan  distance). Coordinates a distance  away of less
than or equal to a nanobot's signal  radius are said to be in range of
that nanobot.

Before you start the teleportation process, you should determine which
nanobot  is the  strongest  (that  is, which  has  the largest  signal
radius) and then, for that nanobot,  the total number of nanobots that
are in range of it, including itself.

For example, given the following nanobots:
#+begin_example
pos=<0,0,0>, r=4
pos=<1,0,0>, r=1
pos=<4,0,0>, r=3
pos=<0,2,0>, r=1
pos=<0,5,0>, r=3
pos=<0,0,3>, r=1
pos=<1,1,1>, r=1
pos=<1,1,2>, r=1
pos=<1,3,1>, r=1
#+end_example

The strongest  nanobot is the  first one (position 0,0,0)  because its
signal radius,  4 is  the largest. Using  that nanobot's  location and
signal radius, the following nanobots are in or out of range:
- The nanobot at 0,0,0 is distance 0 away, and so it is in range.
- The nanobot at 1,0,0 is distance 1 away, and so it is in range.
- The nanobot at 4,0,0 is distance 4 away, and so it is in range.
- The nanobot at 0,2,0 is distance 2 away, and so it is in range.
- The nanobot at 0,5,0 is distance 5 away, and so it is not in range.
- The nanobot at 0,0,3 is distance 3 away, and so it is in range.
- The nanobot at 1,1,1 is distance 3 away, and so it is in range.
- The nanobot at 1,1,2 is distance 4 away, and so it is in range.
- The nanobot at 1,3,1 is distance 5 away, and so it is not in range.

In this example, in total, 7 nanobots are in range of the nanobot with
the largest signal radius.

Find the nanobot with the largest signal radius. How many nanobots are
in range of its signals?
** TODO Day 23.2                                                  :noexport:

** TODO Day 24.1                                                  :noexport:

After a weird buzzing noise, you  appear back at the man's cottage. He
seems relieved to see his friend,  but quickly notices that the little
reindeer caught some kind of cold while out exploring.

The  portly man  explains  that this  reindeer's  immune system  isn't
similar to regular reindeer immune systems:

The  immune system  and the  infection each  have an  army made  up of
several  groups;  each  group  consists   of  one  or  more  identical
units.  The armies  repeatedly fight  until  only one  army has  units
remaining.

Units within a group all have the  same hit points (amount of damage a
unit can  take before it is  destroyed), attack damage (the  amount of
damage  each  unit  deals),  an attack  type,  an  initiative  (higher
initiative units attack first and  win ties), and sometimes weaknesses
or immunities. Here is an example group:

18  units each  with 729  hit points  (weak to  fire; immune  to cold,
slashing) with an attack that does 8 radiation damage at initiative 10

Each group  also has an effective  power: the number of  units in that
group  multiplied by  their  attack  damage. The  above  group has  an
effective power of  18 * 8 =  144. Groups never have  zero or negative
units; instead, the group is removed from combat.

Each fight consists of two phases: target selection and attacking.

During the target  selection phase, each group attempts  to choose one
target. In  decreasing order of  effective power, groups  choose their
targets;  in a  tie,  the  group with  the  higher initiative  chooses
first. The  attacking group chooses to  target the group in  the enemy
army to  which it  would deal  the most  damage (after  accounting for
weaknesses  and  immunities,  but   not  accounting  for  whether  the
defending  group has  enough units  to  actually receive  all of  that
damage).

If an attacking group is considering  two defending groups to which it
would deal equal damage, it chooses to target the defending group with
the largest effective  power; if there is still a  tie, it chooses the
defending group  with the  highest initiative. If  it cannot  deal any
defending groups damage, it does not choose a target. Defending groups
can only be chosen as a target by one attacking group.

At the end of the target selection phase, each group has selected zero
or one groups to  attack, and each group is being  attacked by zero or
one groups.

During the attacking  phase, each group deals damage to  the target it
selected, if  any. Groups  attack in  decreasing order  of initiative,
regardless of  whether they are  part of  the infection or  the immune
system. (If a group contains no units, it cannot attack.)

The damage  an attacking group deals  to a defending group  depends on
the attacking group's attack type and the defending group's immunities
and weaknesses. By default, an attacking group would deal damage equal
to  its  effective power  to  the  defending  group. However,  if  the
defending group  is immune to  the attacking group's attack  type, the
defending group  instead takes  no damage; if  the defending  group is
weak to the attacking group's attack type, the defending group instead
takes double damage.

The  defending group  only loses  whole units  from damage;  damage is
always dealt in such a way that  it kills the most units possible, and
any remaining  damage to a unit  that does not immediately  kill it is
ignored. For example,  if a defending group contains 10  units with 10
hit points each  and receives 75 damage, it loses  exactly 7 units and
is left with 3 units at full health.

After the  fight is over,  if both armies  still contain units,  a new
fight  begins; combat  only ends  once one  army has  lost all  of its
units.

For example, consider the following armies:
#+begin_example
Immune System:
17 units each with 5390 hit points (weak to radiation, bludgeoning) with
 an attack that does 4507 fire damage at initiative 2
989 units each with 1274 hit points (immune to fire; weak to bludgeoning,
 slashing) with an attack that does 25 slashing damage at initiative 3

Infection:
801 units each with 4706 hit points (weak to radiation) with an attack
 that does 116 bludgeoning damage at initiative 1
4485 units each with 2961 hit points (immune to radiation; weak to fire,
 cold) with an attack that does 12 slashing damage at initiative 4
#+end_example

If these armies were to  enter combat, the following fights, including
details during the  target selection and attacking  phases, would take
place:
#+begin_example
Immune System:
Group 1 contains 17 units
Group 2 contains 989 units
Infection:
Group 1 contains 801 units
Group 2 contains 4485 units

Infection group 1 would deal defending group 1 185832 damage
Infection group 1 would deal defending group 2 185832 damage
Infection group 2 would deal defending group 2 107640 damage
Immune System group 1 would deal defending group 1 76619 damage
Immune System group 1 would deal defending group 2 153238 damage
Immune System group 2 would deal defending group 1 24725 damage

Infection group 2 attacks defending group 2, killing 84 units
Immune System group 2 attacks defending group 1, killing 4 units
Immune System group 1 attacks defending group 2, killing 51 units
Infection group 1 attacks defending group 1, killing 17 units

Immune System:
Group 2 contains 905 units
Infection:
Group 1 contains 797 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 184904 damage
Immune System group 2 would deal defending group 1 22625 damage
Immune System group 2 would deal defending group 2 22625 damage

Immune System group 2 attacks defending group 1, killing 4 units
Infection group 1 attacks defending group 2, killing 144 units

Immune System:
Group 2 contains 761 units
Infection:
Group 1 contains 793 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 183976 damage
Immune System group 2 would deal defending group 1 19025 damage
Immune System group 2 would deal defending group 2 19025 damage

Immune System group 2 attacks defending group 1, killing 4 units
Infection group 1 attacks defending group 2, killing 143 units

Immune System:
Group 2 contains 618 units
Infection:
Group 1 contains 789 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 183048 damage
Immune System group 2 would deal defending group 1 15450 damage
Immune System group 2 would deal defending group 2 15450 damage

Immune System group 2 attacks defending group 1, killing 3 units
Infection group 1 attacks defending group 2, killing 143 units

Immune System:
Group 2 contains 475 units
Infection:
Group 1 contains 786 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 182352 damage
Immune System group 2 would deal defending group 1 11875 damage
Immune System group 2 would deal defending group 2 11875 damage

Immune System group 2 attacks defending group 1, killing 2 units
Infection group 1 attacks defending group 2, killing 142 units

Immune System:
Group 2 contains 333 units
Infection:
Group 1 contains 784 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 181888 damage
Immune System group 2 would deal defending group 1 8325 damage
Immune System group 2 would deal defending group 2 8325 damage

Immune System group 2 attacks defending group 1, killing 1 unit
Infection group 1 attacks defending group 2, killing 142 units

Immune System:
Group 2 contains 191 units
Infection:
Group 1 contains 783 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 181656 damage
Immune System group 2 would deal defending group 1 4775 damage
Immune System group 2 would deal defending group 2 4775 damage

Immune System group 2 attacks defending group 1, killing 1 unit
Infection group 1 attacks defending group 2, killing 142 units

Immune System:
Group 2 contains 49 units
Infection:
Group 1 contains 782 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 181424 damage
Immune System group 2 would deal defending group 1 1225 damage
Immune System group 2 would deal defending group 2 1225 damage

Immune System group 2 attacks defending group 1, killing 0 units
Infection group 1 attacks defending group 2, killing 49 units

Immune System:
No groups remain.
Infection:
Group 1 contains 782 units
Group 2 contains 4434 units
#+end_example

In the example above, the winning army ends up with 782 + 4434 = 5216
units.

You   scan  the   reindeer's  condition   (your  puzzle   input);  the
white-bearded  man looks  nervous. As  it stands  now, how  many units
would the winning army have?
** TODO Day 24.2                                                  :noexport:

** TODO Day 25.1                                                  :noexport:

The reindeer's  symptoms are  getting worse, and  neither you  nor the
white-bearded man  have a solution. At  least the reindeer has  a warm
place to rest: a small bed near where you're sitting.

As you reach down, the reindeer  looks up at you, accidentally bumping
a button on your wrist-mounted device with its nose in the process - a
button labeled "help".

"Hello, and  welcome to the  Time Travel  Support Hotline! If  you are
lost in time and space, press 1. If you are trapped in a time paradox,
press 2.  If you  need help caring  for a sick  reindeer, press  3. If
you--"

Beep.

A few  seconds later, you hear  a new voice. "Hello;  please state the
nature of your reindeer." You try to describe the situation.

"Just a moment, I think I can  remotely run a diagnostic scan." A beam
of light projects  from the device and sweeps over  the reindeer a few
times.

"Okay, it looks  like your reindeer is very low  on magical energy; it
should fully  recover if we can  fix that. Let me  check your timeline
for  a source....  Got  one.  There's actually  a  powerful source  of
magical energy about 1000 years forward  from you, and at roughly your
position, too! It  looks like... hot chocolate? Anyway,  you should be
able to  travel there  to pick some  up; just don't  forget a  mug! Is
there anything else I can help you with today?"

You  explain  that your  device  isn't  capable  of going  forward  in
time. "I... see.  That's tricky. Well, according  to this information,
your device should have the necessary  hardware to open a small portal
and send some hot  chocolate back to you. You'll need  a list of fixed
points in spacetime; I'm transmitting it to you now."

"You just  need to align  your device  to the constellations  of fixed
points  so  that it  can  lock  on to  the  destination  and open  the
portal. Let me  look up how much hot chocolate  that breed of reindeer
needs."

"It says here that your particular  reindeer is-- this can't be right,
it says  there's only one  like that in  the universe! But  THAT means
that you're--" You disconnect the call.

The list of fixed points in spacetime  (your puzzle input) is a set of
four-dimensional coordinates.  To align  your device, acquire  the hot
chocolate, and save the reindeer, you  just need to find the number of
constellations of points in the list.

Two points are  in the same constellation if  their manhattan distance
apart is no more than 3 or if  they can form a chain of points, each a
manhattan distance  no more than 3  from the last, between  the two of
them. (That  is, if  a point  is close enough  to a  constellation, it
"joins" that constellation.) For example:
#+begin_example
 0,0,0,0
 3,0,0,0
 0,3,0,0
 0,0,3,0
 0,0,0,3
 0,0,0,6
 9,0,0,0
12,0,0,0
#+end_example

In the above  list, the first six points form  a single constellation:
0,0,0,0 is  exactly distance 3  from the next  four, and the  point at
0,0,0,6 is connected to the others by being 3 away from 0,0,0,3, which
is already  in the constellation.  The bottom two points,  9,0,0,0 and
12,0,0,0 are  in a  separate constellation because  no point  is close
enough to  connect them to the  first constellation. So, in  the above
list, the number  of constellations is 2. (If a  point at 6,0,0,0 were
present,  it would  connect 3,0,0,0  and 9,0,0,0,  merging all  of the
points into a single giant constellation instead.)

In this example, the number of constellations is 4:
#+begin_example
-1,2,2,0
0,0,2,-2
0,0,0,-2
-1,2,0,0
-2,-2,-2,2
3,0,2,-1
-1,3,2,2
-1,0,-1,0
0,2,1,-2
3,0,0,0
#+end_example

In this one, it's 3:
#+begin_example
1,-1,0,1
2,0,-1,0
3,2,-1,0
0,0,3,1
0,0,-1,-1
2,3,-2,0
-2,2,0,0
2,-2,0,-1
1,-1,0,-1
3,2,0,2
#+end_example

Finally, in this one, it's 8:
#+begin_example
1,-1,-1,-2
-2,-2,0,1
0,2,1,3
-2,3,-2,1
0,2,3,-2
-1,-1,1,-2
0,-2,-1,0
-2,2,3,-1
1,2,2,0
-1,-2,0,-2
#+end_example

The portly  man nervously strokes  his white  beard. It's time  to get
that hot chocolate.

How many constellations are formed by the fixed points in spacetime?
** TODO Day 25.2                                                  :noexport:
** Stats                                                          :noexport:

#+CAPTION: https://adventofcode.com/2018/stats
| 25 |  3 | ▉▉▉                                       |
| 24 |  3 | ▉▉▉                                       |
| 23 |  3 | ▉▉▉                                       |
| 22 |  4 | ▉▉▉▉                                      |
| 21 |  4 | ▉▉▉▉                                      |
| 20 |  4 | ▉▉▉▉                                      |
| 19 |  4 | ▉▉▉▉                                      |
| 18 |  5 | ▉▉▉▉▉                                     |
| 17 |  4 | ▉▉▉▉                                      |
| 16 |  5 | ▉▉▉▉▉                                     |
| 15 |  5 | ▉▉▉▉▉                                     |
| 14 |  7 | ▉▉▉▉▉▉▉                                   |
| 13 |  7 | ▉▉▉▉▉▉▉                                   |
| 12 |  7 | ▉▉▉▉▉▉▉                                   |
| 11 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 10 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
|  9 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
|  8 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
|  7 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
|  6 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
|  5 | 16 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                          |
|  4 | 15 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                           |
|  3 | 21 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                     |
|  2 | 28 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉              |
|  1 | 41 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ |
#+TBLFM: $3='(orgtbl-uc-draw-grid $2 0 41 41)


* 2017 [13/50]
** DONE Day 1.1

The  night before  Christmas,  one of  Santa's Elves  calls  you in  a
panic.  "The printer's  broken! We  can't  print the  Naughty or  Nice
List!" By the  time you make it  to sub-basement 17, there  are only a
few minutes until midnight. "We have  a big problem," she says; "there
must be almost  fifty bugs in this system, but  nothing else can print
The List. Stand in this square,  quick! There's no time to explain; if
you can convince  them to pay you  in stars, you'll be  able to--" She
pulls a lever and the world goes blurry.

When your eyes can focus again,  everything seems a lot more pixelated
than before. She must have sent you inside the computer! You check the
system clock: 25 milliseconds until midnight. With that much time, you
should be able to collect all fifty stars by December 25th.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day  millisecond in the Advent calendar; the  second puzzle is
unlocked  when  you  complete  the   first.  Each  puzzle  grants  one
star. Good luck!

You're standing  in a room  with "digitization quarantine"  written in
LEDs along one wall. The only door  is locked, but it includes a small
interface. "Restricted Area - Strictly No Digitized Users Allowed."

It goes on to explain that you  may only leave by solving a captcha to
prove you're not a human. Apparently,  you only get one millisecond to
solve the  captcha: too  fast for  a normal human,  but it  feels like
hours to you.

The captcha requires  you to review a sequence of  digits (your puzzle
input) and find the sum of all digits that match the next digit in the
list. The list is  circular, so the digit after the  last digit is the
first digit in the list.

For example:
- 1122 produces a sum of 3 (1 + 2) because the first digit (1) matches
  the second digit and the third digit (2) matches the fourth digit.
- 1111 produces 4 because each digit (all 1) matches the next.
- 1234 produces 0 because no digit matches the next.
- 91212129 produces 9 because the only digit that matches the next one
  is the last digit, 9.
  
What is the solution to your captcha?

#+begin_src fennel -n :session d1701 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [input]
  (-> (. input 1)
      (.. (string.sub (. input 1) 1 1))
      (aoc.string-toarray)
      (lume.map (fn [e] (tonumber e)))
      (aoc.partition1)
      (lume.map (fn [[e1 e2]] (if (= e1 e2) e1 0)))
      (aoc.table-sum)))

(fn test [expected input]
  (assert (= expected (solve [input]))))

(test 3 "1122")
(test 4 "1111")
(test 0 "1234")
(test 9 "91212129")

(solve (aoc.string-from "2017/01.inp"))
#+end_src

#+RESULTS:
: 995

** DONE Day 1.2

You notice  a progress bar  that jumps to 50%  completion. Apparently,
the  door   isn't  yet  satisfied,   but  it   did  emit  a   star  as
encouragement. The instructions change:

Now, instead of  considering the next digit, it wants  you to consider
the digit  halfway around  the circular  list. That  is, if  your list
contains 10 items, only include a digit  in your sum if the digit 10/2
=  5 steps  forward matches  it. Fortunately,  your list  has an  even
number of elements.

For example:
- 1212 produces  6: the  list contains  4 items,  and all  four digits
  match the digit 2 items ahead.
- 1221 produces 0, because every comparison is between a 1 and a 2.
- 123425 produces  4, because both 2s  match each other, but  no other
  digit has a match.
- 123123 produces 12.
- 12131415 produces 4.

What is the solution to your new captcha?

#+begin_src fennel -n :session d1701 :exports both
(fn solve2 [input]
  (let [xs (lume.map (aoc.string-toarray (. input 1)) #(tonumber $))]
    (aoc.table-sum
     (icollect [i v (ipairs xs)]
        (if (= v (. xs (aoc.modulo+ i (/ (# xs) 2) (# xs)))) v 0)))))

(fn test2 [expected input]
  (assert (= expected (solve2 [input]))))

(test2 6 "1212")
(test2 0 "1221")
(test2 4 "123425")
(test2 12 "123123")
(test2 4 "12131415")

(solve2 (aoc.string-from "2017/01.inp"))
#+end_src

#+RESULTS:
: 1130


** DONE Day 2.1

As you walk  through the door, a glowing humanoid  shape yells in your
direction. "You  there! Your state  appears to  be idle. Come  help us
repair  the  corruption in  this  spreadsheet  -  if we  take  another
millisecond, we'll have to display an hourglass cursor!"

The spreadsheet consists of rows of apparently-random numbers. To make
sure the  recovery process  is on  the right track,  they need  you to
calculate  the spreadsheet's  checksum.  For each  row, determine  the
difference  between the  largest  value and  the  smallest value;  the
checksum is the sum of all of these differences.

For example, given the following spreadsheet:
#+begin_example
5 1 9 5
7 5 3
2 4 6 8
#+end_example

- The first row's largest and smallest values are 9 and 1, and their
  difference is 8.
- The second row's largest and smallest values are 7 and 3, and their
  difference is 4.
- The third row's difference is 6.

In this example, the spreadsheet's checksum would be 8 + 4 + 6 = 18.

What is the checksum for the spreadsheet in your puzzle input?


#+begin_src fennel -n :session d1702 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["5\t1\t9\t5"
        "7\t5\t3"
        "2\t4\t6\t8"])

(fn solve [input]
  (let [xs (lume.map input #(aoc.string-tonumarray $))
        ys (icollect [k v (ipairs xs)]
             (- (aoc.max v) (aoc.min v)))]
    (accumulate [sum 0 k v (ipairs ys)]
      (+ sum v))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 18 test-input)

(solve (aoc.string-from "2017/02.inp"))
#+end_src

#+RESULTS:
: 42299

** DONE Day 2.2

"Great work; looks  like we're on the right track  after all. Here's a
star  for   your  effort."  However,   the  program  seems   a  little
worried. Can programs be worried?


"Based on what we're seeing, it looks like all the User wanted is some
information    about   the    =evenly   divisible    values=   in    the
spreadsheet. Unfortunately, none  of us are equipped for  that kind of
calculation - most of us specialize in bitwise operations."

It sounds like  the goal is to  find the only two numbers  in each row
where one evenly divides the other -  that is, where the result of the
division operation  is a  whole number.  They would  like you  to find
those  numbers on  each  line, divide  them, and  add  up each  line's
result.

For example, given the following spreadsheet:

#+begin_example
5 9 2 8
9 4 7 3
3 8 6 5
#+end_example

- In the first row, the only two numbers that evenly divide are 8 and
  2; the result of this division is 4.
- In the second row, the two numbers are 9 and 3; the result is 3.
- In the third row, the result is 2.

In this example, the sum of the results would be =4 + 3 + 2 = 9=.

What is the sum of each row's result in your puzzle input?

#+begin_src fennel -n :session d1702 :exports both
(local test2-input
       ["5\t9\t2\t8"
        "9\t4\t7\t3"
        "3\t8\t6\t5"])

(fn even-division [xs]
  (let [res []]
    (for [i 1 (- (# xs) 1)]
      (for [j (+ i 1) (# xs)]
        (table.insert res 
                      (if (= 0 (% (. xs i) (. xs j)))
                          (/ (. xs i) (. xs j))
                          (= 0 (% (. xs j) (. xs i)))
                          (/ (. xs j) (. xs i))
                          0))))
    res))

(fn solve2 [input]
  (-> input
      (lume.map #(aoc.string-tonumarray $))
      (lume.map #(even-division $))
      (aoc.table-sum)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 9 test2-input)

(solve2 (aoc.string-from "2017/02.inp"))
#+end_src

#+RESULTS:
: 277

** DONE Day 3.1

You  come across  an  experimental new  kind of  memory  stored on  an
infinite two-dimensional grid.

Each square on the grid is allocated in a spiral pattern starting at a
location marked  1 and then  counting up while spiraling  outward. For
example, the first few squares are allocated like this:

#+begin_example
17  16  15  14  13
18   5   4   3  12
19   6   1   2  11
20   7   8   9  10
21  22  23---> ...
#+end_example

While this is very space-efficient (no squares are skipped), requested
data must be carried back to square 1 (the location of the only access
port for this memory system) by  programs that can only move up, down,
left,  or right.  They always  take the  shortest path:  the Manhattan
Distance between the location of the data and square 1.

For example:
- Data from square 1 is carried 0 steps, since it's at the access
  port.
- Data from square 12 is carried 3 steps, such as: down, left, left.
- Data from square 23 is carried only 2 steps: up twice.
- Data from square 1024 must be carried 31 steps.

How  many  steps are  required  to  carry  the  data from  the  square
identified in your puzzle input all the way to the access port?

#+begin_src fennel -n :session d1703 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [input]
  (let [n2 (aoc.nearest-square input)
        xs (aoc.ulam-spiral n2)
        xn (# (. xs 1))
        yn (# xs)
        to [(math.ceil (/ xn 2))
            (math.ceil (/ yn 2))]]
    (var from false)
    (for [i 1 yn &until from]
      (for [j 1 xn &until from]
        (when (= input (. (. xs i) j))
          (set from [j i]))))
    (aoc.manhattan-dist from to)))

(solve 325489)
#+end_src

#+RESULTS:
: 552


** TODO Day 3.2                                                   :noexport:

As a stress test  on the system, the programs here  clear the grid and
then store the value 1 in square 1. Then, in the same allocation order
as  shown above,  they store  the sum  of the  values in  all adjacent
squares, including diagonals.

So, the first few squares' values are chosen as follows:
- Square 1 starts with the value 1.
- Square 2 has only one adjacent filled square (with value 1), so it
  also stores 1.
- Square 3 has both of the above squares as neighbors and stores the
  sum of their values, 2.
- Square 4 has all three of the aforementioned squares as neighbors
  and stores the sum of their values, 4.
- Square 5 only has the first and fourth squares as neighbors, so it
  gets the value 5.
  
Once a square is written, its value does not change. Therefore, the
first few squares would receive the following values:

#+begin_example
147  142  133  122   59
304    5    4    2   57
330   10    1    1   54
351   11   23   25   26
362  747  806--->   ...
#+end_example

What is the first value written that is larger than your puzzle input?

** DONE Day 4.1

A new system  policy has been put in place  that requires all accounts
to  use  a passphrase  instead  of  simply  a password.  A  passphrase
consists of a series of words (lowercase letters) separated by spaces.

To ensure security, a valid passphrase must contain no duplicate words.

For example:
- aa bb cc dd ee is valid.
- aa bb cc dd aa is not valid - the word aa appears more than once.
- aa bb cc dd aaa is valid - aa and aaa count as different words.

The  system's  full  passphrase  list  is  available  as  your  puzzle
input. How many passphrases are valid?

#+begin_src fennel -n :session d1704 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["aa bb cc dd ee"
        "aa bb cc dd aa"
        "aa bb cc dd aaa"])

(fn solve [input]
  (var res 0)
  (let [lines (lume.map input #(aoc.string-split $ " "))]
    (each [_ line (ipairs lines)]
      (when (aoc.table-no-dups? line)
        (set res (+ 1 res)))))
  res)

(fn test [expected input]
  (assert (= expected (solve input))))

(test 2 test-input)

(solve (aoc.string-from "2017/04.inp"))
#+end_src

#+RESULTS:
: 455


** DONE Day 4.2

For  added  security,  yet  another  system policy  has  been  put  in
place. Now,  a valid  passphrase must  contain no  two words  that are
anagrams  of each  other -  that is,  a passphrase  is invalid  if any
word's  letters can  be  rearranged  to form  any  other  word in  the
passphrase.

For example:
- abcde fghij is a valid passphrase.
- abcde xyz ecdab is  not valid - the letters from  the third word can
  be rearranged to form the first word.
- a ab abc abd abf abj is a valid passphrase, because all letters need
  to be used when forming another word.
- iiii oiii ooii oooi oooo is valid.
- oiii  ioii iioi  iiio is  not  valid -  any  of these  words can  be
  rearranged to form any other word.
  
Under this new system policy, how many passphrases are valid?

#+begin_src fennel -n :session d1704 :exports both
(local test2-input
       ["abcde fghij"
        "abcde xyz ecdab"
        "a ab abc abd abf abj"
        "iiii oiii ooii oooi oooo"
        "oiii ioii iioi iiio"])

(fn solve2 [input]
  (var res 0)
  (let [lines (lume.map input (fn [line] (aoc.string-split line " ")))
        lines2 (lume.map lines
                         (fn [line] (lume.map line
                                              (fn [word]
                                                (let [t (aoc.string-toarray word)]
                                                  (table.sort t)
                                                  (table.concat t ""))))))]
    (each [_ line (ipairs lines2)]
      (when (aoc.table-no-dups? line)
        (set res (+ 1 res)))))
  res)

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 3 test2-input)

(solve2 (aoc.string-from "2017/04.inp"))
#+end_src

#+RESULTS:
: 186


** DONE Day 5.1

An urgent  interrupt arrives from the  CPU: it's trapped in  a maze of
jump instructions, and it would like assistance from any programs with
spare cycles to help find the exit.

The message  includes a list of  the offsets for each  jump. Jumps are
relative: -1 moves  to the previous instruction, and 2  skips the next
one. Start at the first instruction in the list. The goal is to follow
the jumps until one leads outside the list.

In addition, these instructions are a little strange; after each jump,
the offset of that instruction increases  by 1. So, if you come across
an offset of 3, you would  move three instructions forward, but change
it to a 4 for the next time it is encountered.

For example, consider the following list of jump offsets:

#+begin_example
0
3
0
1
-3
#+end_example

Positive  jumps   ("forward")  move  downward;  negative   jumps  move
upward. For  legibility in this  example, these offset values  will be
written  all on  one  line,  with the  current  instruction marked  in
parentheses.  The  following steps  would be taken  before an  exit is
found:
- (0) 3 0 1 -3 - before we have taken any steps.
- (1)  3  0 1  -3  -  jump  with offset  0  (that  is, don't  jump  at
  all). Fortunately, the instruction is then incremented to 1.
- 2 (3)  0 1  -3 -  step forward  because of  the instruction  we just
  modified. The first instruction is incremented again, now to 2.
- 2 4 0 1 (-3) - jump all the way to the end; leave a 4 behind.
- 2 (4) 0 1 -2 - go back to where we just were; increment -3 to -2.
- 2 5 0 1 -2 - jump 4 steps forward, escaping the maze.

In this example, the  exit is reached in 5 steps.  How many steps does
it take to reach the exit?

#+begin_src fennel -n :session d1705 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["0"
        "3"
        "0"
        "1"
        "-3"])

(fn table-inc [t p]
  (let [old (. t (+ 1 p))]
    (aoc.table-swap t (+ 1 p) (+ 1 old))
    old))

(fn solve [input]
  (let [xs (lume.map input #(tonumber $))
        len (# xs)]
    (var p 0)
    (var c 0)
    (while (<= p (- len 1))
      (set p (+ p (table-inc xs p)))
      (set c (+ 1 c)))
    c))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 5 test-input)

(solve (aoc.string-from "2017/05.inp"))
#+end_src

#+RESULTS:
: 326618


** DONE Day 5.2

Now, the jumps  are even stranger: after each jump,  if the offset was
three or more,  instead decrease it by 1. Otherwise,  increase it by 1
as before.

Using  this rule  with the  above example,  the process  now takes  10
steps, and the offset values after finding  the exit are left as 2 3 2
3 -1. How many steps does it now take to reach the exit?

#+begin_src fennel -n :session d1705 :exports both
(fn table-inc2 [t p]
  (let [old (. t (+ 1 p))]
    (if (<= 3 old)
        (aoc.table-swap t (+ 1 p) (- old 1))
        (aoc.table-swap t (+ 1 p) (+ old 1)))
    old))

(fn solve2 [input]
  (let [xs (lume.map input #(tonumber $))
        len (# xs)]
    (var p 0)
    (var c 0)
    (while (<= p (- len 1))
      (set p (+ p (table-inc2 xs p)))
      (set c (+ 1 c)))
    c))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 10 test-input)

(solve2 (aoc.string-from "2017/05.inp"))
#+end_src

#+RESULTS:
: 21841249

** DONE Day 6.1

A debugger program here  is having an issue: it is  trying to repair a
memory reallocation routine, but it keeps getting stuck in an infinite
loop.

In this  area, there are  sixteen memory  banks; each memory  bank can
hold any number of blocks. The  goal of the reallocation routine is to
balance the blocks between the memory banks.

The reallocation routine  operates in cycles. In each  cycle, it finds
the memory bank with the most  blocks (ties won by the lowest-numbered
memory bank)  and redistributes  those blocks among  the banks.  To do
this, it removes all of the  blocks from the selected bank, then moves
to the next (by  index) memory bank and inserts one  of the blocks. It
continues doing  this until it runs  out of blocks; if  it reaches the
last memory bank, it wraps around to the first one.

The debugger would  like to know how many redistributions  can be done
before a blocks-in-banks configuration is  produced that has been seen
before.

For example, imagine a scenario with only four memory banks:
- The banks start with 0, 2, 7, and 0 blocks. The third bank has the
  most blocks, so it is chosen for redistribution.
- Starting with the next bank (the fourth bank) and then continuing to
  the first bank, the second bank, and so on, the 7 blocks are spread
  out over the memory banks. The fourth, first, and second banks get
  two blocks each, and the third bank gets one back. The final result
  looks like this: 2 4 1 2.
- Next, the second bank is chosen because it contains the most blocks
  (four). Because there are four memory banks, each gets one
  block. The result is: 3 1 2 3.
- Now, there is a tie between the first and fourth memory banks, both
  of which have three blocks. The first bank wins the tie, and its
  three blocks are distributed evenly over the other three banks,
  leaving it with none: 0 2 3 4.
- The fourth bank is chosen, and its four blocks are distributed such
  that each of the four banks receives one: 1 3 4 1.
- The third bank is chosen, and the same thing happens: 2 4 1 2.

At this point,  we've reached a state  we've seen before: 2 4  1 2 was
already  seen. The  infinite loop  is detected  after the  fifth block
redistribution cycle, and so the answer in this example is 5.

Given  the  initial  block  counts  in your  puzzle  input,  how  many
redistribution  cycles must  be  completed before  a configuration  is
produced that has been seen before?

#+begin_src fennel -n :session d1706 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["0\t2\t7\t0"])

(fn table-inc [xs i]
  (var v (. xs i))
  (var j (if (< i (# xs)) (+ 1 i) 1))
  (aoc.table-swap xs i 0)
  (while (< 0 v)
    (aoc.table-swap xs j (+ 1 (. xs j)))
    (set v (- v 1))
    (set j (if (< j (# xs)) (+ 1 j) 1)))
  xs)

(fn find-cycle [input]
  (let [xs (aoc.string-tonumarray (. input 1))
        res [(aoc.table-clone xs)]]
    (table-inc xs (aoc.max-index xs))
    (while (not (aoc.matrix-contains? res xs))
      (table.insert res (aoc.table-clone xs))
      (table-inc xs (aoc.max-index xs)))
    res))

(fn solve [input]
  (length (find-cycle input)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 5 test-input)

(solve (aoc.string-from "2017/06.inp"))
#+end_src

#+RESULTS:
: 4074

** DONE Day 6.2

Out of curiosity, the debugger would also like to know the size of the
loop: starting from a state that has already been seen, how many block
redistribution cycles must be performed before that same state is seen
again?

In the example above, 2 4 1 2  is seen again after four cycles, and so
the answer in that example would be 4.

How  many  cycles are  in  the  infinite  loop  that arises  from  the
configuration in your puzzle input?

#+begin_src fennel -n :session d1706 :exports both
(fn solve2 [input]
  (let [res (find-cycle input)
        xs0 (. res (# res))
        xs (table-inc xs0 (aoc.max-index xs0))
        (_ cycle-start) (aoc.matrix-contains? res xs)]
    (- (+ 1 (# res)) cycle-start)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 4 test-input)

(solve2 (aoc.string-from "2017/06.inp"))
#+end_src

#+RESULTS:
: 2793

** TODO Day 7.1                                                   :noexport:

Wandering further through the circuits  of the computer, you come upon
a  tower  of programs  that  have  gotten  themselves  into a  bit  of
trouble. A recursive algorithm has gotten out of hand, and now they're
balanced precariously in a large tower.

One program  at the bottom supports  the entire tower. It's  holding a
large disc, and  on the disc are balanced several  more sub-towers. At
the bottom of these sub-towers, standing on the bottom disc, are other
programs, each holding their own disc, and  so on. At the very tops of
these sub-sub-sub-...-towers,  many programs stand simply  keeping the
disc below them balanced but with no disc of their own.

You offer to  help, but first you need to  understand the structure of
these  towers. You  ask each  program to  yell out  their name,  their
weight, and  (if they're  holding a  disc) the  names of  the programs
immediately  above  them  balancing  on  that  disc.  You  write  this
information down  (your puzzle input). Unfortunately,  in their panic,
they don't  do this in  an orderly fashion;  by the time  you're done,
you're not sure which program gave which information.

For example, if your list is the following:
#+begin_example
pbga (66)
xhth (57)
ebii (61)
havc (66)
ktlj (57)
fwft (72) -> ktlj, cntj, xhth
qoyq (66)
padx (45) -> pbga, havc, qoyq
tknk (41) -> ugml, padx, fwft
jptl (61)
ugml (68) -> gyxo, ebii, jptl
gyxo (61)
cntj (57)
#+end_example

...then you would be able to recreate the structure of the towers that
looks like this:

#+begin_example
                gyxo
              /     
         ugml - ebii
       /      \     
      |         jptl
      |        
      |         pbga
     /        /
tknk --- padx - havc
     \        \
      |         qoyq
      |             
      |         ktlj
       \      /     
         fwft - cntj
              \     
                xhth
#+end_example

In  this example,  tknk is  at  the bottom  of the  tower (the  bottom
program), and is holding up ugml,  padx, and fwft. Those programs are,
in turn,  holding up other  programs; in  this example, none  of those
programs are  holding up any other  programs, and are all  the tops of
their own towers. (The actual tower  balancing in front of you is much
larger.)

Before  you're  ready  to  help  them, you  need  to  make  sure  your
information is correct. What is the name of the bottom program?

** TODO Day 7.2                                                   :noexport:

** DONE Day 8.1

You receive  a signal directly  from the  CPU. Because of  your recent
assistance with  jump instructions, it  would like you to  compute the
result of a series of unusual register instructions.

Each instruction  consists of several  parts: the register  to modify,
whether to increase  or decrease that register's value,  the amount by
which to  increase or decrease it,  and a condition. If  the condition
fails,  skip  the  instruction  without modifying  the  register.  The
registers all start at 0. The instructions look like this:

#+begin_example
b inc 5 if a > 1
a inc 1 if b < 5
c dec -10 if a >= 1
c inc -20 if c == 10
#+end_example

These instructions would be processed as follows:
- Because a starts at 0, it is not greater than 1, and so b is not
  modified.
- a is increased by 1 (to 1) because b is less than 5 (it is 0).
- c is decreased by -10 (to 10) because a is now greater than or equal
  to 1 (it is 1).
- c is increased by -20 (to -10) because c is equal to 10.

After this process, the largest value in any register is 1.

You might also encounter  <= (less than or equal to)  or != (not equal
to). However, the CPU doesn't have  the bandwidth to tell you what all
the registers are named, and leaves that to you to determine.

What  is  the largest  value  in  any  register after  completing  the
instructions in your puzzle input?

#+begin_src fennel -n :session d1708 :exports both
(local aoc (require :lib.aoc))
(local test-input
       ["b inc 5 if a > 1"
        "a inc 1 if b < 5"
        "c dec -10 if a >= 1"
        "c inc -20 if c == 10"])

(fn eval [s r]
  (case (aoc.string-split s " ")
    [r1 "inc" v1 "if" r2 ">" v2]
    (when (> (or (?. r r2) 0) (tonumber v2))
      (tset r r1 (+ (or (?. r r1) 0) (tonumber v1))))
    [r1 "inc" v1 "if" r2 "<" v2]
    (when (< (or (?. r r2) 0) (tonumber v2))
      (tset r r1 (+ (or (?. r r1) 0) (tonumber v1))))
    [r1 "inc" v1 "if" r2 ">=" v2]
    (when (>= (or (?. r r2) 0) (tonumber v2))
      (tset r r1 (+ (or (?. r r1) 0) (tonumber v1))))
    [r1 "inc" v1 "if" r2 "<=" v2]
    (when (<= (or (?. r r2) 0) (tonumber v2))
      (tset r r1 (+ (or (?. r r1) 0) (tonumber v1))))
    [r1 "inc" v1 "if" r2 "==" v2]
    (when (= (or (?. r r2) 0) (tonumber v2))
      (tset r r1 (+ (or (?. r r1) 0) (tonumber v1))))
    [r1 "inc" v1 "if" r2 "!=" v2]
    (when (not= (or (?. r r2) 0) (tonumber v2))
      (tset r r1 (+ (or (?. r r1) 0) (tonumber v1))))
    [r1 "dec" v1 "if" r2 op v2]
    (eval (.. r1 " inc " (* -1 (tonumber v1)) " if " r2 " " op " " v2) r)
    _ (print (.. "No match for " s)))
  r)

(fn solve [input]
  (var regs {})
  (each [_ line (ipairs input)]
    (set regs (eval line regs)))
  (aoc.math-max (aoc.vals regs)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 1 test-input)

(solve (aoc.string-from "2017/08.inp"))
#+end_src

#+RESULTS:
: 5966


** DONE Day 8.2

To be safe, the  CPU also needs to know the highest  value held in any
register during this process so that  it can decide how much memory to
allocate to these operations. For  example, in the above instructions,
the highest  value ever  held was  10 (in register  c after  the third
instruction was evaluated).

#+begin_src fennel -n :session d1708 :exports both
(fn solve2 [input]
  (var regs {})
  (var res 0)
  (each [_ line (ipairs input)]
    (set regs (eval line regs))
    (let [maxreg (aoc.math-max (aoc.vals regs))]
      (when (and maxreg (< res maxreg))
        (set res maxreg))))
  res)

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 10 test-input)

(solve2 (aoc.string-from "2017/08.inp"))
#+end_src

#+RESULTS:
: 6347

** TODO Day 9.1                                                   :noexport:

A large  stream blocks your  path. According  to the locals,  it's not
safe  to  cross  the  stream  at  the  moment  because  it's  full  of
garbage. You look down at the  stream; rather than water, you discover
that it's a stream of characters.

You  sit for  a  while and  record  part of  the  stream (your  puzzle
input). The characters represent groups  - sequences that begin with {
and end with }.  Within a group, there are zero  or more other things,
separated by commas: either another group or garbage. Since groups can
contain  other  groups,  a  }  only  closes  the  most-recently-opened
unclosed  group  - that  is,  they  are  nestable. Your  puzzle  input
represents a  single, large group  which itself contains  many smaller
ones.

Sometimes, instead of  a group, you will find  garbage. Garbage begins
with  < and  ends with  >. Between  those angle  brackets, almost  any
character can  appear, including  { and  }. Within  garbage, <  has no
special meaning.

In a futile attempt to clean up the garbage, some program has canceled
some  of  the  characters  within  it using  !:  inside  garbage,  any
character that  comes after ! should  be ignored, including <,  >, and
even another !.

You don't  see any characters  that deviate from these  rules. Outside
garbage,  you  only  find   well-formed  groups,  and  garbage  always
terminates according to the rules above.

Here are some self-contained pieces of garbage:
- <>, empty garbage.
- <random characters>, garbage containing random characters.
- <<<<>, because the extra < are ignored.
- <{!>}>, because the first > is canceled.
- <!!>, because the second ! is canceled, allowing the > to terminate
  the garbage.
- <!!!>>, because the second ! and the first > are canceled.
- <{o"i!a,<{i<a>, which ends at the first >.

Here are some examples of whole streams and the number of groups they
contain:
- {}, 1 group.
- {{{}}}, 3 groups.
- {{},{}}, also 3 groups.
- {{{},{},{{}}}}, 6 groups.
- {<{},{},{{}}>}, 1 group (which itself contains garbage).
- {<a>,<a>,<a>,<a>}, 1 group.
- {{<a>},{<a>},{<a>},{<a>}}, 5 groups.
- {{<!>},{<!>},{<!>},{<a>}}, 2 groups (since all but the last > are
  canceled).
  
Your  goal  is  to  find  the  total score  for  all  groups  in  your
input. Each group is assigned a score which is one more than the score
of the group that immediately contains it. (The outermost group gets a
score of 1.)
- {}, score of 1.
- {{{}}}, score of 1 + 2 + 3 = 6.
- {{},{}}, score of 1 + 2 + 2 = 5.
- {{{},{},{{}}}}, score of 1 + 2 + 3 + 3 + 3 + 4 = 16.
- {<a>,<a>,<a>,<a>}, score of 1.
- {{<ab>},{<ab>},{<ab>},{<ab>}}, score of 1 + 2 + 2 + 2 + 2 = 9.
- {{<!!>},{<!!>},{<!!>},{<!!>}}, score of 1 + 2 + 2 + 2 + 2 = 9.
- {{<a!>},{<a!>},{<a!>},{<ab>}}, score of 1 + 2 = 3.

What is the total score for all groups in your input?

** TODO Day 9.2                                                   :noexport:

** TODO Day 10.1                                                  :noexport:

You come across some programs that  are trying to implement a software
emulation of a  hash based on knot-tying. The hash  these programs are
implementing  isn't  very   strong,  but  you  decide   to  help  them
anyway. You make a mental note to remind the Elves later not to invent
their own cryptographic functions.

This hash function  simulates tying a knot in a  circle of string with
256  marks on  it.  Based on  the  input to  be  hashed, the  function
repeatedly selects  a span  of string, brings  the ends  together, and
gives the span  a half-twist to reverse the order  of the marks within
it. After  doing this many  times, the order of  the marks is  used to
build the resulting hash.
#+begin_example
  4--5   pinch   4  5           4   1
 /    \  5,0,1  / \/ \  twist  / \ / \
3      0  -->  3      0  -->  3   X   0
 \    /         \ /\ /         \ / \ /
  2--1           2  1           2   5
#+end_example

To achieve this, begin with a list of numbers from 0 to 255, a current
position which  begins at 0  (the first element  in the list),  a skip
size  (which starts  at 0),  and a  sequence of  lengths (your  puzzle
input). Then, for each length:
- Reverse the order of that length of elements in the list, starting
  with the element at the current position.
- Move the current position forward by that length plus the skip size.
- Increase the skip size by one.

The list  is circular; if the  current position and the  length try to
reverse elements  beyond the end  of the list, the  operation reverses
using  as many  extra  elements as  it  needs from  the  front of  the
list. If the current position moves past the end of the list, it wraps
around to  the front.  Lengths larger  than the size  of the  list are
invalid.

Here's an example using a smaller list:

Suppose we instead only had  a circular list containing five elements,
0, 1, 2, 3, 4, and were given input lengths of 3, 4, 1, 5.
- The list begins as [0] 1 2 3 4 (where square brackets indicate the
  current position).
- The first length, 3, selects ([0] 1 2) 3 4 (where parentheses
  indicate the sublist to be reversed).
- After reversing that section (0 1 2 into 2 1 0), we get ([2] 1 0)
  3 4.
- Then, the current position moves forward by the length, 3, plus the
  skip size, 0: 2 1 0 [3] 4. Finally, the skip size increases to 1.
  
- The second length, 4, selects a section which wraps: 2 1) 0 ([3] 4.
- The sublist 3 4 2 1 is reversed to form 1 2 4 3: 4 3) 0 ([1] 2.
- The current position moves forward by the length plus the skip size,
  a total of 5, causing it not to move because it wraps around: 4 3 0
  [1] 2. The skip size increases to 2.
- The third length, 1, selects a sublist of a single element, and so
  reversing it has no effect.
- The current position moves forward by the length (1) plus the skip
  size (2): 4 [3] 0 1 2. The skip size increases to 3.
  
- The fourth length, 5, selects every element starting with the
  second: 4) ([3] 0 1 2. Reversing this sublist (3 0 1 2 4 into 4 2 1
  0 3) produces: 3) ([4] 2 1 0.
- Finally, the current position moves forward by 8: 3 4 2 1 [0]. The
  skip size increases to 4.
  
In this example, the first two numbers  in the list end up being 3 and
4; to check the process, you can multiply them together to produce 12.

However, you  should instead use the  standard list size of  256 (with
values  0  to  255)  and  the  sequence  of  lengths  in  your  puzzle
input.  Once  this  process  is   complete,  what  is  the  result  of
multiplying the first two numbers in the list?

** TODO Day 10.2                                                  :noexport:

** TODO Day 11.1                                                  :noexport:

Crossing  the bridge,  you've barely  reached  the other  side of  the
stream when a  program comes up to you, clearly  in distress. "It's my
child process," she says, "he's gotten lost in an infinite grid!"

Fortunately  for her,  you  have plenty  of  experience with  infinite
grids.

Unfortunately for you, it's a hex grid.

The hexagons  ("hexes") in  this grid are  aligned such  that adjacent
hexes  can  be  found  to  the  north,  northeast,  southeast,  south,
southwest, and northwest:
#+begin_example
  \ n  /
nw +--+ ne
  /    \
-+      +-
  \    /
sw +--+ se
  / s  \
#+end_example

You have the  path the child process took. Starting  where he started,
you need  to determine the  fewest number  of steps required  to reach
him. (A "step" means  to move from the hex you are  in to any adjacent
hex.)

For example:
- ne,ne,ne is 3 steps away.
- ne,ne,sw,sw is 0 steps away (back where you started).
- ne,ne,s,s is 2 steps away (se,se).
- se,sw,se,sw,sw is 3 steps away (s,s,sw).
** TODO Day 11.2                                                  :noexport:

** TODO Day 12.1                                                  :noexport:

Walking along the memory banks of the stream, you find a small village
that  is   experiencing  a  little  confusion:   some  programs  can't
communicate with each other.

Programs  in  this  village  communicate   using  a  fixed  system  of
pipes. Messages  are passed  between programs  using these  pipes, but
most  programs  aren't  connected  to each  other  directly.  Instead,
programs pass  messages between each  other until the  message reaches
the intended recipient.

For some reason,  though, some of these messages  aren't ever reaching
their intended recipient, and the programs suspect that some pipes are
missing. They would like you to investigate.

You walk through the village and record the ID of each program and the
IDs with which  it can communicate directly (your  puzzle input). Each
program has  one or more programs  with which it can  communicate, and
these pipes are  bidirectional; if 8 says it can  communicate with 11,
then 11 will say it can communicate with 8.

You  need to  figure  out how  many  programs are  in  the group  that
contains program ID 0.

For example,  suppose you go  door-to-door like a  travelling salesman
and record the following list:
#+begin_example
0 <-> 2
1 <-> 1
2 <-> 0, 3, 4
3 <-> 2, 4
4 <-> 2, 3, 6
5 <-> 6
6 <-> 4, 5
#+end_example

In this example, the following programs are in the group that contains
program ID 0:
- Program 0 by definition.
- Program 2, directly connected to program 0.
- Program 3 via program 2.
- Program 4 via program 2.
- Program 5 via programs 6, then 4, then 2.
- Program 6 via programs 4, then 2.

Therefore, a total of 6 programs are in this group; all but program 1,
which has a pipe that connects it to itself.

How many programs are in the group that contains program ID 0?
** TODO Day 12.2                                                  :noexport:

** TODO Day 13.1                                                  :noexport:

You need  to cross a vast  firewall. The firewall consists  of several
layers, each with a security scanner  that moves back and forth across
the layer. To succeed, you must not be detected by a scanner.

By studying  the firewall  briefly, you  are able  to record  (in your
puzzle input)  the depth of each  layer and the range  of the scanning
area for  the scanner within it,  written as depth: range.  Each layer
has a  thickness of exactly 1.  A layer at depth  0 begins immediately
inside the firewall; a layer at  depth 1 would start immediately after
that.

For example, suppose you've recorded the following:
#+begin_example
0: 3
1: 2
4: 4
6: 4
#+end_example

This means that there is a layer immediately inside the firewall (with
range 3),  a second  layer immediately  after that  (with range  2), a
third layer which begins at depth 4 (with range 4), and a fourth layer
which begins at  depth 6 (also with range 4).  Visually, it might look
like this:
#+begin_example
 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[ ]             [ ]     [ ]
                [ ]     [ ]
#+end_example

Within each layer, a security scanner  moves back and forth within its
range. Each security scanner starts at the top and moves down until it
reaches  the bottom,  then  moves up  until it  reaches  the top,  and
repeats.  A  security  scanner  takes   one  picosecond  to  move  one
step. Drawing scanners as S, the first few picoseconds look like this:
#+begin_example
Picosecond 0:
 0   1   2   3   4   5   6
[S] [S] ... ... [S] ... [S]
[ ] [ ]         [ ]     [ ]
[ ]             [ ]     [ ]
                [ ]     [ ]

Picosecond 1:
 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] ... [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]

Picosecond 2:
 0   1   2   3   4   5   6
[ ] [S] ... ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[S]             [S]     [S]
                [ ]     [ ]

Picosecond 3:
 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] ... [ ]
[S] [S]         [ ]     [ ]
[ ]             [ ]     [ ]
                [S]     [S]
#+end_example

Your plan  is to hitch a  ride on a  packet about to move  through the
firewall. The packet  will travel along the top of  each layer, and it
moves at one  layer per picosecond. Each picosecond,  the packet moves
one layer forward (its first move takes it into layer 0), and then the
scanners move one step. If there is  a scanner at the top of the layer
as your packet enters it, you are caught. (If a scanner moves into the
top of its layer  while you are there, you are  not caught: it doesn't
have time to notice  you before you leave.) If you were  to do this in
the   configuration  above,   marking  your   current  position   with
parentheses, your passage through the firewall would look like this:

#+begin_example
Initial state:
 0   1   2   3   4   5   6
[S] [S] ... ... [S] ... [S]
[ ] [ ]         [ ]     [ ]
[ ]             [ ]     [ ]
                [ ]     [ ]

Picosecond 0:
 0   1   2   3   4   5   6
(S) [S] ... ... [S] ... [S]
[ ] [ ]         [ ]     [ ]
[ ]             [ ]     [ ]
                [ ]     [ ]

 0   1   2   3   4   5   6
( ) [ ] ... ... [ ] ... [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]


Picosecond 1:
 0   1   2   3   4   5   6
[ ] ( ) ... ... [ ] ... [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]

 0   1   2   3   4   5   6
[ ] (S) ... ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[S]             [S]     [S]
                [ ]     [ ]


Picosecond 2:
 0   1   2   3   4   5   6
[ ] [S] (.) ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[S]             [S]     [S]
                [ ]     [ ]

 0   1   2   3   4   5   6
[ ] [ ] (.) ... [ ] ... [ ]
[S] [S]         [ ]     [ ]
[ ]             [ ]     [ ]
                [S]     [S]


Picosecond 3:
 0   1   2   3   4   5   6
[ ] [ ] ... (.) [ ] ... [ ]
[S] [S]         [ ]     [ ]
[ ]             [ ]     [ ]
                [S]     [S]

 0   1   2   3   4   5   6
[S] [S] ... (.) [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[ ]             [S]     [S]
                [ ]     [ ]


Picosecond 4:
 0   1   2   3   4   5   6
[S] [S] ... ... ( ) ... [ ]
[ ] [ ]         [ ]     [ ]
[ ]             [S]     [S]
                [ ]     [ ]

 0   1   2   3   4   5   6
[ ] [ ] ... ... ( ) ... [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]


Picosecond 5:
 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] (.) [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]

 0   1   2   3   4   5   6
[ ] [S] ... ... [S] (.) [S]
[ ] [ ]         [ ]     [ ]
[S]             [ ]     [ ]
                [ ]     [ ]


Picosecond 6:
 0   1   2   3   4   5   6
[ ] [S] ... ... [S] ... (S)
[ ] [ ]         [ ]     [ ]
[S]             [ ]     [ ]
                [ ]     [ ]

 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] ... ( )
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]
#+end_example

In this  situation, you  are caught  in layers 0  and 6,  because your
packet entered  the layer  when its  scanner was at  the top  when you
entered it.  You are not  caught in layer  1, since the  scanner moved
into the top of the layer once you were already there.

The  severity of  getting caught  on  a layer  is equal  to its  depth
multiplied  by its  range.  (Ignore layers  in which  you  do not  get
caught.) The severity of the whole trip is the sum of these values. In
the example above, the trip severity is 0*3 + 6*4 = 24.

Given  the details  of  the  firewall you've  recorded,  if you  leave
immediately, what is the severity of your whole trip?
** TODO Day 13.2                                                  :noexport:

** TODO Day 14.1                                                  :noexport:

Suddenly,   a    scheduled   job    activates   the    system's   disk
defragmenter. Were the situation different, you might sit and watch it
for a while,  but today, you just  don't have that kind  of time. It's
soaking up valuable system resources that are needed elsewhere, and so
the only option is to help it finish its task as soon as possible.

The disk  in question consists of  a 128x128 grid; each  square of the
grid is either  free or used. On  this disk, the state of  the grid is
tracked by the bits in a sequence of knot hashes.

A total  of 128 knot  hashes are  calculated, each corresponding  to a
single row in  the grid; each hash contains 128  bits which correspond
to individual grid squares. Each bit  of a hash indicates whether that
square is free (0) or used (1).

The hash inputs  are a key string  (your puzzle input), a  dash, and a
number from  0 to 127 corresponding  to the row. For  example, if your
key string  were flqrgnkx, then  the first row  would be given  by the
bits of the knot  hash of flqrgnkx-0, the second row  from the bits of
the  knot  hash  of  flqrgnkx-1,  and   so  on  until  the  last  row,
flqrgnkx-127.

The  output  of  a  knot  hash  is  traditionally  represented  by  32
hexadecimal digits; each  of these digits correspond to 4  bits, for a
total of 4 * 32 = 128  bits. To convert to bits, turn each hexadecimal
digit to its equivalent binary  value, high-bit first: 0 becomes 0000,
1 becomes 0001, e becomes 1110, f becomes 1111, and so on; a hash that
begins   with    a0c2017...   in   hexadecimal   would    begin   with
10100000110000100000000101110000... in binary.

Continuing this process, the first 8 rows and columns for key flqrgnkx
appear as  follows, using #  to denote used  squares, and .  to denote
free ones:
#+begin_example
##.#.#..-->
.#.#.#.#   
....#.#.   
#.#.##.#   
.##.#...   
##..#..#   
.#...#..   
##.#.##.-->
|      |   
V      V   
#+end_example

In this example, 8108 squares are used across the entire 128x128 grid.

Given your actual key string, how many squares are used?
** TODO Day 14.2                                                  :noexport:

** TODO Day 15.1                                                  :noexport:

Here,  you encounter  a pair  of dueling  generators. The  generators,
called generator A and generator B,  are trying to agree on a sequence
of  numbers.  However, one  of  them  is  malfunctioning, and  so  the
sequences don't always match.

As they do this,  a judge waits for each of them  to generate its next
value, compares the lowest 16 bits  of both values, and keeps track of
the number of times those parts of the values match.

The generators  both work on  the same  principle. To create  its next
value, a generator will take  the previous value it produced, multiply
it by a  factor (generator A uses 16807; generator  B uses 48271), and
then   keep  the   remainder  of   dividing  that   resulting  product
by 2147483647. That final remainder is the value it produces next.

To calculate each generator's first  value, it instead uses a specific
starting  value as  its "previous  value"  (as listed  in your  puzzle
input).

For example,  suppose that for  starting values, generator A  uses 65,
while generator B  uses 8921. Then, the first five  pairs of generated
values are:
#+begin_example
--Gen. A--  --Gen. B--
   1092455   430625591
1181022009  1233683848
 245556042  1431495498
1744312007   137874439
1352636452   285222916
#+end_example

In binary,  these pairs are  (with generator  A's value first  in each
pair):
#+begin_example
00000000000100001010101101100111
00011001101010101101001100110111

01000110011001001111011100111001
01001001100010001000010110001000

00001110101000101110001101001010
01010101010100101110001101001010

01100111111110000001011011000111
00001000001101111100110000000111

01010000100111111001100000100100
00010001000000000010100000000100
#+end_example

Here, you  can see that  the lowest (here,  rightmost) 16 bits  of the
third value match: 1110001101001010. Because  of this one match, after
processing these five pairs, the judge  would have added only 1 to its
total.

To  get a  significant sample,  the judge  would like  to consider  40
million pairs. (In the example  above, the judge would eventually find
a total of 588 pairs that match in their lowest 16 bits.)

After 40 million pairs, what is the judge's final count?
** TODO Day 15.2                                                  :noexport:

** TODO Day 16.1                                                  :noexport:

You come upon a very unusual sight; a group of programs here appear to
be dancing.

There are sixteen programs in total,  named a through p. They start by
standing in a  line: a stands in  position 0, b stands  in position 1,
and so on until p, which stands in position 15.

The programs' dance consists of a sequence of dance moves:
- Spin, written sX, makes X programs move from the end to the front,
  but maintain their order otherwise. (For example, s3 on abcde
  produces cdeab).
- Exchange, written xA/B, makes the programs at positions A and B swap
  places.
- Partner, written pA/B, makes the programs named A and B swap places.

For example, with only five programs standing in a line (abcde), they
could do the following dance:
- s1, a spin of size 1: eabcd.
- x3/4, swapping the last two programs: eabdc.
- pe/b, swapping programs e and b: baedc.

After finishing their dance, the programs end up in order baedc.

You watch  the dance for  a while and  record their dance  moves (your
puzzle input).  In what  order are the  programs standing  after their
dance?
** TODO Day 16.2                                                  :noexport:

** TODO Day 17.1                                                  :noexport:

Suddenly,  whirling in  the distance,  you  notice what  looks like  a
massive, pixelated  hurricane: a deadly spinlock.  This spinlock isn't
just  consuming  computing  power,  but  memory,  too;  vast,  digital
mountains are being ripped from the ground and consumed by the vortex.

If you  don't move quickly, fixing  that printer will be  the least of
your problems.

This spinlock's  algorithm is simple but  efficient, quickly consuming
everything in  its path. It  starts with a circular  buffer containing
only the  value 0,  which it  marks as the  current position.  It then
steps forward through  the circular buffer some number  of steps (your
puzzle input) before inserting the first new value, 1, after the value
it stopped on. The inserted  value becomes the current position. Then,
it steps forward from there the  same number of steps, and wherever it
stops, inserts after it the second new  value, 2, and uses that as the
new current position again.

It repeats  this process of  stepping forward, inserting a  new value,
and  using the  location  of the  inserted value  as  the new  current
position a total of 2017 times, inserting 2017 as its final operation,
and ending with  a total of 2018 values (including  0) in the circular
buffer.

For example,  if the  spinlock were  to step 3  times per  insert, the
circular buffer would begin to  evolve like this (using parentheses to
mark the current position after each iteration of the algorithm):
- (0), the initial state before any insertions.
- 0 (1): the spinlock steps forward three times (0, 0, 0), and then
  inserts the first value, 1, after it. 1 becomes the current
  position.
- 0 (2) 1: the spinlock steps forward three times (0, 1, 0), and then
  inserts the second value, 2, after it. 2 becomes the current
  position.
- 0  2 (3) 1: the spinlock steps forward three times (1, 0, 2), and
  then inserts the third value, 3, after it. 3 becomes the current
  position.
  
And so on:
#+begin_example
    0  2 (4) 3  1
    0 (5) 2  4  3  1
    0  5  2  4  3 (6) 1
    0  5 (7) 2  4  3  6  1
    0  5  7  2  4  3 (8) 6  1
    0 (9) 5  7  2  4  3  8  6  1
#+end_example

Eventually, after 2017 insertions, the section of the circular buffer
near the last insertion looks like this:
#+begin_example
1512  1134  151 (2017) 638  1513  851
#+end_example

Perhaps, if you  can identify the value that will  ultimately be after
the last value written (2017),  you can short-circuit the spinlock. In
this example, that would be 638.

What is the value after 2017 in your completed circular buffer?
** TODO Day 17.2                                                  :noexport:

** TODO Day 18.1                                                  :noexport:

You discover  a tablet containing  some strange assembly  code labeled
simply "Duet". Rather  than bother the sound card with  it, you decide
to  run   the  code  yourself.   Unfortunately,  you  don't   see  any
documentation, so you're left to figure out what the instructions mean
on your own.

It seems like the  assembly is meant to operate on  a set of registers
that are  each named  with a single  letter and that  can each  hold a
single integer.  You suppose each  register should start with  a value
of 0.

There aren't that many instructions, so it shouldn't be hard to figure
out what they do. Here's what you determine:
- snd X plays a sound with a frequency equal to the value of X.
- set X Y sets register X to the value of Y.
- add X Y increases register X by the value of Y.
- mul X Y sets register X to the result of multiplying the value
  contained in register X by the value of Y.
- mod X Y sets register X to the remainder of dividing the value
  contained in register X by the value of Y (that is, it sets X to the
  result of X modulo Y).
- rcv X recovers the frequency of the last sound played, but only when
  the value of X is not zero. (If it is zero, the command does
  nothing.)
- jgz X Y jumps with an offset of the value of Y, but only if the
  value of X is greater than zero. (An offset of 2 skips the next
  instruction, an offset of -1 jumps to the previous instruction, and
  so on.)
  
Many of the instructions can take  either a register (a single letter)
or a number. The  value of a register is the  integer it contains; the
value of a number is that number.

After  each   jump  instruction,   the  program  continues   with  the
instruction to which the jump jumped. After any other instruction, the
program continues  with the next instruction.  Continuing (or jumping)
off either end of the program terminates it.

For example:
#+begin_example
set a 1
add a 2
mul a a
mod a 5
snd a
set a 0
rcv a
jgz a -1
set a 1
jgz a -2
#+end_example

- The first four instructions set a to 1, add 2 to it, square it, and
  then set it to itself modulo 5, resulting in a value of 4.
- Then, a sound with frequency 4 (the value of a) is played.
- After that, a is set to 0, causing the subsequent rcv and jgz
  instructions to both be skipped (rcv because a is 0, and jgz because
  a is not greater than 0).
- Finally, a is set to 1, causing the next jgz instruction to
  activate, jumping back two instructions to another jump, which jumps
  again to the rcv, which ultimately triggers the recover operation.
  
At the  time the recover operation  is executed, the frequency  of the
last sound played is 4.

What is  the value of the  recovered frequency (the value  of the most
recently played  sound) the first  time a rcv instruction  is executed
with a non-zero value?
** TODO Day 18.2                                                  :noexport:

** TODO Day 19.1                                                  :noexport:

Somehow, a network  packet got lost and ended up  here. It's trying to
follow a routing diagram (your  puzzle input), but it's confused about
where to go.

Its starting  point is just off  the top of the  diagram. Lines (drawn
with |, -,  and +) show the  path it needs to take,  starting by going
down onto the only line connected to  the top of the diagram. It needs
to follow this path until it reaches the end (located somewhere within
the diagram) and stop there.

Sometimes, the lines  cross over each other; in these  cases, it needs
to continue going the same direction, and only turn left or right when
there's no other option. In addition,  someone has left letters on the
line; these  also don't change its  direction, but it can  use them to
keep track of where it's been. For example:
#+begin_example
     |          
     |  +--+    
     A  |  C    
 F---|----E|--+ 
     |  |  |  D 
     +B-+  +--+ 
#+end_example

Given this diagram, the packet needs to take the following path:
- Starting at the only line touching the top of the diagram, it must
  go down, pass through A, and continue onward to the first +.
- Travel right, up, and right, passing through B in the process.
- Continue down (collecting C), right, and up (collecting D).
- Finally, go all the way left through E and stopping at F.

Following the  path to the  end, the letters it  sees on its  path are
ABCDEF.

The little  packet looks up  at you, hoping you  can help it  find the
way. What letters will  it see (in the order it would  see them) if it
follows the  path? (The routing  diagram is  very wide; make  sure you
view it without line wrapping.)
** TODO Day 19.2                                                  :noexport:

** TODO Day 20.1                                                  :noexport:

Suddenly, the GPU contacts you, asking  for help. Someone has asked it
to simulate  too many particles, and  it won't be able  to finish them
all in time to render the next frame at this rate.

It transmits to you a buffer (your puzzle input) listing each particle
in order (starting  with particle 0, then particle 1,  particle 2, and
so on). For each particle, it provides the X, Y, and Z coordinates for
the particle's position (p), velocity  (v), and acceleration (a), each
in the format <X,Y,Z>.

Each  tick, all  particles  are updated  simultaneously. A  particle's
properties are updated in the following order:
- Increase the X velocity by the X acceleration.
- Increase the Y velocity by the Y acceleration.
- Increase the Z velocity by the Z acceleration.
- Increase the X position by the X velocity.
- Increase the Y position by the Y velocity.
- Increase the Z position by the Z velocity.

Because of seemingly tenuous  rationale involving z-buffering, the GPU
would  like to  know  which  particle will  stay  closest to  position
<0,0,0> in the  long term. Measure this using  the Manhattan distance,
which in this situation is simply the  sum of the absolute values of a
particle's X, Y, and Z position.

For example, suppose  you are only given two particles,  both of which
stay  entirely on  the X-axis  (for simplicity).  Drawing the  current
states of particles 0 and 1 (in  that order) with an adjacent a number
line and diagram  of current X positions (marked  in parentheses), the
following would take place:
#+begin_example
p=< 3,0,0>, v=< 2,0,0>, a=<-1,0,0>    -4 -3 -2 -1  0  1  2  3  4
p=< 4,0,0>, v=< 0,0,0>, a=<-2,0,0>                         (0)(1)

p=< 4,0,0>, v=< 1,0,0>, a=<-1,0,0>    -4 -3 -2 -1  0  1  2  3  4
p=< 2,0,0>, v=<-2,0,0>, a=<-2,0,0>                      (1)   (0)

p=< 4,0,0>, v=< 0,0,0>, a=<-1,0,0>    -4 -3 -2 -1  0  1  2  3  4
p=<-2,0,0>, v=<-4,0,0>, a=<-2,0,0>          (1)               (0)

p=< 3,0,0>, v=<-1,0,0>, a=<-1,0,0>    -4 -3 -2 -1  0  1  2  3  4
p=<-8,0,0>, v=<-6,0,0>, a=<-2,0,0>                         (0)   
#+end_example

At  this point,  particle  1  will never  be  closer  to <0,0,0>  than
particle 0, and so, in the long run, particle 0 will stay closest.

Which particle will stay closest to position <0,0,0> in the long term?
** TODO Day 20.2                                                  :noexport:

** TODO Day 21.1                                                  :noexport:

You find  a program  trying to  generate some art.  It uses  a strange
process  that involves  repeatedly enhancing  the detail  of an  image
through a set of rules.

The image consists of a two-dimensional square grid of pixels that are
either on (#) or off (.). The program always begins with this pattern:
#+begin_example
.#.
..#
###
#+end_example

Because the  pattern is both  3 pixels wide and  3 pixels tall,  it is
said to have a size of 3.

Then, the program repeats the following process:
- If the size is evenly divisible by 2, break the pixels up into 2x2
  squares, and convert each 2x2 square into a 3x3 square by following
  the corresponding enhancement rule.
- Otherwise, the size is evenly divisible by 3; break the pixels up
  into 3x3 squares, and convert each 3x3 square into a 4x4 square by
  following the corresponding enhancement rule.
  
Because each square  of pixels is replaced by a  larger one, the image
gains pixels and so its size increases.

The artist's book of enhancement  rules is nearby (your puzzle input);
however,  it seems  to  be  missing rules.  The  artist explains  that
sometimes,  one must  rotate  or  flip the  input  pattern  to find  a
match. (Never rotate or flip the output pattern, though.) Each pattern
is  written  concisely:  rows  are listed  as  single  units,  ordered
top-down, and separated  by slashes. For example,  the following rules
correspond to the adjacent patterns:
#+begin_example
../.#  =  ..
          .#

                .#.
.#./..#/###  =  ..#
                ###

                        #..#
#..#/..../#..#/.##.  =  ....
                        #..#
                        .##.
#+end_example

When  searching for  a rule  to use,  rotate and  flip the  pattern as
necessary. For example,  all of the following patterns  match the same
rule:
#+begin_example
.#.   .#.   #..   ###
..#   #..   #.#   ..#
###   ###   ##.   .#.
#+end_example

Suppose the book contained the following two rules:
#+begin_example
../.# => ##./#../...
.#./..#/### => #..#/..../..../#..#
#+end_example

As before, the program begins with this pattern:
#+begin_example
.#.
..#
###
#+end_example

The size of  the grid (3) is  not divisible by 2, but  it is divisible
by 3. It  divides evenly into a single square;  the square matches the
second rule, which produces:
#+begin_example
#..#
....
....
#..#
#+end_example

The size of this  enhanced grid (4) is evenly divisible  by 2, so that
rule is used. It divides evenly into four squares:
#+begin_example
#.|.#
..|..
--+--
..|..
#.|.#
#+end_example

Each of  these squares matches  the same rule (../.#  => ##./#../...),
three of which require some flipping  and rotation to line up with the
rule. The output for the rule is the same in all four cases:
#+begin_example
##.|##.
#..|#..
...|...
---+---
##.|##.
#..|#..
...|...
#+end_example

Finally, the squares are joined into a new grid:
#+begin_example
##.##.
#..#..
......
##.##.
#..#..
......
#+end_example

Thus, after 2 iterations, the grid contains 12 pixels that are on.

How many pixels stay on after 5 iterations?
** TODO Day 21.2                                                  :noexport:

** TODO Day 22.1                                                  :noexport:

Diagnostics indicate  that the local  grid computing cluster  has been
contaminated with the Sporifica Virus. The grid computing cluster is a
seemingly-infinite two-dimensional grid of compute nodes. Each node is
either clean or infected by the virus.

To prevent overloading  the nodes (which would render  them useless to
the virus)  or detection by  system administrators, exactly  one virus
carrier moves through  the network, infecting or cleaning  nodes as it
moves. The  virus carrier is  always located on  a single node  in the
network (the  current node)  and keeps  track of  the direction  it is
facing.

To avoid detection, the virus carrier  works in bursts; in each burst,
it wakes  up, does some  work, and goes  back to sleep.  The following
steps are all executed in order one time each burst:
- If the current node is infected, it turns to its right. Otherwise,
  it turns to its left. (Turning is done in-place; the current node
  does not change.)
- If the current node is clean, it becomes infected. Otherwise, it
  becomes cleaned. (This is done after the node is considered for the
  purposes of changing direction.)
- The virus carrier moves forward one node in the direction it is facing.

Diagnostics  have also  provided a  map of  the node  infection status
(your puzzle  input). Clean nodes are  shown as .; infected  nodes are
shown as #. This map only shows the center of the grid; there are many
more  nodes  beyond  those  shown,  but none  of  them  are  currently
infected.

The virus carrier begins in the middle of the map facing up.

For example, suppose you are given a map like this:
#+begin_example
..#
#..
...
#+end_example

Then, the middle of the infinite  grid looks like this, with the virus
carrier's position marked with [ ]:
#+begin_example
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . # . . .
. . . #[.]. . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
#+end_example

The virus carrier  is on a clean  node, so it turns  left, infects the
node, and moves left:
#+begin_example
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . # . . .
. . .[#]# . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
#+end_example

The virus  carrier is on an  infected node, so it  turns right, cleans
the node, and moves up:
#+begin_example
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . .[.]. # . . .
. . . . # . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
#+end_example

Four times  in a  row, the  virus carrier finds  a clean,  infects it,
turns left,  and moves  forward, ending  in the  same place  and still
facing up:
#+begin_example
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . #[#]. # . . .
. . # # # . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
#+end_example

Now on the same node as before,  it sees an infection, which causes it
to turn right, clean the node, and move forward:
#+begin_example
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . # .[.]# . . .
. . # # # . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
#+end_example

After the  above actions, a  total of 7  bursts of activity  had taken
place. Of them, 5 bursts of activity caused an infection.

After a total of 70, the grid  looks like this, with the virus carrier
facing up:
#+begin_example
. . . . . # # . .
. . . . # . . # .
. . . # . . . . #
. . # . #[.]. . #
. . # . # . . # .
. . . . . # # . .
. . . . . . . . .
. . . . . . . . .
#+end_example

By this time,  41 bursts of activity caused an  infection (though most
of those nodes have since been cleaned).

After  a total  of 10000  bursts of  activity, 5587  bursts will  have
caused an infection.

Given your actual map, after 10000 bursts of activity, how many bursts
cause  a node  to  become infected?  (Do not  count  nodes that  begin
infected.)
** TODO Day 22.2                                                  :noexport:

** TODO Day 23.1                                                  :noexport:

You  decide to  head directly  to  the CPU  and fix  the printer  from
there. As you get close, you find an experimental coprocessor doing so
much work  that the local programs  are afraid it will  halt and catch
fire. This would cause serious issues for the rest of the computer, so
you head in and see what you can do.

The  code it's  running seems  to be  a variant  of the  kind you  saw
recently on that tablet. The general functionality seems very similar,
but some of the instructions are different:
- set X Y sets register X to the value of Y.
- sub X Y decreases register X by the value of Y.
- mul X Y sets register X to the result of multiplying the value
  contained in register X by the value of Y.
- jnz X Y jumps with an offset of the value of Y, but only if the
  value of X is not zero. (An offset of 2 skips the next instruction,
  an offset of -1 jumps to the previous instruction, and so on.)
  
Only the instructions listed above are used. The eight registers here,
named a through h, all start at 0.

The coprocessor  is currently set  to some  kind of debug  mode, which
allows for testing, but prevents it from doing any meaningful work.

If you run the program (your puzzle input), how many times is the mul
instruction invoked?
** TODO Day 23.2                                                  :noexport:

** TODO Day 24.1                                                  :noexport:

The CPU itself  is a large, black building surrounded  by a bottomless
pit. Enormous metal tubes extend outward from the side of the building
at regular intervals and descend down into the void. There's no way to
cross, but you need to get inside.

No way,  of course, other than  building a bridge out  of the magnetic
components strewn about nearby.

Each component has two  ports, one on each end. The  ports come in all
different types, and only matching types can be connected. You take an
inventory  of  the  components  by   their  port  types  (your  puzzle
input). Each  port is identified by  the number of pins  it uses; more
pins mean a stronger connection for  your bridge. A 3/7 component, for
example, has  a type-3  port on  one side,  and a  type-7 port  on the
other.

Your  side of  the pit  is metallic;  a perfect  surface to  connect a
magnetic, zero-pin port. Because of this,  the first port you use must
be of type 0.  It doesn't matter what type of port  you end with; your
goal is just to make the bridge as strong as possible.

The  strength of  a  bridge is  the  sum  of the  port  types in  each
component. For example, if your bridge is made of components 0/3, 3/7,
and 7/4, your bridge has a strength of 0+3 + 3+7 + 7+4 = 24.

For example, suppose you had the following components:
#+begin_example
0/2
2/2
2/3
3/4
3/5
0/1
10/1
9/10
#+end_example

With them, you could make the following valid bridges:
#+begin_example
    0/1
    0/1--10/1
    0/1--10/1--9/10
    0/2
    0/2--2/3
    0/2--2/3--3/4
    0/2--2/3--3/5
    0/2--2/2
    0/2--2/2--2/3
    0/2--2/2--2/3--3/4
    0/2--2/2--2/3--3/5
#+end_example

(Note how, as shown by 10/1, order of ports within a component doesn't
matter. However, you may only use each port on a component once.)

Of  these bridges,  the strongest  one  is 0/1--10/1--9/10;  it has  a
strength of 0+1 + 1+10 + 10+9 = 31.

What is  the strength of  the strongest bridge  you can make  with the
components you have available?
** TODO Day 24.2                                                  :noexport:

** TODO Day 25.1                                                  :noexport:

Following the twisty  passageways deeper and deeper into  the CPU, you
finally reach the core of the computer. Here, in the expansive central
chamber,  you find  a  grand  apparatus that  fills  the entire  room,
suspended nanometers above your head.

You had  always imagined  CPUs to be  noisy, chaotic  places, bustling
with activity. Instead, the room is quiet, motionless, and dark.

Suddenly,   you  and   the  CPU's   garbage  collector   startle  each
other.  "It's not  often we  get many  visitors here!",  he says.  You
inquire about the stopped machinery.

"It stopped milliseconds  ago; not sure why. I'm  a garbage collector,
not a doctor." You ask what the machine is for.

"Programs  these days,  don't know  their origins.  That's the  Turing
machine! It's what makes the whole  computer work." You try to explain
that Turing machines are merely models of computation, but he cuts you
off. "No,  see, that's just what  they want you to  think. Ultimately,
inside every  CPU, there's a  Turing machine driving the  whole thing!
Too bad this one's broken. We're doomed!"

You ask  how you can help.  "Well, unfortunately, the only  way to get
the  computer running  again would  be to  create a  whole new  Turing
machine from scratch, but there's no way you can-" He notices the look
on your  face, gives you  a curious glance,  shrugs, and goes  back to
sweeping the floor.

You find the Turing machine blueprints (your puzzle input) on a tablet
in  a nearby  pile of  debris. Looking  back up  at the  broken Turing
machine above, you can start to identify its parts:
- A tape which contains 0 repeated infinitely to the left and right.
- A cursor, which can move left or right along the tape and read or
  write values at its current position.
- A set of states, each containing rules about what to do based on the
  current value under the cursor.
  
Each slot on  the tape has two possible values:  0 (the starting value
for all slots) and  1. Based on whether the cursor is  pointing at a 0
or a  1, the  current state says  what value to  write at  the current
position of the  cursor, whether to move the cursor  left or right one
slot, and which state to use next.

For example, suppose you found the following blueprint:
#+begin_example
Begin in state A.
Perform a diagnostic checksum after 6 steps.

In state A:
  If the current value is 0:
    - Write the value 1.
    - Move one slot to the right.
    - Continue with state B.
  If the current value is 1:
    - Write the value 0.
    - Move one slot to the left.
    - Continue with state B.

In state B:
  If the current value is 0:
    - Write the value 1.
    - Move one slot to the left.
    - Continue with state A.
  If the current value is 1:
    - Write the value 1.
    - Move one slot to the right.
    - Continue with state A.
#+end_example

Running  it until  the number  of steps  required to  take the  listed
diagnostic checksum would result  in the following tape configurations
(with the cursor marked in square brackets):
#+begin_example
... 0  0  0 [0] 0  0 ... (before any steps; about to run state A)
... 0  0  0  1 [0] 0 ... (after 1 step;     about to run state B)
... 0  0  0 [1] 1  0 ... (after 2 steps;    about to run state A)
... 0  0 [0] 0  1  0 ... (after 3 steps;    about to run state B)
... 0 [0] 1  0  1  0 ... (after 4 steps;    about to run state A)
... 0  1 [1] 0  1  0 ... (after 5 steps;    about to run state B)
... 0  1  1 [0] 1  0 ... (after 6 steps;    about to run state A)
#+end_example

The CPU  can confirm that  the Turing machine  is working by  taking a
diagnostic checksum  after a  specific number of  steps (given  in the
blueprint). Once the specified number of steps have been executed, the
Turing machine should pause; once it does, count the number of times 1
appears on  the tape.  In the above  example, the  diagnostic checksum
is 3.

Recreate  the  Turing machine  and  save  the  computer! What  is  the
diagnostic checksum it produces once it's working again?
** TODO Day 25.2                                                  :noexport:
** Stats                                                          :noexport:

#+CAPTION: https://adventofcode.com/2017/stats
| 25 |  6 | ▉▉▉▉▉▉                                    |
| 24 |  6 | ▉▉▉▉▉▉                                    |
| 23 |  6 | ▉▉▉▉▉▉                                    |
| 22 |  7 | ▉▉▉▉▉▉▉                                   |
| 21 |  7 | ▉▉▉▉▉▉▉                                   |
| 20 |  7 | ▉▉▉▉▉▉▉                                   |
| 19 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 18 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
| 17 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
| 16 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
| 15 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
| 14 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
| 13 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
| 12 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
| 11 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
| 10 | 12 | ▉▉▉▉▉▉▉▉▉▉▉▉                              |
|  9 | 13 | ▉▉▉▉▉▉▉▉▉▉▉▉▉                             |
|  8 | 15 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                           |
|  7 | 17 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                         |
|  6 | 18 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                        |
|  5 | 21 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                     |
|  4 | 24 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                  |
|  3 | 24 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                  |
|  2 | 34 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉        |
|  1 | 41 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ |
#+TBLFM: $3='(orgtbl-uc-draw-grid $2 0 41 41)


* 2016 [18/50]
** DONE Day 1.1

Santa's  sleigh  uses  a  very   high-precision  clock  to  guide  its
movements,   and    the   clock's    oscillator   is    regulated   by
stars.  Unfortunately, the  stars have  been stolen...  by the  Easter
Bunny. To save Christmas, Santa needs  you to retrieve all fifty stars
by December 25th.

Collect stars by  solving puzzles. Two puzzles will  be made available
on each day in the Advent calendar; the second puzzle is unlocked when
you complete the first. Each puzzle grants one star. Good luck!

You're   airdropped  near   Easter  Bunny   Headquarters  in   a  city
somewhere. "Near",  unfortunately, is as  close as  you can get  - the
instructions  on  the  Easter  Bunny  Recruiting  Document  the  Elves
intercepted start here, and nobody had time to work them out further.

The Document indicates that you  should start at the given coordinates
(where  you just  landed) and  face North.  Then, follow  the provided
sequence: either  turn left  (L) or  right (R)  90 degrees,  then walk
forward the given number of blocks, ending at a new intersection.

There's  no  time to  follow  such  ridiculous instructions  on  foot,
though, so you take a moment  and work out the destination. Given that
you can  only walk  on the  street grid of  the city,  how far  is the
shortest path to the destination?

For example:
- Following R2, L3 leaves you 2 blocks East and 3 blocks North, or 5
  blocks away.
- R2, R2, R2 leaves you 2 blocks due South of your starting position,
  which is 2 blocks away.
- R5, L5, R5, R3 leaves you 12 blocks away.

How many blocks away is Easter Bunny HQ?

#+begin_src fennel -n :session d1601 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [input]
  (var x 0)
  (var y 0)
  (let [steps (aoc.string-split (. input 1) ", ")]
    (each [_ step (ipairs steps)]
      (let [D (string.sub step 1 1)
            d (string.sub step 2)]
        (if (= "R" D)
            (let [y1 (- y)]
              (set y x)
              (set x y1))
            (let [x1 (- x)]
              (set x y)
              (set y x1)))
        (set x (+ (tonumber d) x)))))
  (aoc.manhattan-dist [x y] [0 0]))

(fn test [expected input]
  (assert (= expected (solve [input]))))

(test 5 "R2, L3")
(test 2 "R2, R2, R2")
(test 12 "R5, L5, R5, R3")

(solve (aoc.string-from "2016/01.inp"))
#+end_src

#+RESULTS:
: 161


** DONE Day 1.2

Then,  you  notice  the  instructions  continue on  the  back  of  the
Recruiting Document. Easter Bunny HQ is actually at the first location
you visit twice.

For  example, if  your  instructions are  R8, R4,  R4,  R8, the  first
location you visit twice is 4 blocks away, due East.

How many blocks away is the first location you visit twice?

#+begin_src fennel -n :session d1601 :exports both
(fn solve2 [input]
  (var dir (/ math.pi 2))
  (var x 0)
  (var y 0)
  (var done false)
  (let [steps (aoc.string-split (. input 1) ", ")
        res [[0 0]]]
    (each [_ step (ipairs steps) &until done]
      (let [D (string.sub step 1 1)
            d (string.sub step 2)]
        (if (= "R" D)
            (set dir (- dir (/ math.pi 2)))
            (set dir (+ dir (/ math.pi 2))))
        (set x (+ x (* d (lume.round (math.cos dir)))))
        (set y (+ y (* d (lume.round (math.sin dir))))))
      (let [[fx fy] (table.remove res)
            [tx ty] [x y]]
        (if (= fx tx)
            (for [i fy ty (if (< ty fy) -1 1) &until done]
              (if (aoc.matrix-contains? res [x i])
                  (do 
                    (set done true)
                    (set y i))
                  (table.insert res [x i])))
            (for [i fx tx (if (< tx fx) -1 1) &until done]
              (if (aoc.matrix-contains? res [i y])
                  (do 
                    (set done true)
                    (set x i))
                  (table.insert res [i y]))))))
    (+ (math.abs x) (math.abs y))))

(fn test2 [expected input]
  (assert (= expected (solve2 [input]))))

(test2 4 "R8, R4, R4, R8")

(solve2 (aoc.string-from "2016/01.inp"))
#+end_src

#+RESULTS:
: 110

** DONE Day 2.1

You   arrive   at   Easter   Bunny   Headquarters   under   cover   of
darkness. However, you left in such a  rush that you forgot to use the
bathroom! Fancy  office buildings  like this  one usually  have keypad
locks on their bathrooms, so you search the front desk for the code.

"In order to improve security,"  the document you find says, "bathroom
codes will  no longer  be written down.  Instead, please  memorize and
follow the procedure below to access the bathrooms."

The document goes on to explain that  each button to be pressed can be
found  by starting  on  the  previous button  and  moving to  adjacent
buttons on the keypad:  U moves up, D moves down, L  moves left, and R
moves  right. Each  line of  instructions corresponds  to one  button,
starting  at the  previous button  (or, for  the first  line, the  "5"
button); press whatever button you're on at the end of each line. If a
move doesn't lead to a button, ignore it.

You can't hold it much longer, so you decide to figure out the code as
you walk to the bathroom. You picture a keypad like this:

#+begin_example
1 2 3
4 5 6
7 8 9
#+end_example

Suppose your instructions are:

#+begin_example
ULL
RRDDD
LURDL
UUUUD
#+end_example

- You start at "5" and move up (to "2"), left (to "1"), and left (you
  can't, and stay on "1"), so the first button is 1.
- Starting from the previous button ("1"), you move right twice (to
  "3") and then down three times (stopping at "9" after two moves and
  ignoring the third), ending up with 9.
- Continuing from "9", you move left, up, right, down, and left, ending with 8.
- Finally, you move up four times (stopping at "2"), then down once,
  ending with 5.

So, in this example, the bathroom code is 1985.

Your puzzle input  is the instructions from the document  you found at
the front desk. What is the bathroom code?

#+begin_src fennel -n :session d1602 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input
       ["ULL"
        "RRDDD"
        "LURDL"
        "UUUUD"])

(fn solve [input]
  (let [pos {:x 2 :y 2}
        xs (lume.map input #(aoc.string-toarray $))
        keypad [[1 2 3]
               [4 5 6]
               [7 8 9]]
        res []]
    (each [_ ys (ipairs xs)]
      (each [_ x (ipairs ys)]
        (case x
          "U" (tset pos :y (math.max 1 (- (. pos :y) 1)))
          "D" (tset pos :y (math.min 3 (+ 1 (. pos :y))))
          "R" (tset pos :x (math.min 3 (+ 1 (. pos :x))))
          "L" (tset pos :x (math.max 1 (- (. pos :x) 1)))))
      (table.insert res (. (. keypad (. pos :y)) (. pos :x))))
    (table.concat res "")))

(fn test [expected input]
  (assert (= expected (solve input))))

(test "1985" test-input)

(solve (aoc.string-from "2016/02.inp"))
#+end_src

#+RESULTS:
: 35749


** DONE Day 2.2

You finally  arrive at the bathroom  (it's a several minute  walk from
the lobby so  visitors can behold the many fancy  conference rooms and
water coolers on this floor) and go to punch in the code. Much to your
bladder's  dismay,  the  keypad  is  not  at  all  like  you  imagined
it.  Instead,  you are  confronted  with  the  result of  hundreds  of
man-hours of bathroom-keypad-design meetings:

#+begin_example
    1
  2 3 4
5 6 7 8 9
  A B C
    D
#+end_example

You still start at "5" and stop  when you're at an edge, but given the
same instructions as above, the outcome is very different:
- You start at "5" and don't move at all (up and left are both edges),
  ending at 5.
- Continuing  from "5",  you move  right  twice and  down three  times
  (through "6", "7", "B", "D", "D"), ending at D.
- Then, from  "D", you move  five more  times (through "D",  "B", "C",
  "C", "B"), ending at B.
- Finally, after five more moves, you end at 3.

So, given the actual keypad layout,  the code would be =5DB3=. Using the
same instructions in  your puzzle input, what is  the correct bathroom
code?

#+begin_src fennel -n :session d1602 :exports both
(fn solve2 [input]
  (let [pos {:x 1 :y 3}
        xs (lume.map input #(aoc.string-toarray $))
        keypad [["0" "0" "1" "0" "0"]
                ["0" "2" "3" "4" "0"]
                ["5" "6" "7" "8" "9"]
                ["0" "A" "B" "C" "0"]
                ["0" "0" "D" "0" "0"]]
        res []]
    (each [_ ys (ipairs xs)]
      (each [_ x (ipairs ys)]
        (case x
          "U" (let [newy (math.max 1 (- (. pos :y) 1))]
                (when (not= 0 (tonumber (. (. keypad newy) (. pos :x))))
                    (tset pos :y newy)))
          "D" (let [newy (math.min 5 (+ 1 (. pos :y)))]
                (when (not= 0 (tonumber (. (. keypad newy) (. pos :x))))
                  (tset pos :y newy)))
          "R" (let [newx (math.min 5 (+ 1 (. pos :x)))]
                (when (not= 0 (tonumber (. (. keypad (. pos :y)) newx)))
                  (tset pos :x newx)))
          "L" (let [newx (math.max 1 (- (. pos :x) 1))]
                (when (not= 0 (tonumber (. (. keypad (. pos :y)) newx)))
                  (tset pos :x newx)))))
      (table.insert res (. (. keypad (. pos :y)) (. pos :x))))
    (table.concat res "")))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 "5DB3" test-input)

(solve2 (aoc.string-from "2016/02.inp"))
#+end_src

#+RESULTS:
: 9365C

** DONE Day 3.1

Now that you can think clearly,  you move deeper into the labyrinth of
hallways and office furniture that makes  up this part of Easter Bunny
HQ. This must be a graphic design department; the walls are covered in
specifications for triangles.

Or are they?

The  design  document gives  the  side  lengths  of each  triangle  it
describes, but... 5  10 25? Some of these aren't  triangles. You can't
help but mark the impossible ones.

In a valid triangle, the sum of  any two sides must be larger than the
remaining side. For example, the "triangle" given above is impossible,
because 5 + 10 is not larger than 25.

In your puzzle input, how many of the listed triangles are possible?

#+begin_src fennel -n :session d1603 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["  5  10  25"])

(fn triangle? [a b c]
  (and
   (< a (+ b c))
   (< b (+ a c))
   (< c (+ a b))))

(fn count-triangles [xs]
  (var res 0)
  (each [_ [a b c] (ipairs xs)]
    (when (triangle? a b c)
      (set res (+ 1 res))))
  res)

(fn solve [input]
  (-> input
      (lume.map #(aoc.string-tonumarray $))
      (count-triangles)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 0 test-input)

(solve (aoc.string-from "2016/03.inp"))
#+end_src

#+RESULTS:
: 1050

** DONE Day 3.2

Now that you've helpfully marked  up their design documents, it occurs
to   you   that  triangles   are   specified   in  groups   of   three
vertically.  Each  set  of  three  numbers in  a  column  specifies  a
triangle. Rows are unrelated.

For example, given the following  specification, numbers with the same
hundreds digit would be part of the same triangle:

#+begin_example
101 301 501
102 302 502
103 303 503
201 401 601
202 402 602
203 403 603
#+end_example

In your puzzle input, and instead  reading by columns, how many of the
listed triangles are possible?

#+begin_src fennel -n :session d1603 :exports both
(fn solve2 [input]
  (-> input
      (lume.map #(aoc.string-tonumarray $))
      (aoc.table-transpose)
      (lume.map #(aoc.partition3 $))
      (aoc.table-flatten)
      (count-triangles)))

(solve2 (aoc.string-from "2016/03.inp"))
#+end_src

#+RESULTS:
: 1921

** DONE Day 4.1

Finally, you come across an information kiosk with a list of rooms. Of
course,  the  list is  encrypted  and  full  of  decoy data,  but  the
instructions  to decode  the  list are  barely  hidden nearby.  Better
remove the decoy data first.

Each room consists  of an encrypted name  (lowercase letters separated
by dashes) followed by  a dash, a sector ID, and  a checksum in square
brackets.

A room is real  (not a decoy) if the checksum is  the five most common
letters  in  the  encrypted  name,  in  order,  with  ties  broken  by
alphabetization. For example:
- aaaaa-bbb-z-y-x-123[abxyz] is a real room because the most common
  letters are a (5), b (3), and then a tie between x, y, and z, which
  are listed alphabetically.
- a-b-c-d-e-f-g-h-987[abcde] is a real room because although the
  letters are all tied (1 of each), the first five are listed
  alphabetically.
- not-a-real-room-404[oarel] is a real room.
- totally-real-room-200[decoy] is not.

Of the  real rooms from  the list above, the  sum of their  sector IDs
is 1514.

What is the sum of the sector IDs of the real rooms?

#+begin_src fennel -n :session d1604 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["aaaaa-bbb-z-y-x-123[abxyz]"
        "a-b-c-d-e-f-g-h-987[abcde]"
        "not-a-real-room-404[oarel]"
        "totally-real-room-200[decoy]"])

(fn parse-rooms [s]
  (let [len (string.len s)]
    [(string.sub s 1 (- len 11))
     (tonumber (string.sub s (- len 9) (- len 7)))
     (string.sub s (- len 5) (- len 1))]))

(fn checksum [room]
  (-> room
      (string.gsub "%-" "")
      (aoc.string-toarray)
      (aoc.table-sort)
      (aoc.partition-by #(= $1 $2))
      (aoc.table-sort (fn [x y] (if (= (# x) (# y))
                                    (< (. x 1) (. y 1))
                                    (>= (# x) (# y)))))
      (lume.map #(. $ 1))
      (table.concat "")
      (string.sub 1 5)))

(fn solve [input]
  (-> input
      (lume.map #(parse-rooms $))
      (lume.filter #(= (checksum (. $ 1)) (. $ 3)))
      (lume.map #(. $ 2))
      (lume.reduce #(+ $1 $2))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 1514 test-input)

(solve (aoc.string-from "2016/04.inp"))
#+end_src

#+RESULTS:
: 361724


** DONE Day 4.2

With all the decoy data out of the way, it's time to decrypt this list
and get moving.

The room names are encrypted by a state-of-the-art shift cipher, which
is  nearly  unbreakable  without  the  right  software.  However,  the
information kiosk designers  at Easter Bunny HQ were  not expecting to
deal with a master cryptographer like yourself.

To  decrypt  a room  name,  rotate  each  letter forward  through  the
alphabet a number of times equal to the room's sector ID. A becomes B,
B becomes C, Z becomes A, and so on. Dashes become spaces.

For  example,  the  real  name for  =qzmt-zixmtkozy-ivhz-343=  is  =very
encrypted name=.

What is the sector ID of the room where North Pole objects are stored?

#+begin_src fennel -n :session d1604 :exports both
(local test2-input ["qzmt-zixmtkozy-ivhz-343[zimth]"])

(fn ceasar-decrypt [[room id sum]]
  (let [xs (aoc.string-split room "-")]
    (lume.map xs #(aoc.string-shift $ id))))

(fn solve2 [input target]
  (-> input
      (lume.map #(parse-rooms $))
      (lume.filter #(= (checksum (. $ 1)) (. $ 3)))
      (lume.map (fn [e] [(table.concat (ceasar-decrypt e) " ")
                         (. e 2)]))
      (lume.filter (fn [e] (= target (. e 1))))
      (aoc.first)
      (. 2)))

(fn test2 [expected input target]
  (assert (= expected (solve2 input target))))

(test2 343 test2-input "very encrypted name")

(solve2 (aoc.string-from "2016/04.inp") "northpole object storage")
#+end_src

#+RESULTS:
: 482

** DONE Day 5.1

You are faced with a security  door designed by Easter Bunny engineers
that  seem  to have  acquired  most  of  their security  knowledge  by
watching hacking movies.

The eight-character password  for the door is  generated one character
at a time by finding the MD5  hash of some Door ID (your puzzle input)
and an increasing integer index (starting with 0).

A hash indicates the next character in the password if its hexadecimal
representation  starts  with  five  zeroes.  If  it  does,  the  sixth
character in the hash is the next character of the password.

For example, if the Door ID is abc:
- The first index which produces a hash that starts with five zeroes
  is 3231929, which we find by hashing abc3231929; the sixth character
  of the hash, and thus the first character of the password, is 1.
- 5017308 produces the next interesting hash, which starts with
  000008f82..., so the second character of the password is 8.
- The third time a hash starts with five zeroes is for abc5278568,
  discovering the character f.
  
In this example, after continuing this  search a total of eight times,
the password is 18f47a30.

Given the actual Door ID, what is the password?

#+begin_src fennel -n :session d1605 :exports both
(local md5 (require :lib.md5))
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn solve [input]
  (var salt 0)
  (let [res []]
    (while (< (# res) 8)
      (let [hash (md5.sumhexa (.. input salt))
            prefix (string.sub hash 1 5)]
        (when (= "00000" prefix)
          (table.insert res (string.sub hash 6 6)))
        (set salt (+ 1 salt))))
    (table.concat res "")))

(solve "reyedfim")
#+end_src

#+RESULTS:
: f97c354d

** DONE Day 5.2

As the  door slides open,  you are presented  with a second  door that
uses a slightly more  inspired security mechanism. Clearly unimpressed
by  the last  version  (in what  movie is  the  password decrypted  in
order?!),  the  Easter  Bunny  engineers  have  worked  out  a  [[https://www.youtube.com/watch?v=NHWjlCaIrQo&t=25][better
solution]].

Instead of simply filling in the password from left to right, the hash
now also indicates the position within the password to fill. You still
look for hashes  that begin with five zeroes; however,  now, the sixth
character represents the position (0-7),  and the seventh character is
the character to put in that position.

A hash result of  000001f means that f is the  second character in the
password.  Use only  the first  result for  each position,  and ignore
invalid positions.

For example, if the Door ID is =abc=:
- The first interesting hash is from abc3231929, which produces
  0000015...; so, 5 goes in position 1: _5______.
- In the previous method, 5017308 produced an interesting hash;
  however, it is ignored, because it specifies an invalid position
  (8).
- The second interesting hash is at index 5357525, which produces
  000004e...; so, e goes in position 4: _5__e___.

You almost  choke on your  popcorn as  the final character  falls into
place, producing the password 05ace8e3.

Given the actual Door ID and this new method, what is the password?

#+begin_src fennel -n :session d1605 :exports both
(fn solve2 [input]
  (var salt 0)
  (let [res ["" "" "" "" "" "" "" ""]]
    (while (lume.find res "")
      (let [hash (md5.sumhexa (.. input salt))
            prefix (string.sub hash 1 5)]
        (when (= "00000" prefix)
          (let [pos (tonumber (string.sub hash 6 6))]
            (when (and pos (<= 0 pos 7) (= "" (. res (+ 1 pos))))
              (aoc.table-swap res (+ 1 pos) (string.sub hash 7 7)))))
        (set salt (+ 1 salt))))
    (table.concat res "")))

(solve2 "reyedfim")
#+end_src

#+RESULTS:
: 863dde27

** DONE Day 6.1

Something is jamming your communications with Santa. Fortunately, your
signal is only partially jammed,  and protocol in situations like this
is to switch to a simple repetition code to get the message through.

In this  model, the same  message is sent repeatedly.  You've recorded
the repeating message  signal (your puzzle input), but  the data seems
quite corrupted - almost too badly to recover. Almost.

All you need to do is figure  out which character is most frequent for
each position.  For example,  suppose you  had recorded  the following
messages:

#+begin_example
eedadn
drvtee
eandsr
raavrd
atevrs
tsrnev
sdttsa
rasrtv
nssdts
ntnada
svetve
tesnvt
vntsnd
vrdear
dvrsen
enarar
#+end_example

The most common character in the first  column is e; in the second, a;
in the  third, s, and  so on.  Combining these characters  returns the
error-corrected message, easter.

Given the recording in your puzzle input, what is the error-corrected
version of the message being sent?

#+begin_src fennel -n :session d1606 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input
       ["eedadn"
        "drvtee"
        "eandsr"
        "raavrd"
        "atevrs"
        "tsrnev"
        "sdttsa"
        "rasrtv"
        "nssdts"
        "ntnada"
        "svetve"
        "tesnvt"
        "vntsnd"
        "vrdear"
        "dvrsen"
        "enarar"])

(fn solve [input]
  (-> input
      (aoc.read-matrix)
      (aoc.table-transpose)
      (lume.map aoc.table-sort)
      (lume.map #(aoc.partition-by $ (fn [e1 e2] (= e1 e2))))
      (lume.map #(aoc.table-sort $ (fn [e1 e2] (> (length e1) (length e2)))))
      (lume.map #(. (. $ 1) 1))
      (lume.reduce #(.. $1 $2))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test "easter" test-input)

(solve (aoc.string-from "2016/06.inp"))
#+end_src

#+RESULTS:
: qtbjqiuq

** DONE Day 6.2

Of course, that would be the message - if you hadn't agreed to use a
modified repetition code instead.

In this  modified code, the  sender instead transmits what  looks like
random data, but for each  character, the character they actually want
to  send  is  slightly  less   likely  than  the  others.  Even  after
signal-jamming noise, you can look at the letter distributions in each
column and choose the least  common letter to reconstruct the original
message.

In the above  example, the least common character in  the first column
is a;  in the  second, d, and  so on. Repeating  this process  for the
remaining characters produces the original message, advent.

Given  the  recording in  your  puzzle  input  and this  new  decoding
methodology,  what is  the original  message that  Santa is  trying to
send?

#+begin_src fennel -n :session d1606 :exports both
(fn solve2 [input]
  (-> input
      (aoc.read-matrix)
      (aoc.table-transpose)
      (lume.map aoc.table-sort)
      (lume.map #(aoc.partition-by $ (fn [e1 e2] (= e1 e2))))
      (lume.map #(aoc.table-sort $ (fn [e1 e2] (< (length e1) (length e2)))))
      (lume.map #(. (. $ 1) 1))
      (lume.reduce #(.. $1 $2))))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 "advent" test-input)

(solve2 (aoc.string-from "2016/06.inp"))
#+end_src

#+RESULTS:
: akothqli

** DONE Day 7.1

While snooping around the local network of EBHQ, you compile a list of
IP   addresses  (they're   IPv7,   of  course;   IPv6   is  much   too
limited).   You'd  like   to  figure   out  which   IPs  support   TLS
(transport-layer snooping).

An IP supports  TLS if it has an Autonomous  Bridge Bypass Annotation,
or ABBA.  An ABBA is any  four-character sequence which consists  of a
pair of two different characters followed by the reverse of that pair,
such as  xyyx or  abba. However,  the IP  also must  not have  an ABBA
within any hypernet sequences, which are contained by square brackets.

For example:
- abba[mnop]qrst supports TLS (abba outside square brackets).
- abcd[bddb]xyyx does not support TLS (bddb is within square brackets,
  even though xyyx is outside square brackets).
- aaaa[qwer]tyui does not support TLS (aaaa is invalid; the interior
  characters must be different).
- ioxxoj[asdfgh]zxcvbn supports TLS (oxxo is outside square brackets,
  even though it's within a larger string).

How many IPs in your puzzle input support TLS?

#+begin_src fennel -n :session d1607 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input
       ["abba[mnop]qrst"
        "abcd[bddb]xyyx"
        "aaaa[qwer]tyui"
        "ioxxoj[asdfgh]zxcvbn"])

(fn find-abba-index [s]
  (let [xs (aoc.string-toarray s)]
    (var done false)
    (for [i 4 (# xs) &until done]
      (when (and
             (= (. xs (- i 3)) (. xs i))
             (= (. xs (- i 2)) (. xs (- i 1)))
             (not= (. xs i) (. xs (- i 1))))
        (set done (- i 3))))
    done))

(fn is-abba? [s]
  (< 0 (or (find-abba-index s) 0) (length s)))

(fn is-hyper-abba? [s]
  (let [b (string.find s "[" 1 true)
        e (string.find s "]" 1 true)]
    (if (= nil b e) false
        (or (is-abba? (string.sub s b e))
            (is-hyper-abba? (string.sub s (+ 1 e)))))))

(fn solve [input]
  (-> input
      (lume.filter #(not (is-hyper-abba? $)))
      (lume.count #(is-abba? $))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 2 test-input)

(solve (aoc.string-from "2016/07.inp"))
#+end_src

#+RESULTS:
: 110

** DONE Day 7.2

You  would also  like  to  know which  IPs  support SSL  (super-secret
listening).

An  IP supports  SSL if  it has  an Area-Broadcast  Accessor, or  ABA,
anywhere  in  the supernet  sequences  (outside  any square  bracketed
sections), and a corresponding Byte Allocation Block, or BAB, anywhere
in  the hypernet  sequences. An  ABA is  any three-character  sequence
which consists of the same  character twice with a different character
between them,  such as  xyx or  aba. A corresponding  BAB is  the same
characters but in reversed positions: yxy and bab, respectively.

For example:
- aba[bab]xyz  supports   SSL  (aba   outside  square   brackets  with
  corresponding bab within square brackets).
- xyx[xyx]xyx does not support SSL (xyx, but no corresponding yxy).
- aaa[kek]eke supports SSL (eke in  supernet with corresponding kek in
  hypernet;  the aaa  sequence is  not related,  because the  interior
  character must be different).
- zazbz[bzb]cdb supports  SSL (zaz has  no corresponding aza,  but zbz
  has a corresponding bzb, even though zaz and zbz overlap).

How many IPs in your puzzle input support SSL?

#+begin_src fennel -n :session d1607 :exports both
(local test2-input
       ["aba[bab]xyz"
        "xyx[xyx]xyx"
        "aaa[kek]eke"
        "zazbz[bzb]cdb"])

(fn find-aba-index [s ?j]
  (let [xs (aoc.string-toarray s)
        j (or ?j 1)]
    (var done false)
    (for [i (+ j 2) (# xs) &until done]
      (when (and
             (not= "]" (. xs i))
             (not= "[" (. xs i))
             (not= "[" (. xs (- i 1)))
             (not= "]" (. xs (- i 1)))
             (not= (. xs (- i 1)) (. xs i))
             (= (. xs (- i 2)) (. xs i)))
        (set done (- i 2))))
    done))

(fn match-aba-to-bab [s ?h]
  (let [i (find-aba-index s ?h)]
    (if (not i) []
        (let [bab (.. (string.sub s (+ 1 i) (+ 1 i))
                      (string.sub s i i)
                      (string.sub s (+ 1 i) (+ 1 i)))
              btwn (fn [xs x] (and (< (. xs 1) x) (< (+ x 2) (. xs 2))))
              op-ind (aoc.string-all-indices s "[")
              clo-ind (aoc.string-all-indices s "]")
              brackets (aoc.table-zip op-ind clo-ind)
              j (lume.filter (aoc.string-all-indices s bab)
                             (fn [jj] (lume.any brackets (fn [br] (btwn br jj)))))]

          (if (and (lume.all brackets #(not (btwn $ i))) (< 0 (length j)))
              [i (. j 1)]
              (match-aba-to-bab s (+ 1 i)))))))

(fn solve2 [input]
  (-> input
      (lume.map match-aba-to-bab)
      (lume.filter aoc.not-empty?)
      (length)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 3 test2-input)

(solve2 (aoc.string-from "2016/07.inp"))
#+end_src

#+RESULTS:
: 242


** DONE Day 8.1

You come  across a door  implementing what you  can only assume  is an
implementation  of  two-factor authentication  after  a  long game  of
requirements telephone.

To get past the door, you first swipe a keycard (no problem; there was
one on a  nearby desk). Then, it  displays a code on  a little screen,
and  you type  that  code  on a  keypad.  Then,  presumably, the  door
unlocks.

Unfortunately,  the screen  has  been smashed.  After  a few  minutes,
you've taken  everything apart and figured  out how it works.  Now you
just have to work out what the screen would have displayed.

The  magnetic  strip on  the  card  you  swiped  encodes a  series  of
instructions  for  the  screen;  these instructions  are  your  puzzle
input. The screen  is 50 pixels wide  and 6 pixels tall,  all of which
start off, and is capable of three somewhat peculiar operations:
- rect AxB turns on all of the pixels in a rectangle at the top-left
  of the screen which is A wide and B tall.
- rotate row y=A by B shifts all of the pixels in row A (0 is the top
  row) right by B pixels. Pixels that would fall off the right end
  appear at the left end of the row.
- rotate column x=A by B shifts all of the pixels in column A (0 is
  the left column) down by B pixels. Pixels that would fall off the
  bottom appear at the top of the column.
  
For example, here is a simple sequence on a smaller screen:

#+begin_example
rect 3x2 creates a small rectangle in the top-left corner:

###....
###....
.......

rotate column x=1 by 1 rotates the second column down by one pixel:

#.#....
###....
.#.....

rotate row y=0 by 4 rotates the top row right by four pixels:

....#.#
###....
.#.....

rotate column x=1 by 1 again rotates the second column down by one
pixel, causing the bottom pixel to wrap back to the top:

.#..#.#
#.#....
.#.....
#+end_example

As you  can see,  this display technology  is extremely  powerful, and
will soon dominate the tiny-code-displaying-screen market. That's what
the advertisement  on the back of  the display tries to  convince you,
anyway.

There seems  to be an  intermediate check of  the voltage used  by the
display: after you  swipe your card, if the screen  did work, how many
pixels should be lit?

#+begin_src fennel -n :session d1608 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input
       ["rect 3x2"
        "rotate column x=1 by 1"
        "rotate row y=0 by 4"
        "rotate column x=1 by 1"])

(fn rect [xs [x y]]
  (for [i 1 y]
    (for [j 1 x]
      (aoc.table-swap (. xs i) j 1)))
  xs)

(fn shift-row [xs y v]
  (let [ys (. xs y)
        zs (aoc.table-shift ys v)]
    (aoc.table-swap xs y zs)))

(fn shift-col [xs x v]
  (-> xs
      (aoc.table-transpose)
      (shift-row x v)
      (aoc.table-transpose)))

(fn read-input [xs input]
  (var res xs)
  (each [_ s (ipairs input)]
    (case (aoc.string-split s " ")
      ["rect" XY]
      (set res (rect res (aoc.string-split XY "x")))
      ["rotate" "column" X "by" v]
      (set res (shift-col res (+ 1 (tonumber (string.sub X 3))) (tonumber v)))
      ["rotate" "row" Y "by" v]
      (set res (shift-row res (+ 1 (tonumber (string.sub Y 3))) (tonumber v)))
      _ (print (.. "No match for " s))))
  res)

(fn solve [input X Y]
  (-> (aoc.matrix X Y 0)
      (read-input input)
      (aoc.table-sum)))

(fn test [expected input]
  (assert (= expected (solve input 7 3))))

(test 6 test-input)

(solve (aoc.string-from "2016/08.inp") 50 6)
#+end_src

#+RESULTS:
: 128

** DONE Day 8.2

You  notice that  the screen  is  only capable  of displaying  capital
letters; in the font it uses, each letter is 5 pixels wide and 6 tall.


After you swipe your card, what code is the screen trying to display?

#+begin_src fennel -n :session d1608 :results output :exports both
(fn solve2 [input X Y]
  (-> (aoc.matrix X Y 0)
      (read-input input)
      (aoc.matrix-print)))

(solve2 (aoc.string-from "2016/08.inp") 50 6)
#+end_src

#+RESULTS:
: ####..##...##..###...##..###..#..#.#...#.##...##..
: #....#..#.#..#.#..#.#..#.#..#.#..#.#...##..#.#..#.
: ###..#..#.#..#.#..#.#....#..#.####..#.#.#..#.#..#.
: #....#..#.####.###..#.##.###..#..#...#..####.#..#.
: #....#..#.#..#.#.#..#..#.#....#..#...#..#..#.#..#.
: ####..##..#..#.#..#..###.#....#..#...#..#..#..##..

** DONE Day 9.1

Wandering around a  secure area, you come across a  datalink port to a
new part  of the  network. After briefly  scanning it  for interesting
files,   you  find   one  file   in  particular   that  catches   your
attention.   It's  compressed   with  an   experimental  format,   but
fortunately, the documentation for the format is nearby.

The  format  compresses  a   sequence  of  characters.  Whitespace  is
ignored. To indicate  that some sequence should be  repeated, a marker
is added to the file, like (10x2). To decompress this marker, take the
subsequent  10 characters  and  repeat them  2  times. Then,  continue
reading the  file after the  repeated data.  The marker itself  is not
included in the decompressed output.

If parentheses or  other characters appear within  the data referenced
by a marker,  that's okay - treat  it like normal data,  not a marker,
and then resume looking for markers after the decompressed section.

For example:
- ADVENT contains no markers and decompresses to itself with no
  changes, resulting in a decompressed length of 6.
- A(1x5)BC repeats only the B a total of 5 times, becoming ABBBBBC for
  a decompressed length of 7.
- (3x3)XYZ becomes XYZXYZXYZ for a decompressed length of 9.
- A(2x2)BCD(2x2)EFG doubles the BC and EF, becoming ABCBCDEFEFG for a
  decompressed length of 11.
- (6x1)(1x3)A simply becomes (1x3)A - the (1x3) looks like a marker,
  but because it's within a data section of another marker, it is not
  treated any differently from the A that comes after it. It has a
  decompressed length of 6.
- X(8x2)(3x3)ABCY becomes X(3x3)ABC(3x3)ABCY (for a decompressed
  length of 18), because the decompressed data from the (8x2) marker
  (the (3x3)ABC) is skipped and not processed further.
  
What is the decompressed length of the file (your puzzle input)? Don't
count whitespace.

#+begin_src fennel -n :session d1609 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input
       ["ADVENT"
        "A(1x5)BC"
        "(3x3)XYZ"
        "A(2x2)BCD(2x2)EFG"
        "(6x1)(1x3)A"
        "X(8x2)(3x3)ABCY"])

(fn decompress [s ?b]
  (let [op (string.find s "(" (or ?b 1) true)
        cp (string.find s ")" (or ?b 1) true)]
    (if (or (not op) (not cp)) s
        (let [marker (string.sub s (+ 1 op) (- cp 1))
              [l t] (aoc.string-split marker "x")
              len (tonumber l)
              tim (tonumber t)
              ss (..
                  (string.sub s 1 (- op 1))
                  (string.rep (string.sub s (+ 1 cp) (+ cp len)) tim)
                  (string.sub s (+ 1 cp len)))]
          (decompress ss (+ (- op 1) (* len tim)))))))

(fn solve [input]
  (-> (. input 1)
      (decompress)
      (length)))

(fn test [expected input]
  (let [compressed (table.concat input "")]
    (assert (= expected (solve [compressed])))))

(test 57 test-input)

(solve (aoc.string-from "2016/09.inp"))
#+end_src

#+RESULTS:
: 70186

** DONE Day 9.2

Apparently, the file actually uses version two of the format.

In  version   two,  the  only   difference  is  that   markers  within
decompressed data are decompressed.  This, the documentation explains,
provides  much  more  substantial compression  capabilities,  allowing
many-gigabyte files to be stored in only a few kilobytes.

For example:
- (3x3)XYZ still becomes XYZXYZXYZ, as the decompressed section
  contains no markers.
- X(8x2)(3x3)ABCY becomes XABCABCABCABCABCABCY, because the
  decompressed data from the (8x2) marker is then further
  decompressed, thus triggering the (3x3) marker twice for a total of
  six ABC sequences.
- (27x12)(20x12)(13x14)(7x10)(1x12)A decompresses into a string of A
  repeated 241920 times.
- (25x3)(3x3)ABC(2x3)XY(5x2)PQRSTX(18x9)(3x2)TWO(5x7)SEVEN becomes 445
  characters long.
  
Unfortunately, the  computer you brought probably  doesn't have enough
memory to  actually decompress the file;  you'll have to come  up with
another way to get its decompressed length.

What  is the  decompressed  length  of the  file  using this  improved
format?

#+begin_src fennel -n :session d1609 :exports both
(fn decompress2 [s res]
  (let [op (string.find s "(" 1 true)
        cp (string.find s ")" 1 true)]
    (if (or (not op) (not cp)) (+ res (string.len s))
        (let [marker (string.sub s (+ 1 op) (- cp 1))
              [l t] (aoc.string-split marker "x")
              len (tonumber l)
              tim (tonumber t)
              nres (decompress2 (string.sub s (+ 1 cp) (+ cp len)) 0)
              ss (string.sub s (+ 1 cp len))]
          (decompress2 ss (+ res (- op 1) (* tim nres)))))))

(fn solve2 [input]
  (-> (. input 1)
      (decompress2 0)))

(fn test2 [expected input]
  (assert (= expected (solve2 [input] 0))))

(test2 9 "(3x3)XYZ")
(test2 20 "X(8x2)(3x3)ABCY")
(test2 241920 "(27x12)(20x12)(13x14)(7x10)(1x12)A")
(test2 445 "(25x3)(3x3)ABC(2x3)XY(5x2)PQRSTX(18x9)(3x2)TWO(5x7)SEVEN")

(solve2 (aoc.string-from "2016/09.inp") 0)
#+end_src

#+RESULTS:
: 10915059201

** TODO Day 10.1                                                  :noexport:

You  come upon  a  factory in  which many  robots  are zooming  around
handing small microchips to each other.

Upon closer examination,  you notice that each bot  only proceeds when
it  has two  microchips, and  once it  does, it  gives each  one to  a
different bot  or puts it  in a  marked "output" bin.  Sometimes, bots
take microchips from "input" bins, too.

Inspecting one  of the microchips, it  seems like they each  contain a
single number; the bots must use some  logic to decide what to do with
each  chip. You  access the  local control  computer and  download the
bots' instructions (your puzzle input).

Some  of the  instructions  specify that  a specific-valued  microchip
should  be given  to  a specific  bot; the  rest  of the  instructions
indicate  what  a  given  bot   should  do  with  its  lower-value  or
higher-value chip.

For example, consider the following instructions:
#+begin_example
value 5 goes to bot 2
bot 2 gives low to bot 1 and high to bot 0
value 3 goes to bot 1
bot 1 gives low to output 1 and high to bot 0
bot 0 gives low to output 2 and high to output 0
value 2 goes to bot 2
#+end_example

- Initially, bot 1 starts with a value-3 chip, and bot 2 starts with a
  value-2 chip and a value-5 chip.
- Because bot 2 has two microchips, it gives its lower one (2) to bot
  1 and its higher one (5) to bot 0.
- Then, bot 1 has two microchips; it puts the value-2 chip in output 1
  and gives the value-3 chip to bot 0.
- Finally, bot 0 has two microchips; it puts the 3 in output 2 and the
  5 in output 0.

In the  end, output bin 0  contains a value-5 microchip,  output bin 1
contains  a value-2  microchip, and  output bin  2 contains  a value-3
microchip.  In this  configuration, bot  number 2  is responsible  for
comparing value-5 microchips with value-2 microchips.

Based on  your instructions,  what is  the number of  the bot  that is
responsible   for   comparing   value-61  microchips   with   value-17
microchips?
** TODO Day 10.2                                                  :noexport:

** TODO Day 11.1                                                  :noexport:

You come upon  a column of four floors that  have been entirely sealed
off  from the  rest  of  the building  except  for  a small  dedicated
lobby. There  are some radiation warnings  and a big sign  which reads
"Radioisotope Testing Facility".

According  to the  project status  board, this  facility is  currently
being used  to experiment with Radioisotope  Thermoelectric Generators
(RTGs, or  simply "generators")  that are designed  to be  paired with
specially-constructed  microchips.  Basically,  an  RTG  is  a  highly
radioactive rock that generates electricity through heat.

The  experimental RTGs  have  poor radiation  containment, so  they're
dangerously  radioactive.  The chips  are  prototypes  and don't  have
normal radiation shielding,  but they do have the  ability to generate
an electromagnetic radiation shield  when powered. Unfortunately, they
can only  be powered  by their  corresponding RTG.  An RTG  powering a
microchip is still dangerous to other microchips.

In other  words, if a chip  is ever left  in the same area  as another
RTG,  and  it's  not connected  to  its  own  RTG,  the chip  will  be
fried. Therefore,  it is  assumed that you  will follow  procedure and
keep chips  connected to their  corresponding RTG when they're  in the
same room, and away from other RTGs otherwise.

These microchips  sound very  interesting and  useful to  your current
activities, and you'd  like to try to retrieve them.  The fourth floor
of  the  facility   has  an  assembling  machine  which   can  make  a
self-contained, shielded computer for you to  take with you - that is,
if you can bring it all of the RTGs and microchips.

Within the radiation-shielded part of the facility (in which it's safe
to have these  pre-assembly RTGs), there is an elevator  that can move
between the  four floors. Its  capacity rating  means it can  carry at
most yourself and two RTGs  or microchips in any combination. (They're
rigged to  some heavy  diagnostic equipment  - the  assembling machine
will detach it for you.) As a security measure, the elevator will only
function if  it contains at least  one RTG or microchip.  The elevator
always stops  on each floor  to recharge,  and this takes  long enough
that the  items within it  and the items  on that floor  can irradiate
each other. (You can prevent this if a Microchip and its Generator end
up on the same  floor in this way, as they can  be connected while the
elevator is recharging.)

You make  some notes of  the locations  of each component  of interest
(your puzzle  input). Before you  don a  hazmat suit and  start moving
things around, you'd like to have an idea of what you need to do.

When you enter  the containment area, you and the  elevator will start
on the first floor.

For example, suppose the isolated area has the following arrangement:
- The first floor contains a hydrogen-compatible microchip and a
  lithium-compatible microchip.
- The second floor contains a hydrogen generator.
- The third floor contains a lithium generator.
- The fourth floor contains nothing relevant.

As a diagram (F# for a Floor number, E for Elevator, H for Hydrogen, L
for Lithium, M for Microchip, and  G for Generator), the initial state
looks like this:

#+begin_example
F4 .  .  .  .  .  
F3 .  .  .  LG .  
F2 .  HG .  .  .  
F1 E  .  HM .  LM 
#+end_example

Then, to  get everything up  to the  assembling machine on  the fourth
floor, the following steps could be taken:

Bring the Hydrogen-compatible Microchip to  the second floor, which is
safe because it can get power from the Hydrogen Generator:
#+begin_example
    F4 .  .  .  .  .  
    F3 .  .  .  LG .  
    F2 E  HG HM .  .  
    F1 .  .  .  .  LM 
#+end_example

Bring both  Hydrogen-related items to  the third floor, which  is safe
because the  Hydrogen-compatible microchip  is getting power  from its
generator:
#+begin_example
    F4 .  .  .  .  .  
    F3 E  HG HM LG .  
    F2 .  .  .  .  .  
    F1 .  .  .  .  LM 
#+end_example

Leave  the   Hydrogen  Generator  on   floor  three,  but   bring  the
Hydrogen-compatible Microchip back down with  you so you can still use
the elevator:
#+begin_example
    F4 .  .  .  .  .  
    F3 .  HG .  LG .  
    F2 E  .  HM .  .  
    F1 .  .  .  .  LM 
#+end_example

At the  first floor, grab  the Lithium-compatible Microchip,  which is
safe because Microchips don't affect each other:
#+begin_example
    F4 .  .  .  .  .  
    F3 .  HG .  LG .  
    F2 .  .  .  .  .  
    F1 E  .  HM .  LM 
#+end_example

Bring both  Microchips up  one floor,  where there  is nothing  to fry
them:
#+begin_example
    F4 .  .  .  .  .  
    F3 .  HG .  LG .  
    F2 E  .  HM .  LM 
    F1 .  .  .  .  .  
#+end_example

Bring  both Microchips  up again  to floor  three, where  they can  be
temporarily  connected to  their  corresponding  generators while  the
elevator recharges, preventing either of them from being fried:
#+begin_example
    F4 .  .  .  .  .  
    F3 E  HG HM LG LM 
    F2 .  .  .  .  .  
    F1 .  .  .  .  .  
#+end_example

Bring both Microchips to the fourth floor:
#+begin_example
    F4 E  .  HM .  LM 
    F3 .  HG .  LG .  
    F2 .  .  .  .  .  
    F1 .  .  .  .  .  
#+end_example

Leave the Lithium-compatible microchip on  the fourth floor, but bring
the Hydrogen-compatible one so you can still use the elevator; this is
safe  because although  the Lithium  Generator is  on the  destination
floor, you  can connect Hydrogen-compatible microchip  to the Hydrogen
Generator there:
#+begin_example
    F4 .  .  .  .  LM 
    F3 E  HG HM LG .  
    F2 .  .  .  .  .  
    F1 .  .  .  .  .  
#+end_example

Bring both  Generators up to the  fourth floor, which is  safe because
you  can  connect  the  Lithium-compatible Microchip  to  the  Lithium
Generator upon arrival:
#+begin_example
    F4 E  HG .  LG LM 
    F3 .  .  HM .  .  
    F2 .  .  .  .  .  
    F1 .  .  .  .  .  
#+end_example

Bring the Lithium Microchip with you to the third floor so you can use
the elevator:
#+begin_example
    F4 .  HG .  LG .  
    F3 E  .  HM .  LM 
    F2 .  .  .  .  .  
    F1 .  .  .  .  .  
#+end_example

Bring both Microchips to the fourth floor:
#+begin_example
    F4 E  HG HM LG LM 
    F3 .  .  .  .  .  
    F2 .  .  .  .  .  
    F1 .  .  .  .  .  
#+end_example

In this arrangement,  it takes 11 steps to collect  all of the objects
at the  fourth floor for assembly.  (Each elevator stop counts  as one
step, even if nothing is added to or removed from it.)

In your  situation, what is  the minimum  number of steps  required to
bring all of the objects to the fourth floor?
** TODO Day 11.2                                                  :noexport:

** TODO Day 12.1                                                  :noexport:

You finally  reach the  top floor  of this building:  a garden  with a
slanted glass ceiling. Looks like there are no more stars to be had.

While sitting on  a nearby bench amidst some tiger  lilies, you manage
to  decrypt  some  of  the   files  you  extracted  from  the  servers
downstairs.

According  to  these  documents,  Easter  Bunny  HQ  isn't  just  this
building - it's a collection of  buildings in the nearby area. They're
all connected  by a local  monorail, and there's another  building not
far from here!  Unfortunately, being night, the  monorail is currently
not operating.

You remotely connect to the monorail control systems and discover that
the  boot sequence  expects  a password.  The password-checking  logic
(your  puzzle input)  is easy  to  extract, but  the code  it uses  is
strange: it's assembunny  code designed for the new  computer you just
assembled. You'll have to execute the code and get the password.

The assembunny code you've extracted operates on four registers (a, b,
c, and d) that start at 0  and can hold any integer. However, it seems
to make use of only a few instructions:
- cpy x y copies x (either an integer or the value of a register) into
  register y.
- inc x increases the value of register x by one.
- dec x decreases the value of register x by one.
- jnz x y jumps to an instruction y away (positive means forward;
  negative means backward), but only if x is not zero.
  
The jnz  instruction moves relative to  itself: an offset of  -1 would
continue at the previous instruction, while  an offset of 2 would skip
over the next instruction.

For example:
#+begin_example
cpy 41 a
inc a
inc a
dec a
jnz a 2
dec a
#+end_example

The above code  would set register a  to 41, increase its  value by 2,
decrease its value  by 1, and then  skip the last dec a  (because a is
not zero, so the jnz a 2 skips it), leaving register a at 42. When you
move past the last instruction, the program halts.

After executing the  assembunny code in your puzzle  input, what value
is left in register a?
** TODO Day 12.2                                                  :noexport:

** TODO Day 13.1                                                  :noexport:

You arrive at the first floor of  this new building to discover a much
less  welcoming  environment  than  the   shiny  atrium  of  the  last
one. Instead, you are in a maze of twisty little cubicles, all alike.

Every location  in this area  is addressed  by a pair  of non-negative
integers  (x,y). Each  such coordinate  is either  a wall  or an  open
space. You  can't move  diagonally. The  cube maze  starts at  0,0 and
seems to  extend infinitely toward  positive x and y;  negative values
are invalid,  as they represent  a location outside the  building. You
are in a small waiting area at 1,1.

While it seems chaotic, a  nearby morale-boosting poster explains, the
layout is  actually quite logical.  You can determine whether  a given
x,y coordinate will be a wall or an open space using a simple system:
#+begin_example
    Find x*x + 3*x + 2*x*y + y + y*y.
    Add the office designer's favorite number (your puzzle input).
    Find the binary representation of that sum; count the number of bits that are 1.
        If the number of bits that are 1 is even, it's an open space.
        If the number of bits that are 1 is odd, it's a wall.
#+end_example

For example, if the office designer's favorite number were 10, drawing
walls as # and open spaces as ., the corner of the building containing
0,0 would look like this:
#+begin_example
  0123456789
0 .#.####.##
1 ..#..#...#
2 #....##...
3 ###.#.###.
4 .##..#..#.
5 ..##....#.
6 #...##.###
#+end_example

Now, suppose  you wanted to  reach 7,4.  The shortest route  you could
take is marked as O:
#+begin_example
  0123456789
0 .#.####.##
1 .O#..#...#
2 #OOO.##...
3 ###O#.###.
4 .##OO#OO#.
5 ..##OOO.#.
6 #...##.###
#+end_example

Thus, reaching  7,4 would take  a minimum  of 11 steps  (starting from
your current location, 1,1).

What is the fewest number of steps required for you to reach 31,39?
** TODO Day 13.2                                                  :noexport:

** TODO Day 14.1                                                  :noexport:

In  order to  communicate securely  with  Santa while  you're on  this
mission, you've  been using a one-time  pad that you generate  using a
pre-agreed algorithm.  Unfortunately, you've run  out of keys  in your
one-time pad, and so you need to generate some more.

To generate keys, you first get a  stream of random data by taking the
MD5  of a  pre-arranged salt  (your  puzzle input)  and an  increasing
integer  index (starting  with  0, and  represented  in decimal);  the
resulting  MD5 hash  should be  represented as  a string  of lowercase
hexadecimal digits.

However, not  all of these  MD5 hashes are keys,  and you need  64 new
keys for your one-time pad. A hash is a key only if:
- It contains three of the same character in a row, like 777. Only
  consider the first such triplet in a hash.
- One of the next 1000 hashes in the stream contains that same
  character five times in a row, like 77777.
  
Considering future hashes for  five-of-a-kind sequences does not cause
those hashes to be skipped; instead, regardless of whether the current
hash is a  key, always resume testing for keys  starting with the very
next hash.

For example, if the pre-arranged salt is abc:
- The first index which produces a triple is 18, because the MD5 hash
  of abc18 contains ...cc38887a5.... However, index 18 does not count
  as a key for your one-time pad, because none of the next thousand
  hashes (index 19 through index 1018) contain 88888.
- The next index which produces a triple is 39; the hash of abc39
  contains eee. It is also the first key: one of the next thousand
  hashes (the one at index 816) contains eeeee.
- None of the next six triples are keys, but the one after that, at
  index 92, is: it contains 999 and index 200 contains 99999.
- Eventually, index 22728 meets all of the criteria to generate the 64th key.

So, using our example salt of abc, index 22728 produces the 64th key.

Given the actual  salt in your puzzle input, what  index produces your
64th one-time pad key?
** TODO Day 14.2                                                  :noexport:

** TODO Day 15.1                                                  :noexport:

The  halls open  into an  interior  plaza containing  a large  kinetic
sculpture. The sculpture is in a sealed enclosure and seems to involve
a set of identical spherical capsules  that are carried to the top and
allowed to bounce through the maze of spinning pieces.

Part of the sculpture is even interactive! When a button is pressed, a
capsule  is dropped  and  tries to  fall  through slots  in  a set  of
rotating discs to  finally go through a little hole  at the bottom and
come out of the sculpture. If any of the slots aren't aligned with the
capsule  as it  passes, the  capsule bounces  off the  disc and  soars
away. You feel compelled to get one of those capsules.

The discs pause their motion each  second and come in different sizes;
they  seem to  each have  a fixed  number of  positions at  which they
stop. You decide  to call the position  with the slot 0,  and count up
for each position it reaches next.

Furthermore,  the discs  are spaced  out so  that after  you push  the
button, one second  elapses before the first disc is  reached, and one
second elapses  as the capsule passes  from one disc to  the one below
it. So, if  you push the button at time=100,  then the capsule reaches
the top disc at time=101, the  second disc at time=102, the third disc
at time=103, and so on.

The button will only drop a capsule at an integer time - no fractional
seconds allowed.

For example, at time=0, suppose you see the following arrangement:
#+begin_example
Disc #1 has 5 positions; at time=0, it is at position 4.
Disc #2 has 2 positions; at time=0, it is at position 1.
#+end_example

If you press the button exactly  at time=0, the capsule would start to
fall; it  would reach the first  disc at time=1. Since  the first disc
was at  position 4  at time=0,  by time=1 it  has ticked  one position
forward. As  a five-position  disc, the  next position  is 0,  and the
capsule falls through the slot.

Then, at time=2, the capsule reaches  the second disc. The second disc
has ticked forward two positions at this point: it started at position
1, then  continued to position 0,  and finally ended up  at position 1
again. Because there's only a slot  at position 0, the capsule bounces
away.

If, however, you  wait until time=5 to push the  button, then when the
capsule reaches each disc, the first disc will have ticked forward 5+1
=  6 times  (to position  0),  and the  second disc  will have  ticked
forward 5+2 = 7 times (also to  position 0). In this case, the capsule
would fall through the discs and come out of the machine.

However, your  situation has more  than two discs; you've  noted their
positions in your  puzzle input. What is the first  time you can press
the button to get a capsule?
** TODO Day 15.2                                                  :noexport:

** TODO Day 16.1                                                  :noexport:

You're done scanning this part of  the network, but you've left traces
of your presence. You need to overwrite some disks with random-looking
data to cover your tracks and  update the local security system with a
new checksum for those disks.

For  the  data  to  not  be  suspicious,  it  needs  to  have  certain
properties;  purely random  data  will be  detected  as tampering.  To
generate appropriate random data, you'll need to use a modified dragon
curve.

Start with an appropriate initial  state (your puzzle input). Then, so
long as you  don't have enough data  yet to fill the  disk, repeat the
following steps:
- Call the data you have at this point "a".
- Make a copy of "a"; call this copy "b".
- Reverse the order of the characters in "b".
- In "b", replace all instances of 0 with 1 and all 1s with 0.
- The resulting data is "a", then a single 0, then "b".

For example, after a single step of this process,
- 1 becomes 100.
- 0 becomes 001.
- 11111 becomes 11111000000.
- 111100001010 becomes 1111000010100101011110000.

Repeat these steps until you have enough data to fill the desired disk.

Once the data  has been generated, you also need  to create a checksum
of that  data. Calculate the checksum  only for the data  that fits on
the disk,  even if you generated  more data than that  in the previous
step.

The  checksum for  some  given  data is  created  by considering  each
non-overlapping  pair of  characters in  the  input data.  If the  two
characters match  (00 or 11), the  next checksum character is  a 1. If
the characters do not match (01 or 10), the next checksum character is
a 0. This should produce a new string which is exactly half as long as
the  original. If  the  length of  the checksum  is  even, repeat  the
process until you end up with a checksum with an odd length.

For example, suppose we want to fill  a disk of length 12, and when we
finally  generate  a string  of  at  least  length  12, the  first  12
characters are 110010110100. To generate its checksum:
- Consider each pair: 11, 00, 10, 11, 01, 00.
- These are same, same, different, same, different, same,
  producing 110101.
- The resulting string has length 6, which is even, so we repeat the
  process.
- The pairs are 11 (same), 01 (different), 01 (different).
- This produces the checksum 100, which has an odd length, so we stop.

Therefore, the checksum for 110010110100 is 100.

Combining all of these steps together, suppose you want to fill a disk
of length 20 using an initial state of 10000:
- Because 10000 is too short, we first use the modified dragon curve
  to make it longer.
- After one round, it becomes 10000011110 (11 characters), still too
  short.
- After two rounds, it becomes 10000011110010000111110 (23
  characters), which is enough.
- Since we only need 20, but we have 23, we get rid of all but the
  first 20 characters: 10000011110010000111.
- Next, we start calculating the checksum; after one round, we have
  0111110101, which 10 characters long (even), so we continue.  
- After two rounds, we have 01100, which is 5 characters long (odd),
  so we are done.

In this example, the correct checksum would therefore be 01100.

The first  disk you  have to  fill has length  272. Using  the initial
state in your puzzle input, what is the correct checksum?
** TODO Day 16.2                                                  :noexport:

** TODO Day 17.1                                                  :noexport:

You're trying  to access  a secure  vault protected by  a 4x4  grid of
small rooms connected by doors. You start in the top-left room (marked
S),  and you  can  access the  vault  (marked V)  once  you reach  the
bottom-right room:
#+begin_example
#########
#S| | | #
#-#-#-#-#
# | | | #
#-#-#-#-#
# | | | #
#-#-#-#-#
# | | |  
####### V
#+end_example

Fixed walls are marked with #, and doors are marked with - or |.

The doors in your current room  are either open or closed (and locked)
based on  the hexadecimal MD5 hash  of a passcode (your  puzzle input)
followed by a  sequence of uppercase characters  representing the path
you have  taken so far (U  for up, D for  down, L for left,  and R for
right).

Only the first  four characters of the hash are  used; they represent,
respectively, the  doors up, down,  left, and right from  your current
position. Any b,  c, d, e, or  f means that the  corresponding door is
open;  any  other   character  (any  number  or  a)   means  that  the
corresponding door is closed and locked.

To access  the vault,  all you  need to do  is reach  the bottom-right
room; reaching this room opens the vault and all doors in the maze.

For example, suppose the passcode  is hijkl. Initially, you have taken
no steps, and so  your path is empty: you simply find  the MD5 hash of
hijkl alone.  The first four characters  of this hash are  ced9, which
indicate that up is open (c), down  is open (e), left is open (d), and
right is  closed and  locked (9).  Because you  start in  the top-left
corner, there  are no "up"  or "left" doors to  be open, so  your only
choice is down.

Next, having  gone only one  step (down, or D),  you find the  hash of
hijklD. This produces  f2bc, which indicates that you can  go back up,
left (but that's a wall), or  right. Going right means hashing hijklDR
to get 5745  - all doors closed and locked.  However, going up instead
is worthwhile: even though it returns  you to the room you started in,
your path would then be DU, opening a different set of doors.

After going DU (and then hashing  hijklDU to get 528e), only the right
door  is open;  after going  DUR, all  doors lock.  (Fortunately, your
actual passcode is not hijkl).

Passcodes actually used by Easter Bunny Vault Security do allow access
to the vault if you know the right path. For example:
- If your passcode were ihgpwlah, the shortest path would be DDRRRD.
- With kglvqrro, the shortest path would be DDUDRLRRUDRD.
- With ulqzkmiv, the shortest would be DRURDRUDDLLDLUURRDULRLDUUDDDRR.
  
Given your  vault's passcode,  what is the  shortest path  (the actual
path, not just the length) to reach the vault?
** TODO Day 17.2                                                  :noexport:

** TODO Day 18.1                                                  :noexport:

As you enter  this room, you hear  a loud click! Some of  the tiles in
the floor here seem to be pressure  plates for traps, and the trap you
just triggered has run  out of... whatever it tried to  do to you. You
doubt you'll be so lucky next time.

Upon closer examination, the traps and safe tiles in this room seem to
follow a  pattern. The tiles are  arranged into rows that  are all the
same width; you take  note of the safe tiles (.) and  traps (^) in the
first row (your puzzle input).

The type of tile  (trapped or safe) in each row is  based on the types
of  the  tiles in  the  same  position, and  to  either  side of  that
position, in  the previous row. (If  either side is off  either end of
the row,  it counts as "safe"  because there isn't a  trap embedded in
the wall.)

For example,  suppose you  know the  first row  (with tiles  marked by
letters) and  want to  determine the  next row  (with tiles  marked by
numbers):
#+begin_example
ABCDE
12345
#+end_example

The type  of tile 2 is  based on the types  of tiles A, B,  and C; the
type  of tile  5 is  based  on tiles  D,  E, and  an imaginary  "safe"
tile. Let's  call these three  tiles from  the previous row  the left,
center, and right tiles, respectively. Then, a new tile is a trap only
in one of the following situations:
- Its left and center tiles are traps, but its right tile is not.
- Its center and right tiles are traps, but its left tile is not.
- Only its left tile is a trap.
- Only its right tile is a trap.

In any other situation, the new tile is safe.

Then, starting with  the row ..^^., you can determine  the next row by
applying those rules to each new tile:
- The leftmost character on the next row considers the left
  (nonexistent, so we assume "safe"), center (the first ., which means
  "safe"), and right (the second ., also "safe") tiles on the previous
  row. Because all of the trap rules require a trap in at least one of
  the previous three tiles, the first tile on this new row is also
  safe, ..
- The second character on the next row considers its left (.), center
  (.), and right (^) tiles from the previous row. This matches the
  fourth rule: only the right tile is a trap. Therefore, the next tile
  in this new row is a trap, ^.
- The third character considers .^^, which matches the second trap
  rule: its center and right tiles are traps, but its left tile is
  not. Therefore, this tile is also a trap, ^.
- The last two characters in this new row match the first and third
  rules, respectively, and so they are both also traps, ^.
  
After these  steps, we  now know the  next row of  tiles in  the room:
.^^^^. Then, we continue on to the next row, using the same rules, and
get ^^..^. After determining two new rows, our map looks like this:
#+begin_example
..^^.
.^^^^
^^..^
#+end_example

Here's a larger example with ten tiles per row and ten rows:
#+begin_example
.^^.^.^^^^
^^^...^..^
^.^^.^.^^.
..^^...^^^
.^^^^.^^.^
^^..^.^^..
^^^^..^^^.
^..^^^^.^^
.^^^..^.^^
^^.^^^..^^
#+end_example

In ten rows, this larger example has 38 safe tiles.

Starting with  the map  in your puzzle  input, in a  total of  40 rows
(including the starting row), how many safe tiles are there?
** TODO Day 18.2                                                  :noexport:

** TODO Day 19.1                                                  :noexport:

The Elves contact you over a  highly secure emergency channel. Back at
the North  Pole, the  Elves are  busy misunderstanding  White Elephant
parties.

Each Elf brings a present. They all sit in a circle, numbered starting
with position  1. Then, starting with  the first Elf, they  take turns
stealing all the presents  from the Elf to their left.  An Elf with no
presents is removed from the circle and does not take turns.

For example, with five Elves (numbered 1 to 5):
#+begin_example
  1
5   2
 4 3
#+end_example

- Elf 1 takes Elf 2's present.
- Elf 2 has no presents and is skipped.
- Elf 3 takes Elf 4's present.
- Elf 4 has no presents and is also skipped.
- Elf 5 takes Elf 1's two presents.
- Neither Elf 1 nor Elf 2 have any presents, so both are skipped.
- Elf 3 takes Elf 5's three presents.

So, with five Elves, the Elf that sits starting in position 3 gets all
the presents.

With the  number of Elves given  in your puzzle input,  which Elf gets
all the presents?
** TODO Day 19.2                                                  :noexport:

** TODO Day 20.1                                                  :noexport:

You'd like to set up a small hidden computer here so you can use it to
get back into the network  later. However, the corporate firewall only
allows communication with certain external IP addresses.

You've retrieved  the list of blocked  IPs from the firewall,  but the
list seems to be messy and poorly maintained, and it's not clear which
IPs  are  allowed. Also,  rather  than  being written  in  dot-decimal
notation, they  are written as  plain 32-bit integers, which  can have
any value from 0 through 4294967295, inclusive.

For example, suppose only the values  0 through 9 were valid, and that
you retrieved the following blacklist:
#+begin_example
5-8
0-2
4-7
#+end_example

The blacklist specifies ranges of IPs (inclusive of both the start and
end value) that are not allowed. Then, the only IPs that this firewall
allows are 3 and 9, since those are the only numbers not in any range.

Given the  list of blocked IPs  you retrieved from the  firewall (your
puzzle input), what is the lowest-valued IP that is not blocked?
** TODO Day 20.2                                                  :noexport:

** TODO Day 21.1                                                  :noexport:

The  computer system  you're  breaking into  uses  a weird  scrambling
function  to store  its passwords.  It  shouldn't be  much trouble  to
create your  own scrambled password so  you can add it  to the system;
you just have to implement the scrambler.

The scrambling function  is a series of operations (the  exact list is
provided  in your  puzzle input).  Starting  with the  password to  be
scrambled,  apply each  operation  in succession  to  the string.  The
individual operations behave as follows:
- swap position X with position Y means that the letters at indexes X
  and Y (counting from 0) should be swapped.
- swap letter X with letter Y means that the letters X and Y should be
  swapped (regardless of where they appear in the string).
- rotate left/right X steps means that the whole string should be
  rotated; for example, one right rotation would turn abcd into dabc.
- rotate based on position of letter X means that the whole string
  should be rotated to the right based on the index of letter X
  (counting from 0) as determined before this instruction does any
  rotations. Once the index is determined, rotate the string to the
  right one time, plus a number of times equal to that index, plus one
  additional time if the index was at least 4.
- reverse positions X through Y means that the span of letters at
  indexes X through Y (including the letters at X and Y) should be
  reversed in order.
- move position X to position Y means that the letter which is at
  index X should be removed from the string, then inserted such that
  it ends up at index Y.
  
For example, suppose you start with abcde and perform the following
operations:
- swap position 4 with position 0 swaps the first and last letters,
  producing the input for the next step, ebcda.
- swap letter d with letter b swaps the positions of d and b: edcba.
- reverse positions 0 through 4 causes the entire string to be
  reversed, producing abcde.
- rotate left 1 step shifts all letters left one position, causing the
  first letter to wrap to the end of the string: bcdea.
- move position 1 to position 4 removes the letter at position 1 (c),
  then inserts it at position 4 (the end of the string): bdeac.
- move position 3 to position 0 removes the letter at position 3 (a),
  then inserts it at position 0 (the front of the string): abdec.
- rotate based on position of letter b finds the index of letter b
  (1), then rotates the string right once plus a number of times equal
  to that index (2): ecabd.
- rotate based on position of letter d finds the index of letter d
  (4), then rotates the string right once, plus a number of times
  equal to that index, plus an additional time because the index was
  at least 4, for a total of 6 right rotations: decab.
  
After these steps, the resulting scrambled password is decab.

Now, you  just need to generate  a new scrambled password  and you can
access the  system. Given  the list of  scrambling operations  in your
puzzle input, what is the result of scrambling abcdefgh?
** TODO Day 21.2                                                  :noexport:

** TODO Day 22.1                                                  :noexport:

You gain access to a massive  storage cluster arranged in a grid; each
storage node is only connected to  the four nodes directly adjacent to
it (three if the node is on an edge, two if it's in a corner).

You can  directly access data  only on node  /dev/grid/node-x0-y0, but
you can perform some limited actions on the other nodes:
- You can get the disk usage of all nodes (via df). The result of
  doing this is in your puzzle input.
- You can instruct a node to move (not copy) all of its data to an
  adjacent node (if the destination node has enough space to receive
  the data). The sending node is left empty after this operation.
  
Nodes are named by their position: the node named node-x10-y10 is
adjacent to nodes node-x9-y10, node-x11-y10, node-x10-y9, and
node-x10-y11.

Before you  begin, you need to  understand the arrangement of  data on
these  nodes. Even  though you  can  only move  data between  directly
connected nodes, you're  going to need to rearrange a  lot of the data
to get access  to the data you  need. Therefore, you need  to work out
how you might be able to shift data around.

To do this, you'd like to count the number of viable pairs of nodes. A
viable pair is any two nodes (A,B), regardless of whether they are
directly connected, such that:
- Node A is not empty (its Used is not zero).
- Nodes A and B are not the same node.
- The data on node A (its Used) would fit on node B (its Avail).  

How many viable pairs of nodes are there?
** TODO Day 22.2                                                  :noexport:

** TODO Day 23.1                                                  :noexport:

This is one of the top floors  of the nicest tower in EBHQ. The Easter
Bunny's private office  is here, complete with a safe  hidden behind a
painting, and who wouldn't hide a star in a safe behind a painting?

The safe has a digital screen and keypad for code entry. A sticky note
attached to the  safe has a password hint on  it: "eggs". The painting
is of a large rabbit coloring some eggs. You see 7.

When you go to type the  code, though, nothing appears on the display;
instead, the keypad comes apart  in your hands, apparently having been
smashed.  Behind it  is  some kind  of  socket -  one  that matches  a
connector  in your  prototype  computer! You  pull  apart the  smashed
keypad and extract the logic circuit,  plug it into your computer, and
plug your computer into the safe.

Now, you  just need to  figure out what  output the keypad  would have
sent to the safe. You extract  the assembunny code from the logic chip
(your puzzle input).

The  code  looks  like  it  uses  almost  the  same  architecture  and
instruction set that the monorail computer used! You should be able to
use the  same assembunny interpreter  for this  as you did  there, but
with one new instruction:

tgl x  toggles the instruction  x away (pointing at  instructions like
jnz does: positive means forward; negative means backward):
- For one-argument instructions, inc becomes dec, and all other
  one-argument instructions become inc.
- For two-argument instructions, jnz becomes cpy, and all other
  two-instructions become jnz.
- The arguments of a toggled instruction are not affected.
- If an attempt is made to toggle an instruction outside the program,
  nothing happens.
- If toggling produces an invalid instruction (like cpy 1 2) and an
  attempt is later made to execute that instruction, skip it instead.
- If tgl toggles itself (for example, if a is 0, tgl a would target
  itself and become inc a), the resulting instruction is not executed
  until the next time it is reached.
  
For example, given this program:
#+begin_example
cpy 2 a
tgl a
tgl a
tgl a
cpy 1 a
dec a
dec a
#+end_example

- cpy 2 a initializes register a to 2.
- The first tgl a toggles an instruction a (2) away from it, which
  changes the third tgl a into inc a.
- The second tgl a also modifies an instruction 2 away from it, which
  changes the cpy 1 a into jnz 1 a.
- The fourth line, which is now inc a, increments a to 3.
- Finally, the fifth line, which is now jnz 1 a, jumps a (3)
  instructions ahead, skipping the dec a instructions.
  
In this example, the final value in register a is 3.

The rest of the electronics seem to place the keypad entry (the number
of eggs, 7) in register a, run  the code, and then send the value left
in register a to the safe.

What value should be sent to the safe?
** TODO Day 23.2                                                  :noexport:

** TODO Day 24.1                                                  :noexport:

You've finally  met your match; the  doors that provide access  to the
roof are locked tight, and all of the controls and related electronics
are inaccessible. You simply can't reach them.

The robot that cleans the air ducts, however, can.

It's not a very  fast little robot, but you reconfigure  it to be able
to interface  with some  of the  exposed wires  that have  been routed
through  the HVAC  system.  If you  can  direct it  to  each of  those
locations, you should be able to bypass the security controls.

You extract  the duct layout  for this  area from some  blueprints you
acquired and  create a  map with the  relevant locations  marked (your
puzzle input).  0 is  your current location,  from which  the cleaning
robot  embarks; the  other numbers  are (in  no particular  order) the
locations  the robot  needs to  visit at  least once  each. Walls  are
marked as  #, and open passages  are marked as ..  Numbers behave like
open passages.

For example, suppose you have a map like the following:
#+begin_example
###########
#0.1.....2#
#.#######.#
#4.......3#
###########
#+end_example

To reach  all of the  points of interest  as quickly as  possible, you
would have the robot take the following path:
- 0 to 4 (2 steps)
- 4 to 1 (4 steps; it can't move diagonally)
- 1 to 2 (6 steps)
- 2 to 3 (2 steps)

Since the  robot isn't  very fast,  you need to  find it  the shortest
route. This  path is the fewest  steps (in the above  example, a total
of 14) required to  start at 0 and then visit  every other location at
least once.

Given  your actual  map, and  starting from  location 0,  what is  the
fewest number of steps required to  visit every non-0 number marked on
the map at least once?
** TODO Day 24.2                                                  :noexport:

** TODO Day 25.1                                                  :noexport:

You open the door and find yourself on the roof. The city sprawls away
from you for miles and miles.

There's not much time now - it's already Christmas, but you're nowhere
near the North Pole, much too far to deliver these stars to the sleigh
in time.

However, maybe  the huge antenna up  here can offer a  solution. After
all, the sleigh  doesn't need the stars, exactly; it  needs the timing
data they provide,  and you happen to have a  massive signal generator
right here.

You connect  the stars  you have to  your prototype  computer, connect
that to the antenna, and begin the transmission.

Nothing happens.

You call  the service number  printed on the  side of the  antenna and
quickly explain  the situation. "I'm  not sure what kind  of equipment
you  have connected  over  there,"  he says,  "but  you  need a  clock
signal." You try to explain that this is a signal for a clock.

"No, no, a  clock signal - timing information so  the antenna computer
knows how to read the data  you're sending it. An endless, alternating
pattern of 0, 1, 0, 1, 0, 1, 0, 1, 0, 1...." He trails off.

You ask if the antenna can handle  a clock signal at the frequency you
would need to use for the data from the stars. "There's no way it can!
The  only antenna  we've installed  capable  of that  is on  top of  a
top-secret Easter Bunny installation,  and you're definitely not-" You
hang up the phone.

You've extracted the antenna's clock signal generation assembunny code
(your puzzle input);  it looks mostly compatible with  code you worked
on just recently.

This  antenna  code,   being  a  signal  generator,   uses  one  extra
instruction:
- out x transmits x (either an integer or the value of a register) as
  the next value for the clock signal.
  
The code takes  a value (via register a) that  describes the signal to
generate, but you're  not sure how it's used. You'll  have to find the
input to produce the right signal through experimentation.

What is  the lowest positive  integer that  can be used  to initialize
register a  and cause the code  to output a  clock signal of 0,  1, 0,
1... repeating forever?
** TODO Day 25.2                                                  :noexport:
** Stats                                                          :noexport:

#+CAPTION: https://adventofcode.com/2016/stats
| 25 |  7 | ▉▉▉▉▉▉▉                                   |
| 24 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 23 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 22 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
| 21 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
| 20 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
| 19 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
| 18 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
| 17 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
| 16 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
| 15 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
| 14 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
| 13 | 11 | ▉▉▉▉▉▉▉▉▉▉▉                               |
| 12 | 13 | ▉▉▉▉▉▉▉▉▉▉▉▉▉                             |
| 11 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
| 10 | 14 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉                            |
|  9 | 17 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                         |
|  8 | 18 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                        |
|  7 | 20 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                      |
|  6 | 23 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                   |
|  5 | 22 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                    |
|  4 | 25 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                 |
|  3 | 31 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉           |
|  2 | 32 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉          |
|  1 | 41 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ |
#+TBLFM: $3='(orgtbl-uc-draw-grid $2 0 41 41)


* 2015 [44/50]
** DONE Day 1.1

Santa  was hoping  for a  white Christmas,  but his  weather machine's
"snow"  function is  powered by  stars, and  he's fresh  out! To  save
Christmas, he needs you to collect fifty stars by December 25th.

Collect stars by helping Santa solve puzzles. Two puzzles will be made
available on  each day in  the Advent  calendar; the second  puzzle is
unlocked  when  you  complete  the  first.   Each  puzzle  grants  one
star. Good luck!

Here's an easy puzzle to warm you up.

Santa is trying to deliver presents in a large apartment building, but
he can't  find the right  floor - the directions  he got are  a little
confusing. He  starts on the ground  floor (floor 0) and  then follows
the instructions one character at a time.

An opening  parenthesis, (,  means he  should go up  one floor,  and a
closing parenthesis, ), means he should go down one floor.

The apartment building is very tall, and the basement is very deep; he
will never find the top or bottom floors.

For example:
- (()) and ()() both result in floor 0.
- ((( and (()(()( both result in floor 3.
- ))((((( also results in floor 3.
- ()) and ))( both result in floor -1 (the first basement level).
- ))) and )())()) both result in floor -3.

To what floor do the instructions take Santa?

#+begin_src fennel -n :session d1501 :exports both
(local aoc (require :lib.aoc))

(fn solve [input]
  (var res 0)
  (let [xs (aoc.string-toarray (. input 1))]
    (each [_ x (ipairs xs)]
      (if (= ")" x)
          (set res (- res 1))
          (set res (+ 1 res)))))
  res)

(solve (aoc.string-from "2015/01.inp"))
#+end_src

#+RESULTS:
: 74

** DONE Day 1.2

Now,  given the  same instructions,  find  the position  of the  first
character that causes him to enter  the basement (floor -1). The first
character in the instructions has position 1, the second character has
position 2, and so on.

For example:
- ) causes him to enter the basement at character position 1.
- ()()) causes him to enter the basement at character position 5.

What is the position of the character that causes Santa to first enter
the basement?

#+begin_src fennel -n :session d1501 :exports both
(fn solve2 [input]
  (var res 0)
  (var done false)
  (let [xs (aoc.string-toarray (. input 1))]
    (each [i x (ipairs xs) &until done]
      (set res (+ res (if (= ")" x) -1 1)))
      (when (< res 0) (set done i))))
  done)

(solve2 (aoc.string-from "2015/01.inp"))
#+end_src

#+RESULTS:
: 1795

** DONE Day 2.1

The  elves are  running low  on wrapping  paper, and  so they  need to
submit an order  for more. They have a list  of the dimensions (length
l, width  w, and  height h) of  each present, and  only want  to order
exactly as much as they need.

Fortunately,  every present  is  a box  (a  perfect right  rectangular
prism), which makes  calculating the required wrapping  paper for each
gift  a little  easier: find  the surface  area of  the box,  which is
2*l*w + 2*w*h  + 2*h*l. The elves  also need a little  extra paper for
each present: the area of the smallest side.

For example:
- A present with dimensions 2x3x4 requires 2*6 + 2*12 + 2*8 = 52
  square feet of wrapping paper plus 6 square feet of slack, for a
  total of 58 square feet.
- A present with dimensions 1x1x10 requires 2*1 + 2*10 + 2*10 = 42
  square feet of wrapping paper plus 1 square foot of slack, for a
  total of 43 square feet.

All numbers in the elves' list are in feet. How many total square feet
of wrapping paper should they order?

#+begin_src fennel -n :session d1502 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input
       ["2x3x4"
        "1x1x10"])

(fn area [w h l]
  (let [a1 (* l w) a2 (* w h) a3 (* h l)]
    (+ (* 2 a1) (* 2 a2) (* 2 a3) (math.min a1 a2 a3))))

(fn solve [input]
  (var res 0)
  (each [_ dim (ipairs input)]
    (case (aoc.string-split dim "x")
      [x y z] (set res (+ res (area x y z)))
      _ (print (.. "No match found for " dim))))
  res)

(fn test [expected input]
  (assert (= expected (solve input))))

(test 101 test-input)

(solve (aoc.string-from "2015/02.inp"))
#+end_src

#+RESULTS:
: 1588178

** DONE Day 2.2

The  elves are  also running  low on  ribbon. Ribbon  is all  the same
width, so they only have to worry about the length they need to order,
which they would again like to be exact.

The ribbon required to wrap a  present is the shortest distance around
its sides,  or the smallest  perimeter of  any one face.  Each present
also requires  a bow made  out of ribbon as  well; the feet  of ribbon
required for the perfect  bow is equal to the cubic  feet of volume of
the present.  Don't ask how  they tie  the bow, though;  they'll never
tell.

For example:
- A present with dimensions 2x3x4 requires 2+2+3+3 = 10 feet of ribbon
  to wrap the present plus 2*3*4 = 24 feet of ribbon for the bow, for
  a total of 34 feet.
- A present with dimensions 1x1x10 requires 1+1+1+1 = 4 feet of ribbon
  to wrap the present plus 1*1*10 = 10 feet of ribbon for the bow, for
  a total of 14 feet.

How many total feet of ribbon should they order?

#+begin_src fennel -n :session d1502 :exports both
(fn volume [w h l]
  (* w h l))

(fn perimeter [a b]
  (+ (* 2 a) (* 2 b)))

(fn solve2 [input]
  (var res 0)
  (each [_ dim (ipairs input)]
    (case (aoc.string-split dim "x")
      [x y z] (set res (+ res
                          (math.min (perimeter x y)
                                    (perimeter y z)
                                    (perimeter z x))
                          (volume x y z)))
      _ (print (.. "No match found for " dim))))
  res)

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 48 test-input)

(solve2 (aoc.string-from "2015/02.inp"))
#+end_src

#+RESULTS:
: 3783758

** DONE Day 3.1

Santa is  delivering presents to  an infinite two-dimensional  grid of
houses.

He  begins by  delivering  a  present to  the  house  at his  starting
location, and then  an elf at the  North Pole calls him  via radio and
tells him where  to move next.  Moves are always  exactly one house to
the north (^), south (v), east (>),  or west (<).  After each move, he
delivers another present to the house at his new location.

However, the  elf back  at the north  pole has had  a little  too much
eggnog, and  so his  directions are  a little off,  and Santa  ends up
visiting some houses more than once.  How many houses receive at least
one present?

For example:
- > delivers presents to 2 houses: one at the starting location, and
  one to the east.
- ^>v< delivers presents to 4 houses in a square, including twice to
  the house at his starting/ending location.
- ^v^v^v^v^v delivers a bunch of presents to some very lucky children
  at only 2 houses.
  
#+begin_src fennel -n :session d1503 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn visit-houses [dir res pos]
  (case dir
    "^" (tset pos :y (+ (. pos :y) 1))
    "v" (tset pos :y (+ (. pos :y) -1 ))
    ">" (tset pos :x (+ (. pos :x) 1 ))
    "<" (tset pos :x (+ (. pos :x) -1 ))
    _ (print (.. "Too much eggnog. Instruction unclear: " dir)))
  (let [cur [(. pos :x) (. pos :y)]]
    (when (not (aoc.matrix-contains? res cur)) 
      (table.insert res cur))))

(fn solve [input]
  (let [pos {:x 0 :y 0}
        res [[(. pos :x) (. pos :y)]]
        xs (aoc.string-toarray (. input 1))]
    (lume.map xs #(visit-houses $ res pos))
    (length res)))

(fn test [expected input]
  (assert (= expected (solve [input]))))

(test 2 ">")
(test 4 "^>v<")
(test 2 "^v^v^v^v^v")

(solve (aoc.string-from "2015/03.inp"))
#+end_src

#+RESULTS:
: 2081

** DONE Day 3.2

The next year, to speed up  the process, Santa creates a robot version
of himself, Robo-Santa, to deliver presents with him.

Santa  and  Robo-Santa start  at  the  same location  (delivering  two
presents to the same starting house),  then take turns moving based on
instructions from  the elf, who  is eggnoggedly reading from  the same
script as the previous year.

This year, how many houses receive at least one present?

For example:
- ^v delivers presents to 3 houses, because Santa goes north, and then
  Robo-Santa goes south.
- ^>v< now delivers presents to 3 houses, and Santa and Robo-Santa end
  up back where they started.
- ^v^v^v^v^v now delivers presents to 11 houses, with Santa going one
  direction and Robo-Santa going the other.

#+begin_src fennel -n :session d1503 :exports both
(fn solve2 [input]
  (let [pos-odd {:x 0 :y 0}
        pos-even {:x 0 :y 0}
        res [[(. pos-odd :x) (. pos-odd :y)]]
        xs (aoc.string-toarray (. input 1))]
    (lume.map (aoc.table-odd xs) #(visit-houses $ res pos-odd))
    (lume.map (aoc.table-even xs) #(visit-houses $ res pos-even))
    (length res)))

(fn test2 [expected input]
  (assert (= expected (solve2 [input]))))

(test2 3 "^v")
(test2 3 "^>v<")
(test2 11 "^v^v^v^v^v")

(solve2 (aoc.string-from "2015/03.inp"))
#+end_src

#+RESULTS:
: 2341


** DONE Day 4.1

Santa needs help mining some AdventCoins (very similar to bitcoins) to
use as  gifts for all  the economically forward-thinking  little girls
and boys.

To do this,  he needs to find MD5 hashes  which, in hexadecimal, start
with at least  five zeroes. The input  to the MD5 hash  is some secret
key  (your  puzzle  input,  given  below)  followed  by  a  number  in
decimal. To mine AdventCoins, you  must find Santa the lowest positive
number (no leading zeroes: 1, 2, 3, ...) that produces such a hash.

For example:
- If your secret key is abcdef, the answer is 609043, because the MD5
  hash of abcdef609043 starts with five zeroes (000001dbbfa...), and
  it is the lowest such number to do so.
- If your secret key is pqrstuv, the lowest number it combines with to
  make an MD5 hash starting with five zeroes is 1048970; that is, the
  MD5 hash of pqrstuv1048970 looks like 000006136ef....

#+begin_src fennel -n :session d1504 :exports both
(local md5 (require :lib.md5))

(fn solve [seed]
  (var res false)
  (var salt 0)
  (while (not res)
    (let [hash (md5.sumhexa (.. seed salt))
          prefix (string.sub hash 1 5)]
      (if (= "00000" prefix)
          (set res salt)
          (set salt (+ 1 salt)))))
  res)

(solve "yzbqklnj")
#+end_src

#+RESULTS:
: 282749
  
** DONE Day 4.2

Now find one that starts with six zeroes.

#+begin_src fennel -n :session d1504 :exports both
(fn solve2 [seed]
  (var res false)
  (var salt 0)
  (while (not res)
    (let [hash (md5.sumhexa (.. seed salt))
          prefix (string.sub hash 1 6)]
      (if (= "000000" prefix)
          (set res salt)
          (set salt (+ 1 salt)))))
  res)

(solve2 "yzbqklnj")
#+end_src

#+RESULTS:
: 9962624



** DONE Day 5.1

Santa  needs help  figuring out  which strings  in his  text file  are
naughty or nice.

A nice string is one with all of the following properties:
- It contains at least three vowels (aeiou only), like aei, xazegov,
  or aeiouaeiouaeiou.
- It contains at least one letter that appears twice in a row, like
  xx, abcdde (dd), or aabbccdd (aa, bb, cc, or dd).
- It does not contain the strings ab, cd, pq, or xy, even if they are
  part of one of the other requirements.
  
For example:
- ugknbfddgicrmopn is nice because it has at least three vowels
  (u...i...o...), a double letter (...dd...), and none of the
  disallowed substrings.
- aaa is nice because it has at least three vowels and a double
  letter, even though the letters used by different rules overlap.
- jchzalrnumimnmhp is naughty because it has no double letter.
- haegwjzuvuyypxyu is naughty because it contains the string xy.
- dvszwmarrgswjxmb is naughty because it contains only one vowel.

How many strings are nice?

#+begin_src fennel -n :session d1505 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["ugknbfddgicrmopn"
        "aaa"
        "jchzalrnumimnmhp"
        "haegwjzuvuyypxyu"
        "dvszwmarrgswjxmb"])

(fn none-of-ab-p [x]
  (not (string.find x "ab" 1 true)))

(fn none-of-cd-p [x]
  (not (string.find x "cd" 1 true)))

(fn none-of-pq-p [x]
  (not (string.find x "pq" 1 true)))

(fn none-of-xy-p [x]
  (not (string.find x "xy" 1 true)))

(fn one-double-p [x]
  (let [ys (aoc.partition1 (aoc.string-toarray x))]
    (lume.any ys (fn [[c1 c2]] (= c1 c2)))))

(fn three-vowels-p [x]
  (var count 0)
  (each [_ c (ipairs (aoc.string-toarray x))]
    (case c
      "a" (set count (+ 1 count))
      "e" (set count (+ 1 count))
      "i" (set count (+ 1 count))
      "o" (set count (+ 1 count))
      "u" (set count (+ 1 count))
      _ nil))
  (<= 3 count))

(fn solve [input]
  (-> input
      (lume.filter #(none-of-ab-p $))
      (lume.filter #(none-of-cd-p $))
      (lume.filter #(none-of-pq-p $))
      (lume.filter #(none-of-xy-p $))
      (lume.filter #(one-double-p $))
      (lume.filter #(three-vowels-p $))
      (length)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 2 test-input)

(solve (aoc.string-from "2015/05.inp"))
#+end_src

#+RESULTS:
: 236

** DONE Day 5.2

Realizing the error of his ways,  Santa has switched to a better model
of determining  whether a string is  naughty or nice. None  of the old
rules apply, as they are all clearly ridiculous.

Now, a nice string is one with all of the following properties:
- It contains a pair of any two letters that appears at least twice in
  the string without  overlapping, like xyxy (xy)  or aabcdefgaa (aa),
  but not like aaa (aa, but it overlaps).
- It  contains at  least one  letter  which repeats  with exactly  one
  letter between them, like xyx, abcdefeghi (efe), or even aaa.
  
For example:
- qjhvhtzxzqqjkmpb is  nice because is  has a pair that  appears twice
  (qj) and a letter that repeats  with exactly one letter between them
  (zxz).
- xxyxx is nice because it has a  pair that appears twice and a letter
  that repeats with one between, even  though the letters used by each
  rule overlap.
- uurcxstgmygtbstg is naughty because it has a pair (tg) but no repeat
  with a single letter between them.
- ieodomkazucvgmuy is naughty  because it has a  repeating letter with
  one between (odo), but no pair that appears twice.
  
How many strings are nice under these new rules?

#+begin_src fennel -n :session d1505 :exports both
(local test2-input
       ["qjhvhtzxzqqjkmpb"
        "xxyxx"
        "uurcxstgmygtbstg"
        "ieodomkazucvgmuy"])

(fn two-pairs-p [x]
  (var done false)
  (let [xs (aoc.string-toarray x)]
    (for [i 1 (- (# xs) 1) &until done]
      (let [token (.. (. xs i) (. xs (+ 1 i)))]
        (when (string.find x token (+ 2 i) true)
          (set done true))))) 
  done)

(fn triple-p [x]
  (-> x
      (aoc.string-toarray)
      (aoc.partition3step1)
      (lume.any (fn [[a b c]] (= a c)))))

(fn solve2 [input]
  (-> input
      (lume.filter #(two-pairs-p $))
      (lume.filter #(triple-p $))
      (length)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 2 test2-input)

(solve2 (aoc.string-from "2015/05.inp"))
#+end_src

#+RESULTS:
: 51


** DONE Day 6.1

Because  your  neighbors  keep  defeating you  in  the  holiday  house
decorating  contest year  after  year, you've  decided  to deploy  one
million lights in a 1000x1000 grid.

Furthermore, because you've been especially  nice this year, Santa has
mailed  you  instructions  on  how   to  display  the  ideal  lighting
configuration.

Lights in your grid are numbered from  0 to 999 in each direction; the
lights  at each  corner are  at 0,0,  0,999, 999,999,  and 999,0.  The
instructions include whether  to turn on, turn off,  or toggle various
inclusive  ranges  given as  coordinate  pairs.  Each coordinate  pair
represents opposite  corners of  a rectangle, inclusive;  a coordinate
pair  like 0,0  through 2,2  therefore  refers to  9 lights  in a  3x3
square. The lights all start turned off.

To defeat your neighbors this year, all  you have to do is set up your
lights by doing the instructions Santa sent you in order.

For example:
- turn on 0,0 through 999,999 would turn on (or leave on) every light.
- toggle 0,0 through 999,0 would toggle the first line of 1000 lights,
  turning off the ones that were on, and turning on the ones that were
  off.
- turn off 499,499 through 500,500 would turn off (or leave off) the
  middle four lights.  

After following the instructions, how many lights are lit?

#+begin_src fennel -n :session d1506 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-line [line]
  (case (aoc.string-split line " ")
    ["turn" "off" from "through" to]
    [0 (aoc.string-split from ",") (aoc.string-split to ",")]
    ["toggle" from "through" to]
    [-1 (aoc.string-split from ",") (aoc.string-split to ",")]
    ["turn" "on" from "through" to]
    [1 (aoc.string-split from ",") (aoc.string-split to ",")]
    _ (print (.. "No match for " line))))

(fn solve [input]
  (let [m (aoc.matrix 1000 1000 0)
        xs (lume.map input (fn [l] (read-line l)))]
    (each [_ [op [a1 a2] [b1 b2]] (ipairs xs)]
      (let [x1 (+ 1 (tonumber a1))
            y1 (+ 1 (tonumber a2))
            x2 (+ 1 (tonumber b1))
            y2 (+ 1 (tonumber b2))]
        (case op
          -1 (aoc.matrix-toggle m x1 y1 x2 y2)
          0 (aoc.matrix-set m x1 y1 x2 y2 0)
          1 (aoc.matrix-set m x1 y1 x2 y2 1)
          _ (print (.. "No match for " op)))))
    (aoc.table-sum m)))

(solve (aoc.string-from "2015/06.inp"))
#+end_src

#+RESULTS:
: 569999


** DONE Day 6.2

You  just finish  implementing  your winning  light  pattern when  you
realize you mistranslated Santa's message from Ancient Nordic Elvish.

The light grid you bought actually has individual brightness controls;
each light can have a brightness of zero or more. The lights all start
at zero.

The  phrase  turn on  actually  means  that  you should  increase  the
brightness of those lights by 1.

The  phrase turn  off  actually  means that  you  should decrease  the
brightness of those lights by 1, to a minimum of zero.

The  phrase  toggle  actually  means  that  you  should  increase  the
brightness of those lights by 2.

What is  the total brightness  of all lights combined  after following
Santa's instructions?

For example:
- turn on 0,0 through 0,0 would increase the total brightness by 1.
- toggle 0,0 through 999,999 would increase the total brightness
  by 2000000.

#+begin_src fennel -n :session d1506 :exports both
(fn solve2 [input]
  (let [m (aoc.matrix 1000 1000 0)
        xs (lume.map input (fn [l] (read-line l)))]
    (each [_ [op [a1 a2] [b1 b2]] (ipairs xs)]
      (let [x1 (+ 1 (tonumber a1))
            y1 (+ 1 (tonumber a2))
            x2 (+ 1 (tonumber b1))
            y2 (+ 1 (tonumber b2))]
        (case op
          -1 (aoc.matrix-apply m x1 y1 x2 y2 (fn [v] (+ 2 v)))
          0 (aoc.matrix-apply m x1 y1 x2 y2 (fn [v] (math.max 0 (- v 1))))
          1 (aoc.matrix-apply m x1 y1 x2 y2 (fn [v] (+ 1 v)))
          _ (print (.. "No match for " op)))))
    (aoc.table-sum m)))

(solve2 (aoc.string-from "2015/06.inp"))
#+end_src

#+RESULTS:
: 17836115

  
** DONE Day 7.1

This  year, Santa  brought  little Bobby  Tables a  set  of wires  and
bitwise logic gates! Unfortunately, little Bobby is a little under the
recommended age range, and he needs help assembling the circuit.

Each wire has  an identifier (some lowercase letters) and  can carry a
16-bit signal (a number from 0 to 65535). A signal is provided to each
wire by  a gate, another wire,  or some specific value.  Each wire can
only  get a  signal from  one source,  but can  provide its  signal to
multiple  destinations. A  gate provides  no signal  until all  of its
inputs have a signal.

The included instructions  booklet describes how to  connect the parts
together: x AND y -> z means to  connect wires x and y to an AND gate,
and then connect its output to wire z.

For example:
- 123 -> x means that the signal 123 is provided to wire x.
- x AND y -> z means that the bitwise AND of wire x and wire y is
  provided to wire z.
- p LSHIFT 2 -> q means that the value from wire p is left-shifted by
  2 and then provided to wire q.
- NOT e -> f means that the bitwise complement of the value from wire
  e is provided to wire f.
  
Other   possible   gates   include   OR  (bitwise   OR)   and   RSHIFT
(right-shift). If, for some reason,  you'd like to emulate the circuit
instead, almost all programming languages (for example, C, JavaScript,
or Python) provide operators for these gates.

For example, here is a simple circuit:

#+begin_example
123 -> x
456 -> y
x AND y -> d
x OR y -> e
x LSHIFT 2 -> f
y RSHIFT 2 -> g
NOT x -> h
NOT y -> i
#+end_example

After it is run, these are the signals on the wires:

#+begin_example
d: 72
e: 507
f: 492
g: 114
h: 65412
i: 65079
x: 123
y: 456
#+end_example

In little Bobby's kit's instructions  booklet (provided as your puzzle
input), what signal is ultimately provided to wire a?

#+begin_src fennel -n :session d1507 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local bit (require :bit))

(fn eval [xs k]
  (or (tonumber k)
      (let [v (?. xs k)]
        (match (aoc.string-split v " ")
          ["NOT" f] (tset xs k (bit.bnot (eval xs f)))
          [f1 "AND" f2] (tset xs k (bit.band (eval xs f1) (eval xs f2)))
          [f1 "OR" f2] (tset xs k (bit.bor (eval xs f1) (eval xs f2)))
          [f "LSHIFT" n] (tset xs k (bit.lshift (eval xs f) (tonumber n)))
          [f "RSHIFT" n] (tset xs k (bit.rshift (eval xs f) (tonumber n)))
          [f] (tset xs k (eval xs f))
          _ (print (.. "No match for " k)))
        (. xs k))))

(fn init [xs line]
  (let [[op res] (aoc.string-split line "->")]
    (tset xs (aoc.string-trim2 res) (aoc.string-trim2 op))))

(fn solve [lines k]
  (let [xs {}]
    (lume.map lines #(init xs $))
    (eval xs k)))

(solve (aoc.string-from "2015/07.inp") :a)
#+end_src

#+RESULTS:
: 956

** DONE Day 7.2

Now,  take the  signal you  got on  wire a,  override wire  b to  that
signal, and reset the other wires  (including wire a). What new signal
is ultimately provided to wire a?

#+begin_src fennel -n :session d1507 :exports both
(fn solve2 [lines k]
  (let [xs {}]
    (lume.map lines #(init xs $))
    (tset xs :b 956)
    (eval xs k)))

(solve2 (aoc.string-from "2015/07.inp") :a)
#+end_src

#+RESULTS:
: 40149


** DONE Day 8.1

Space  on the  sleigh  is limited  this  year, and  so  Santa will  be
bringing his list as  a digital copy. He needs to  know how much space
it will take up when stored.

It is common in many programming  languages to provide a way to escape
special  characters  in strings.  For  example,  C, JavaScript,  Perl,
Python, and even PHP handle special characters in very similar ways.

However, it is important to  realize the difference between the number
of characters in the code representation of the string literal and the
number of characters in the in-memory string itself.

For example:
- "" is 2 characters of code (the two double quotes), but the string
  contains zero characters.
- "abc" is 5 characters of code, but 3 characters in the string data.
- "aaa\"aaa" is 10 characters of code, but the string itself contains
  six "a" characters and a single, escaped quote character, for a
  total of 7 characters in the string data.
- ="\x27"= is 6 characters of code, but the string itself contains just
  one - an apostrophe ('), escaped using hexadecimal notation.
  
Santa's  list  is  a  file that  contains  many  double-quoted  string
literals,  one  on each  line.  The  only  escape sequences  used  are
\\ (which represents a single  backslash), \" (which represents a lone
double-quote character), and =\x= plus two hexadecimal characters (which
represents a single character with that ASCII code).

Disregarding  the  whitespace in  the  file,  what  is the  number  of
characters of code for string  literals minus the number of characters
in memory for the values of the strings in total for the entire file?

For  example,  given the  four  strings  above,  the total  number  of
characters of string code (2 + 5 + 10 + 6 = 23) minus the total number
of characters in memory for string values (0 + 3 + 7 + 1 = 11) is 23 -
11 = 12.

#+begin_src fennel -n :session d1508 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn char-len [s]
  (var len 0)
  (var i 1)
  (let [xs (aoc.string-toarray s)]
    (while (<= i (# xs))
      (case (. xs i)
        "\\" (set i (+ i (if (= "x" (. xs (+ 1 i))) 4 2)))
        _ (set i (+ i 1)))
      (set len (+ 1 len))))
  len)

(fn raw-len [s]
  (+ 
   (string.len "\"")
   (string.len "\"")
   (string.len s)))

(fn solve [lines]
  (var len1 0)
  (var len2 0)
  (each [_ line (ipairs lines)]
    (set len1 (+ len1 (raw-len line)))
    (set len2 (+ len2 (char-len line))))
  (- len1 len2))

(solve (aoc.string-from "2015/08.inp"))
#+end_src

#+RESULTS:
: 1371

** DONE Day 8.2

Now, let's  go the  other way.  In addition to  finding the  number of
characters of code, you should  now encode each code representation as
a new  string and  find the  number of characters  of the  new encoded
representation, including the surrounding double quotes.

For example:
- "" encodes to "\"\"", an increase from 2 characters to 6.
- "abc" encodes to "\"abc\"", an increase from 5 characters to 9.
- "aaa\"aaa" encodes to "\"aaa\\\"aaa\"", an increase from 10
  characters to 16.
- ="\x27"= encodes to ="\"\\x27\""=, an increase from 6 characters to 11.
  
Your task is  to find the total number of  characters to represent the
newly encoded strings  minus the number of characters of  code in each
original string literal. For example, for the strings above, the total
encoded length  (6 + 9  + 16 +  11 = 42)  minus the characters  in the
original code representation (23, just like  in the first part of this
puzzle) is 42 - 23 = 19.

#+begin_src fennel -n :session d1508 :exports both
(fn solve2 [lines]
  (-> lines
      (lume.map (fn [s] (- (string.len (aoc.string-escape s))
                           (string.len s))))
      (lume.reduce (fn [s x] (+ s x)))))

(solve2 (aoc.string-from "2015/08.inp"))
#+end_src

#+RESULTS:
: 2117

** DONE Day 9.1

Every year, Santa  manages to deliver all of his  presents in a single
night.

This year, however, he has some new locations to visit; his elves have
provided him  the distances  between every pair  of locations.  He can
start and end  at any two (different) locations he  wants, but he must
visit each location exactly once. What is the shortest distance he can
travel to achieve this?

For example, given the following distances:

#+begin_example
London to Dublin = 464
London to Belfast = 518
Dublin to Belfast = 141
#+end_example

The possible routes are therefore:

#+begin_example
Dublin -> London -> Belfast = 982
London -> Dublin -> Belfast = 605
London -> Belfast -> Dublin = 659
Dublin -> Belfast -> London = 659
Belfast -> Dublin -> London = 605
Belfast -> London -> Dublin = 982
#+end_example

The shortest of these is London -> Dublin -> Belfast = 605, and so the
answer is 605 in this example.

What is the distance of the shortest route?

#+begin_src fennel -n :session d1509 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["London to Dublin = 464"
        "London to Belfast = 518"
        "Dublin to Belfast = 141"])

(fn read-lines [lines]
  (let [res {}]
    (each [_ line (ipairs lines)]
      (case (aoc.string-split line " ")
        [dest1 "to" dest2 "=" dist]
        (do
          (aoc.table-update res dest1 dest2 dist)
          (aoc.table-update res dest2 dest1 dist))
        _ (print "No match found for line")))
    res))

(fn distance [itin t]
  (accumulate [sum 0 _ [b e] (ipairs (aoc.partition1 itin))]
    (+ sum (tonumber (. (. t b) e)))))

(fn find-distances [input]
  (let [t (read-lines input)
        d (aoc.keys t)
        itiner []]
    (aoc.permutation d (# d) itiner)
    (lume.map itiner #(distance $ t))))

(fn solve [input]
  (-> input
      (find-distances)
      (aoc.math-min)))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 605 test-input)

(solve (aoc.string-from "2015/09.inp"))
#+end_src

#+RESULTS:
: 251

** DONE Day 9.2

The next year, just to show off, Santa decides to take the route with
the longest distance instead.

He can still start and end at any two (different) locations he wants,
and he still must visit each location exactly once.

For example, given the distances above, the longest route would be 982
via (for example) Dublin -> London -> Belfast.

What is the distance of the longest route?

#+begin_src fennel -n :session d1509 :exports both
(fn solve2 [input]
  (-> input
      (find-distances)
      (aoc.math-max)))

(fn test2 [expected input]
  (assert (= expected (solve2 input))))

(test2 982 test-input)

(solve2 (aoc.string-from "2015/09.inp"))
#+end_src

#+RESULTS:
: 898


** DONE Day 10.1

Today, the  Elves are  playing a game  called look-and-say.  They take
turns  making sequences  by reading  aloud the  previous sequence  and
using that reading  as the next sequence. For example,  211 is read as
"one two, two ones", which becomes 1221 (1 2, 2 1s).

Look-and-say sequences  are generated iteratively, using  the previous
value as  input for the  next step. For  each step, take  the previous
value, and  replace each run of  digits (like 111) with  the number of
digits (3) followed by the digit itself (1).

For example:
- 1 becomes 11 (1 copy of digit 1).
- 11 becomes 21 (2 copies of digit 1).
- 21 becomes 1211 (one 2 followed by one 1).
- 1211 becomes 111221 (one 1, one 2, and two 1s).
- 111221 becomes 312211 (three 1s, two 2s, and one 1).

Starting with the  digits in your puzzle input, apply  this process 40
times. What is the length of the result?

#+begin_src fennel -n :session d1510 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn soundas [xs]
  (let [ys (aoc.partition-by xs #(= $1 $2))
        zs (lume.map ys #(.. "" (length $) (. $ 1)))]
    (table.concat zs "")))

(fn solve [input cycles]
  (var res input)
  (for [i 1 cycles]
    (let [xs (aoc.string-toarray res)]
      (set res (soundas xs))))
  (length res))

(fn test [expected input cycles]
  (assert (= expected (solve input cycles))))

(test 6 "1" 5)

(solve "1321131112" 40)
#+end_src

#+RESULTS:
: 492982

** DONE Day 10.2

Neat, right?  You  might also enjoy hearing [[https://www.youtube.com/watch?v=ea7lJkEhytA][John  Conway talking]] about
this sequence (that's Conway of Conway's Game of Life fame).

Now, starting again with the digits in your puzzle input, apply this
process 50 times. What is the length of the new result?

#+begin_src fennel -n :session d1510 :exports both
(solve "1321131112" 50)
#+end_src

#+RESULTS:
: 6989950


** DONE Day 11.1

Santa's previous  password expired, and  he needs help choosing  a new
one.

To help him remember his new password after the old one expires, Santa
has  devised a  method  of coming  up  with a  password  based on  the
previous one. Corporate policy dictates that passwords must be exactly
eight lowercase  letters (for security  reasons), so he finds  his new
password by incrementing  his old password string  repeatedly until it
is valid.

Incrementing is just  like counting with numbers: xx, xy,  xz, ya, yb,
and so  on. Increase the  rightmost letter one step;  if it was  z, it
wraps around to a,  and repeat with the next letter  to the left until
one doesn't wrap around.

Unfortunately for Santa,  a new Security-Elf recently  started, and he
has imposed some additional password requirements:
- Passwords must include one increasing straight of at least three
  letters, like abc, bcd, cde, and so on, up to xyz. They cannot skip
  letters; abd doesn't count.
- Passwords may not contain the letters i, o, or l, as these letters
  can be mistaken for other characters and are therefore confusing.
- Passwords must contain at least two different, non-overlapping pairs
  of letters, like aa, bb, or zz.

For example:
- hijklmmn  meets  the  first  requirement (because  it  contains  the
  straight hij) but fails the  second requirement (because it contains
  i and l).
- abbceffg meets the third requirement (because it repeats bb and ff)
  but fails the first requirement.
- abbcegjk fails the third requirement, because it only has one double
  letter (bb).
- The next password after abcdefgh is abcdffaa.
- The next password after ghijklmn is ghjaabcc, because you eventually
  skip all the passwords that start with ghi..., since i is not
  allowed.
  
Given Santa's  current password (your  puzzle input), what  should his
next password be?

#+begin_src fennel -n :session d1511 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn incchar [xs ?pos]
  (let [pos (or ?pos (# xs))]
    (if (not (<= 1 pos (# xs)))
        xs
        (let [xn (- (string.byte (. xs pos)) 96)
              xo (aoc.modulo+ 1 xn 26)]
          (table.remove xs pos)
          (table.insert xs pos (string.char (+ 96 xo)))
          (if (= 1 xo)
              (incchar xs (- pos 1))
              xs)))))

(fn valid? [xs]
  (and
   (lume.all xs
             #(and (not= $ "i") (not= $ "o") (not= $ "l")))
   (lume.any (aoc.partition3step1 xs)
             #(and (= (+ 2 (string.byte (. $ 1)))
                      (+ 1 (string.byte (. $ 2)))
                      (string.byte (. $ 3)))))
   (<= 2 (length (lume.filter (aoc.partition-by xs #(= $1 $2))
                              #(<= 2 (length $)))))))

(fn pwdgen [xs]
  (var ys (incchar xs))
  (while (not (valid? ys))
    (set ys (incchar ys)))
  ys)

(fn solve [input]
  (-> input
      (aoc.string-toarray)
      (pwdgen)
      (table.concat "")))

(fn test [expected input]
  (assert (= expected (solve input))))

(test "abcdffaa" "abcdefgh")
(test "ghjaabcc" "ghijklmn")
(solve "vzbxkghb")
#+end_src

#+RESULTS:
: vzbxxyzz

** DONE Day 11.2

Santa's password expired again. What's the next one?

#+begin_src fennel -n :session d1511 :exports both
(solve "vzbxxyzz")
#+end_src

#+RESULTS:
: vzcaabcc


** DONE Day 12.1

Santa's Accounting-Elves need help balancing  the books after a recent
order.  Unfortunately,  their  accounting  software  uses  a  peculiar
storage format. That's where you come in.

They have a  JSON document which contains a variety  of things: arrays
([1,2,3]), objects ({"a":1, "b":2}),  numbers, and strings. Your first
job is to  simply find all of the numbers  throughout the document and
add them together.

For example:
- [1,2,3] and {"a":2,"b":4} both have a sum of 6.
- [[[3] ] ] and {"a":{"b":4},"c":-1} both have a sum of 3.
- {"a":[-1,1]} and [-1,{"a":1}] both have a sum of 0.
- [] and {} both have a sum of 0.

You will not encounter any strings containing numbers.

What is the sum of all numbers in the document?

#+begin_src fennel -n :session d1512 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local json (require :lib.dkjson))

(fn sum-numbers [x]
  (case (type x)
    :string 0
    :number x
    :table
    (if (= 0 (length x))
        (accumulate [sum 0 k v (pairs x)]
          (+ sum (sum-numbers v)))
        (accumulate [sum 0 k v (ipairs x)]
          (+ sum (sum-numbers v))))
    _ (print (.. "No match found for " x))))

(fn solve [input]
  (-> (. input 1)
      (json.decode)
      (sum-numbers)))

(fn test [expected input]
  (assert (= expected (solve [input]))))

(test 6 "[1,2,3]")
(test 6 "{\"a\":2,\"b\":4}")
(test 3 "[[[3] ] ]")
(test 3 "{\"a\":{\"b\":4},\"c\":-1}")
(test 0 "{\"a\":[-1,1]}")
(test 0 "[-1,{\"a\":1}]")
(test 0 "[]")
(test 0 "{}")

(solve (aoc.string-from "2015/12.inp"))
#+end_src

#+RESULTS:
: 191164

** DONE Day 12.2

Uh oh  - the Accounting-Elves  have realized that  they double-counted
everything red.

Ignore any object (and all of its children) which has any property
with the value "red". Do this only for objects ({...}), not arrays
([...]).
- [1,2,3] still has a sum of 6.
- [1,{"c":"red","b":2},3] now has a sum of 4, because the middle
  object is ignored.
- {"d":"red","e":[1,2,3,4],"f":5} now has a sum of 0, because the
  entire structure is ignored.
- [1,"red",5] has a sum of 6, because "red" in an array has no effect.
  
#+begin_src fennel -n :session d1512 :exports both
(fn sum-numbers2 [x]
  (case (type x)
    :string 0
    :number x
    :table
    (if (= 0 (length x))
        (if (lume.any x #(= "red" $))
            0
            (accumulate [sum 0 k v (pairs x)]
              (+ sum (sum-numbers2 v))))
        (accumulate [sum 0 k v (ipairs x)]
          (+ sum (sum-numbers2 v))))
    _ (print (.. "No match found for " x))))

(fn solve2 [input]
  (-> (. input 1)
      (json.decode)
      (sum-numbers2)))

(solve2 (aoc.string-from "2015/12.inp"))
#+end_src

#+RESULTS:
: 87842


** DONE Day 13.1

In  years past,  the holiday  feast with  your family  hasn't gone  so
well.  Not  everyone gets  along!  This  year,  you resolve,  will  be
different. You're  going to find  the optimal seating  arrangement and
avoid all those awkward conversations.

You start  by writing  up a  list of everyone  invited and  the amount
their  happiness would  increase  or  decrease if  they  were to  find
themselves  sitting next  to each  other person.  You have  a circular
table that will be just big enough to fit everyone comfortably, and so
each person will have exactly two neighbors.

For example,  suppose you  have only four  attendees planned,  and you
calculate their potential happiness as follows:

#+begin_example
Alice would gain 54 happiness units by sitting next to Bob.
Alice would lose 79 happiness units by sitting next to Carol.
Alice would lose 2 happiness units by sitting next to David.
Bob would gain 83 happiness units by sitting next to Alice.
Bob would lose 7 happiness units by sitting next to Carol.
Bob would lose 63 happiness units by sitting next to David.
Carol would lose 62 happiness units by sitting next to Alice.
Carol would gain 60 happiness units by sitting next to Bob.
Carol would gain 55 happiness units by sitting next to David.
David would gain 46 happiness units by sitting next to Alice.
David would lose 7 happiness units by sitting next to Bob.
David would gain 41 happiness units by sitting next to Carol.
#+end_example

Then, if  you seat Alice next  to David, Alice would  lose 2 happiness
units (because David talks so much), but David would gain 46 happiness
units (because  Alice is  such a  good listener),  for a  total change
of 44.

If you  continue around  the table,  you could then  seat Bob  next to
Alice (Bob  gains 83, Alice gains  54). Finally, seat Carol,  who sits
next to Bob (Carol  gains 60, Bob loses 7) and  David (Carol gains 55,
David gains 41). The arrangement looks like this:

#+begin_example
     +41 +46
+55   David    -2
Carol       Alice
+60    Bob    +54
     -7  +83
#+end_example

After  trying every  other  seating arrangement  in this  hypothetical
scenario, you  find that this  one is the  most optimal, with  a total
change in happiness of 330.

What  is  the  total  change  in happiness  for  the  optimal  seating
arrangement of the actual guest list?

#+begin_src fennel -n :session d1513 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input
       ["Alice would gain 54 happiness units by sitting next to Bob."
        "Alice would lose 79 happiness units by sitting next to Carol."
        "Alice would lose 2 happiness units by sitting next to David."
        "Bob would gain 83 happiness units by sitting next to Alice."
        "Bob would lose 7 happiness units by sitting next to Carol."
        "Bob would lose 63 happiness units by sitting next to David."
        "Carol would lose 62 happiness units by sitting next to Alice."
        "Carol would gain 60 happiness units by sitting next to Bob."
        "Carol would gain 55 happiness units by sitting next to David."
        "David would gain 46 happiness units by sitting next to Alice."
        "David would lose 7 happiness units by sitting next to Bob."
        "David would gain 41 happiness units by sitting next to Carol."])

(fn read-line [line xs]
  (case (aoc.string-split line " ")
    [me "would" "gain" x "happiness" "units" "by" "sitting" "next" "to" who]
    (aoc.table-update xs me (string.sub who 1 (- (# who) 1)) (tonumber x))
    [me "would" "lose" x "happiness" "units" "by" "sitting" "next" "to" who]
    (aoc.table-update xs me (string.sub who 1 (- (# who) 1)) (- (tonumber x)))
    _ (print (.. "No match found for " line))))

(fn read-lines [lines]
  (let [scores {}]
    (each [_ line (ipairs lines)]
      (read-line line scores))
    scores))

(fn score-pairs [xs scores]
  (let [fst (. xs 1)
        lst (. xs (# xs))
        ys (aoc.partition1 xs)
        res [(+ (. (. scores fst) lst) (. (. scores lst) fst))]]
    (each [_ [p1 p2] (ipairs ys)]
      (table.insert res (+ (. (. scores p1) p2) (. (. scores p2) p1))))
    res))

(fn score-arrangements [lines]
  (let [scores (read-lines lines)
        guests (aoc.keys scores)
        arrangement []]
    (aoc.permutation guests (# guests) arrangement)
    (lume.map arrangement #(score-pairs $ scores))))

(fn solve [lines]
  (let [xs (score-arrangements lines)]
    (aoc.math-max (lume.map xs #(aoc.table-sum $)))))

(fn test [expected input]
  (assert (= expected (solve input))))

(test 330 test-input)

(solve (aoc.string-from "2015/13.inp"))
#+end_src

#+RESULTS:
: 733


** DONE Day 13.2

In all the commotion, you realize that you forgot to seat yourself. At
this point, you're  pretty apathetic toward the whole  thing, and your
happiness wouldn't really go up or down regardless of who you sit next
to. You assume everyone else would be just as ambivalent about sitting
next to you, too.

So, add  yourself to  the list, and  give all  happiness relationships
that involve you a score of 0.

What is the total change in happiness for the optimal seating
arrangement that actually includes yourself?

#+begin_src fennel -n :session d1513 :exports both
(fn solve2 [lines]
  (let [xs (score-arrangements lines)]
    (each [_ x (ipairs xs)]
        (table.sort x)
        ;; maximize happiness sitting at its min
        (aoc.table-swap x 1 0))
    (aoc.math-max (lume.map xs #(aoc.table-sum $)))))

(solve2 (aoc.string-from "2015/13.inp"))
#+end_src

#+RESULTS:
: 725


** DONE Day 14.1

This year is  the Reindeer Olympics! Reindeer can fly  at high speeds,
but must rest  occasionally to recover their energy.  Santa would like
to know which of his reindeer is fastest, and so he has them race.

Reindeer can  only either  be flying  (always at  their top  speed) or
resting (not moving at all), and  always spend whole seconds in either
state.

For example, suppose you have the following Reindeer:
- Comet can fly 14 km/s for 10 seconds, but then must rest for 127
  seconds.
- Dancer can fly 16 km/s for 11 seconds, but then must rest for 162
  seconds.
  
After  one second,  Comet has  gone 14  km, while  Dancer has  gone 16
km. After  ten seconds, Comet has  gone 140 km, while  Dancer has gone
160 km. On  the eleventh second, Comet begins resting  (staying at 140
km), and Dancer  continues on for a  total distance of 176  km. On the
12th second,  both reindeer are  resting. They continue to  rest until
the 138th  second, when Comet  flies for  another ten seconds.  On the
174th second, Dancer flies for another 11 seconds.

In this example,  after the 1000th second, both  reindeer are resting,
and Comet is in the lead at  1120 km (poor Dancer has only gotten 1056
km by that point). So, in this situation, Comet would win (if the race
ended at 1000 seconds).

Given the descriptions of each  reindeer (in your puzzle input), after
exactly 2503 seconds, what distance has the winning reindeer traveled?

#+begin_src fennel -n :session d1514 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input
       ["Comet can fly 14 km/s for 10 seconds, but then must rest for 127 seconds."
        "Dancer can fly 16 km/s for 11 seconds, but then must rest for 162 seconds."])

(fn read-line [line]
  (case (aoc.string-split line " ")
    [n "can" "fly" km "km/s" "for" m "seconds," "but" "then" "must" "rest" "for" s "seconds."]
    {:n n :km (tonumber km) :m (tonumber m) :s (tonumber s)}
    _ (print (.. "No match for " line))))

(fn time-to-dist [xs t]
  (let [n (. xs :n)
        km (. xs :km)
        m (. xs :m)
        s (. xs :s)
        cycles (math.floor (/ t (+ m s)))
        reminder (- t (* cycles (+ m s)))]
    {:n n :d (+ (* km m cycles)
                (if (< reminder m)
                    (* km reminder)
                    (* km m)))}))

(fn solve [input maxtime]
  (-> input
      (lume.map read-line)
      (lume.map #(time-to-dist $ maxtime))
      (lume.map #(. $ :d))
      (aoc.table-max)))

(fn test [expected input]
  (assert (= expected (solve input 1000))))

(test 1120 test-input)

(solve (aoc.string-from "2015/14.inp") 2503)
#+end_src

#+RESULTS:
: 2696


** DONE Day 14.2

Seeing how  reindeer move  in bursts, Santa  decides he's  not pleased
with the old scoring system.

Instead,  at the  end  of each  second,  he awards  one  point to  the
reindeer currently in  the lead. (If there are  multiple reindeer tied
for the lead, they each get  one point.) He keeps the traditional 2503
second time  limit, of  course, as doing  otherwise would  be entirely
ridiculous.

Given the example reindeer from  above, after the first second, Dancer
is in the lead and gets one  point. He stays in the lead until several
seconds into Comet's second burst: after the 140th second, Comet pulls
into the  lead and gets his  first point. Of course,  since Dancer had
been in the  lead for the 139 seconds before  that, he has accumulated
139 points by the 140th second.

After the 1000th second, Dancer has accumulated 689 points, while poor
Comet,  our old  champion,  only has  312. So,  with  the new  scoring
system, Dancer would win (if the race ended at 1000 seconds).

Again given the descriptions of  each reindeer (in your puzzle input),
after exactly 2503 seconds, how  many points does the winning reindeer
have?

#+begin_src fennel -n :session d1514 :exports both
(fn in-motion? [t0 t1 t2]
  (<= 1 (% t0 (+ t1 t2)) t1))

(fn update-distance [x time]
  (when (in-motion? time (. x :m) (. x :s))
    (tset x :d (+ (. x :km) (or (. x :d) 0)))))

(fn award-points [x dist]
  (when (= dist (. x :d))
    (tset x :p (+ 1 (or (. x :p) 0)))))

(fn solve2 [input maxtime]
  (let [xs (lume.map input read-line)]
    (for [i 1 maxtime]
      (lume.each xs #(update-distance $ i))
      (let [dist (aoc.table-max (lume.map xs #(. $ :d)))]
        (lume.each xs #(award-points $ dist))))
    (aoc.table-max (lume.map xs #(. $ :p)))))

(fn test2 [expected input]
  (assert (= expected (solve2 input 1000))))

(test2 689 test-input)

(solve2 (aoc.string-from "2015/14.inp") 2503)
#+end_src

#+RESULTS:
: 1084


** DONE Day 15.1

Today, you set out on the  task of perfecting your milk-dunking cookie
recipe. All you have to do is find the right balance of ingredients.

Your recipe leaves room for  exactly 100 teaspoons of ingredients. You
make a list  of the remaining ingredients you could  use to finish the
recipe (your puzzle input) and their properties per teaspoon:
- capacity (how well it helps the cookie absorb milk)
- durability (how well it keeps the cookie intact when full of milk)
- flavor (how tasty it makes the cookie)
- texture (how it improves the feel of the cookie)
- calories (how many calories it adds to the cookie)

You can only measure ingredients in whole-teaspoon amounts accurately,
and you have to  be accurate so you can reproduce  your results in the
future. The total score of a cookie  can be found by adding up each of
the  properties  (negative  totals  become  0)  and  then  multiplying
together everything except calories.

For instance, suppose you have these two ingredients:

#+begin_example
Butterscotch: capacity -1, durability -2, flavor 6, texture 3, calories 8
Cinnamon: capacity 2, durability 3, flavor -2, texture -1, calories 3
#+end_example

Then, choosing to use 44 teaspoons of butterscotch and 56 teaspoons of
cinnamon (because the  amounts of each ingredient must add  up to 100)
would result in a cookie with the following properties:
- A capacity of 44*-1 + 56*2 = 68
- A durability of 44*-2 + 56*3 = 80
- A flavor of 44*6 + 56*-2 = 152
- A texture of 44*3 + 56*-1 = 76

Multiplying these together (68 * 80  * 152 * 76, ignoring calories for
now) results  in a total  score of 62842880,  which happens to  be the
best score  possible given  these ingredients.  If any  properties had
produced a negative total, it  would have instead become zero, causing
the whole score to multiply to zero.

Given the ingredients in your kitchen and their properties, what is
the total score of the highest-scoring cookie you can make?

#+begin_src fennel -n :session d1515 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-lines [lines]
  (let [res []]
    (each [_ line (ipairs lines)]
      (case (aoc.string-split line " ")
        [i "capacity" c "durability" d "flavor" f "texture" t "calories" cl]
        (table.insert res
                      {:ing (string.sub i 1 -2)
                       :cap (tonumber (string.sub c 1 -2))
                       :dur (tonumber (string.sub d 1 -2))
                       :fla (tonumber (string.sub f 1 -2))
                       :tex (tonumber (string.sub t 1 -2))
                       :cal (tonumber cl)})
        _ (print (.. "No match found for " line))))
    res))

(fn score-ingredient [n x]
  [(* n (. x :cap))
   (* n (. x :dur))
   (* n (. x :fla))
   (* n (. x :tex))
   (* n (. x :cal))])

(fn score-recipe [xs ?cals]
  (let [ys (lume.map xs #(score-ingredient (. $ 1) (. $ 2)))
        zs (aoc.table-column-sum ys)
        cal (table.remove zs)]
    (if ?cals
        (if (= ?cals cal) 
            (-> zs
                (lume.map #(if (< 0 $) $ 0))
                (lume.reduce #(* $1 $2)))
            0)
        (-> zs
            (lume.map #(if (< 0 $) $ 0))
            (lume.reduce #(* $1 $2))))))

(fn solve [input ?cal]
  (let [xs (read-lines input)
        res []]
    (for [i 1 100]
      (for [j 1 (- 100 i)]
        (for [k 1 (- 100 i j)]
          (table.insert res
           (score-recipe [[i (. xs 1)] [j (. xs 2)] [k (. xs 3)]
                          [(- 100 i j k) (. xs 4)]] ?cal)))))
    (aoc.table-max (lume.filter res #(< 0 $)))))

(solve (aoc.string-from "2015/15.inp"))
#+end_src

#+RESULTS:
: 21367368


** DONE Day 15.2

Your cookie  recipe becomes  wildly popular! Someone  asks if  you can
make another recipe that has exactly  500 calories per cookie (so they
can use it as a meal replacement). Keep the rest of your award-winning
process  the  same  (100  teaspoons, same  ingredients,  same  scoring
system).

For example, given the ingredients  above, if you had instead selected
40 teaspoons of butterscotch and 60 teaspoons of cinnamon (which still
adds to 100), the total calorie count  would be 40*8 + 60*3 = 500. The
total score would go down, though:  only 57600000, the best you can do
in such trying circumstances.

Given the  ingredients in your  kitchen and their properties,  what is
the total  score of  the highest-scoring  cookie you  can make  with a
calorie total of 500?

#+begin_src fennel -n :session d1515 :exports both
(solve (aoc.string-from "2015/15.inp") 500)
#+end_src

#+RESULTS:
: 1766400

** DONE Day 16.1

Your Aunt Sue has  given you a wonderful gift, and  you'd like to send
her a thank you card. However,  there's a small problem: she signed it
"From, Aunt Sue".

You have 500 Aunts named "Sue".

So, to avoid sending the card to  the wrong person, you need to figure
out  which Aunt  Sue  (which you  conveniently number  1  to 500,  for
sanity) gave  you the gift.  You open the  present and, as  luck would
have it,  good ol' Aunt  Sue got you a  My First Crime  Scene Analysis
Machine! Just what you wanted. Or needed, as the case may be.

The  My First  Crime Scene  Analysis  Machine (MFCSAM  for short)  can
detect a few specific compounds in a given sample, as well as how many
distinct  kinds  of  those  compounds  there  are.  According  to  the
instructions, these are what the MFCSAM can detect:
- children, by human DNA age analysis.
- cats. It doesn't differentiate individual breeds.
- Several seemingly random breeds of dog: samoyeds, pomeranians,
  akitas, and vizslas.
- goldfish. No other kinds of fish.
- trees, all in one group.
- cars, presumably by exhaust or gasoline or something.
- perfumes, which is handy, since many of your Aunts Sue wear a few
  kinds.
  
In  fact, many  of your  Aunts Sue  have many  of these.  You put  the
wrapping from the gift into the  MFCSAM. It beeps inquisitively at you
a few times and then prints out a message on ticker tape:

#+begin_example
children: 3
cats: 7
samoyeds: 2
pomeranians: 3
akitas: 0
vizslas: 0
goldfish: 5
trees: 3
cars: 2
perfumes: 1
#+end_example

You  make a  list  of the  things  you can  remember  about each  Aunt
Sue. Things  missing from  your list  aren't zero  - you  simply don't
remember the value.

What is the number of the Sue that got you the gift?

#+begin_src fennel -n :session d1516 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-input [input]
  (let [res []]
    (each [_ line (ipairs input)]
      (case (aoc.string-split line " ")
       ["Sue" n p1 v1 p2 v2 p3 v3]
       (table.insert res
        {:n (tonumber (string.sub n 1 -2))
         (string.sub p1 1 -2) (tonumber (string.sub v1 1 -2))
         (string.sub p2 1 -2) (tonumber (string.sub v2 1 -2))
         (string.sub p3 1 -2) (tonumber v3)})
       _ (print (.. "No match for " line))))
    res))

(fn pred [xs k v]
  (let [res (. xs k)]
    (if (= nil res) true
        (= v res) true
        false)))

(fn solve [input]
  (-> input
      (read-input)
      (lume.filter #(pred $ :children 3))
      (lume.filter #(pred $ :cats 7))
      (lume.filter #(pred $ :samoyeds 2))
      (lume.filter #(pred $ :pomeranians 3))
      (lume.filter #(pred $ :akitas 0))
      (lume.filter #(pred $ :vizslas 0))
      (lume.filter #(pred $ :goldfish 5))
      (lume.filter #(pred $ :trees 3))
      (lume.filter #(pred $ :cars 2))
      (lume.filter #(pred $ :perfumes 1))
      (. 1)
      (. :n)))

(solve (aoc.string-from "2015/16.inp"))
#+end_src

#+RESULTS:
: 373

** DONE Day 16.2

As you're about to send the  thank you note, something in the MFCSAM's
instructions  catches  your  eye.   Apparently,  it  has  an  outdated
[[https://www.youtube.com/watch?v=RXJKdh1KZ0w][retroencabulator]],  and so  the  output from  the  machine isn't  exact
values - some of them indicate ranges.

In particular,  the =cats= and  =trees= readings indicates that  there are
_greater than_ that many (due to  the unpredictable nuclear decay of cat
dander and tree  pollen), while the =pomeranians=  and =goldfish= readings
indicate  that there  are  _fewer than_  that many  (due  to the  modial
interaction of magnetoreluctance).

What is the number of the real Aunt Sue?

#+begin_src fennel -n :session d1516 :exports both
(fn pred2 [xs k v]
  (let [res (. xs k)]
    (if (= nil res) true
        (< v res) true
        false)))

(fn pred3 [xs k v]
  (let [res (. xs k)]
    (if (= nil res) true
        (> v res) true
        false)))

(fn solve2 [input]
  (-> input
      (read-input)
      (lume.filter #(pred $ :children 3))
      (lume.filter #(pred2 $ :cats 7))
      (lume.filter #(pred $ :samoyeds 2))
      (lume.filter #(pred3 $ :pomeranians 3))
      (lume.filter #(pred $ :akitas 0))
      (lume.filter #(pred $ :vizslas 0))
      (lume.filter #(pred3 $ :goldfish 5))
      (lume.filter #(pred2 $ :trees 3))
      (lume.filter #(pred $ :cars 2))
      (lume.filter #(pred $ :perfumes 1))
      (. 1)
      (. :n)))

(solve2 (aoc.string-from "2015/16.inp"))
#+end_src

#+RESULTS:
: 260


** DONE Day 17.1

The elves bought too much eggnog again  - 150 liters this time. To fit
it all  into your refrigerator,  you'll need  to move it  into smaller
containers. You take  an inventory of the capacities  of the available
containers.

For example, suppose you have containers of  size 20, 15, 10, 5, and 5
liters. If you need to store 25 liters, there are four ways to do it:
- 15 and 10
- 20 and 5 (the first 5)
- 20 and 5 (the second 5)
- 15, 5, and 5

Filling all containers entirely, how many different combinations of
containers can exactly fit all 150 liters of eggnog?

#+begin_src fennel -n :session d1517 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))
(local test-input ["20" "15" "10" "5" "5"])

(fn solve [input total]
  (-> input
      (lume.map tonumber)
      (aoc.powerset)
      (lume.filter #(= total (aoc.table-sum $)))
      (length)))

(fn test [expected input total]
  (assert (= expected (solve input total))))

(test 4 test-input 25)

(solve (aoc.string-from "2015/17.inp") 150)
#+end_src

#+RESULTS:
: 1304

** DONE Day 17.2

While playing with all the containers  in the kitchen, another load of
eggnog arrives! The shipping and receiving department is requesting as
many containers as you can spare.

Find the  minimum number of  containers that  can exactly fit  all 150
liters of eggnog. How many different  ways can you fill that number of
containers and still hold exactly 150 litres?

In the example above, the minimum  number of containers was two. There
were three ways  to use that many containers, and  so the answer there
would be 3.

#+begin_src fennel -n :session d1517 :exports both
(fn solve2 [input total]
  (let [xs (lume.map input #(tonumber $))
        ys (aoc.powerset xs)
        zs (lume.filter ys #(= total (aoc.table-sum $)))
        len (lume.map zs (fn [z] (length z)))]
    (let [min (aoc.table-min len)]
      (lume.count zs (fn [z] (= min (# z)))))))

(fn test2 [expected input max]
  (assert (= expected (solve2 input max))))

(test2 3 test-input 25)

(solve2 (aoc.string-from "2015/17.inp") 150)
#+end_src

#+RESULTS:
: 18


** DONE Day 18.1

After the million lights incident,  the fire code has gotten stricter:
now, at  most ten thousand lights  are allowed. You arrange  them in a
100x100 grid.

Never one to  let you down, Santa again mails  you instructions on the
ideal lighting configuration. With so few lights, he says, you'll have
to resort to animation.

Start by  setting your  lights to  the included  initial configuration
(your puzzle input). A # means "on", and a . means "off".

Then, animate  your grid in  steps, where  each step decides  the next
configuration  based  on the  current  one.  Each light's  next  state
(either on or off) depends on its current state and the current states
of the  eight lights adjacent  to it (including diagonals).  Lights on
the  edge of  the  grid might  have fewer  than  eight neighbors;  the
missing ones always count as "off".

For example,  in a  simplified 6x6  grid, the light  marked A  has the
neighbors numbered 1 through 8, and the light marked B, which is on an
edge, only has the neighbors marked 1 through 5:

#+begin_example
1B5...
234...
......
..123.
..8A4.
..765.
#+end_example

The state a light  should have next is based on  its current state (on
or off) plus the number of neighbors that are on:
- A light which is on stays on when 2 or 3 neighbors are on, and turns
  off otherwise.
- A light which is off turns on if exactly 3 neighbors are on, and
  stays off otherwise.
  
All of  the lights update  simultaneously; they all consider  the same
current state before moving to the next.

Here's a few steps from an example configuration of another 6x6 grid:

#+begin_example
Initial state:
.#.#.#
...##.
#....#
..#...
#.#..#
####..

After 1 step:
..##..
..##.#
...##.
......
#.....
#.##..

After 2 steps:
..###.
......
..###.
......
.#....
.#....

After 3 steps:
...#..
......
...#..
..##..
......
......

After 4 steps:
......
......
..##..
..##..
......
......
#+end_example

After 4 steps, this example has four lights on.

In your grid of 100x100  lights, given your initial configuration, how
many lights are on after 100 steps?

#+begin_src fennel -n :session d1518 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(local test-input
       [".#.#.#"
        "...##."
        "#....#"
        "..#..."
        "#.#..#"
        "####.."])

(fn dothash2num [s]
  (let [xs (aoc.string-toarray s)]
    (lume.map xs (fn [x] (if (= "#" x) 1 0)))))

(fn animate [xs]
  (let [res (aoc.matrix-clone xs)]
    (for [i 1 (# xs)]
      (for [j 1 (# (. xs i))]
        (let [ns (aoc.matrix-adjvals xs i j)
              nsum (aoc.table-sum ns)]
          (aoc.matrix-swap
           res j i
           (case (. (. xs i) j)
             0 (if (= 3 nsum) 1 0)
             1 (if (or (= 2 nsum)
                       (= 3 nsum)) 1 0))))))
    res))

(fn solve [input steps]
  (var xs (lume.map input dothash2num))
  (for [i 1 steps]
    (set xs (animate xs)))
  (aoc.table-sum xs))

(fn test [expected input steps]
  (assert (= expected (solve input steps))))

(test 4 test-input 4)

(solve (aoc.string-from "2015/18.inp") 100)
#+end_src

#+RESULTS:
: 814

** DONE Day 18.2

You flip the  instructions over; Santa goes on to  point out that this
is all just  an implementation of [[https://en.wikipedia.org/wiki/Conway's_Game_of_Life][Conway's Game of  Life]]. At least, it
was, until you  notice that something's wrong with the  grid of lights
you bought: four lights, one in each corner, are =stuck on= and can't be
turned off. The example above will actually run like this:

#+begin_example
Initial state:
##.#.#
...##.
#....#
..#...
#.#..#
####.#

After 1 step:
#.##.#
####.#
...##.
......
#...#.
#.####

After 2 steps:
#..#.#
#....#
.#.##.
...##.
.#..##
##.###

After 3 steps:
#...##
####.#
..##.#
......
##....
####.#

After 4 steps:
#.####
#....#
...#..
.##...
#.....
#.#..#

After 5 steps:
##.###
.##..#
.##...
.##...
#.#...
##...#
#+end_example

After 5 steps, this example now has 17 lights on.

In your grid of 100x100  lights, given your initial configuration, but
with the four corners  always in the =on= state, =how  many lights are on=
after 100 steps?

#+begin_src fennel -n :session d1518 :exports both
(fn animate2 [xs]
  (let [res (aoc.matrix-clone xs)]
    (for [i 1 (# xs)]
      (for [j 1 (# (. xs i))]
        (let [ns (aoc.matrix-adjvals xs i j)
              nsum (aoc.table-sum ns)]
          (aoc.matrix-swap
           res j i
           (if (= 3 (# ns)) 1 ;; corners have 3 neighbours
               (case (. (. xs i) j)
                 0 (if (= 3 nsum) 1 0)
                 1 (if (or (= 2 nsum)
                           (= 3 nsum)) 1 0)))))))
    res))

(fn reset-corners [xs v]
  (aoc.matrix-swap xs 1 1 v)
  (aoc.matrix-swap xs (# (. xs 1)) 1 v)
  (aoc.matrix-swap xs 1 (# xs) v)
  (aoc.matrix-swap xs (# (. xs 1)) (# xs) v)
  xs)

(fn solve2 [input steps]
  (var xs (reset-corners (lume.map input dothash2num) 1))
  (for [i 1 steps]
    (set xs (animate2 xs)))
  (aoc.table-sum xs))

(fn test2 [expected input steps]
  (assert (= expected (solve2 input steps))))

(test2 17 test-input 5)

(solve2 (aoc.string-from "2015/18.inp") 100)
#+end_src

#+RESULTS:
: 924


** DONE Day 19.1

Rudolph the  Red-Nosed Reindeer is  sick! His nose isn't  shining very
brightly, and he needs medicine.

Red-Nosed Reindeer biology isn't  similar to regular reindeer biology;
Rudolph  is   going  to  need  custom-made   medicine.  Unfortunately,
Red-Nosed  Reindeer  chemistry  isn't   similar  to  regular  reindeer
chemistry, either.

The  North  Pole  is  equipped   with  a  Red-Nosed  Reindeer  nuclear
fusion/fission plant,  capable of constructing any  Red-Nosed Reindeer
molecule you need.  It works by starting with some  input molecule and
then doing  a series of replacements,  one per step, until  it has the
right molecule.

However,  the  machine   has  to  be  calibrated  before   it  can  be
used. Calibration  involves determining  the number of  molecules that
can be generated in one step from a given starting point.

For  example,  imagine  a  simpler  machine  that  supports  only  the
following replacements:

#+begin_example
H => HO
H => OH
O => HH
#+end_example

Given  the replacements  above and  starting with  HOH, the  following
molecules could be generated:
- HOOH (via H => HO on the first H).
- HOHO (via H => HO on the second H).
- OHOH (via H => OH on the first H).
- HOOH (via H => OH on the second H).
- HHHH (via O => HH).

So, in  the example above, there  are 4 distinct molecules  (not five,
because HOOH  appears twice) after  one replacement from  HOH. Santa's
favorite molecule, HOHOHO, can become  7 distinct molecules (over nine
replacements: six from H, and three from O).

The   machine   replaces   without    regard   for   the   surrounding
characters. For example, given the string  H2O, the transition H => OO
would result in OO2O.

Your puzzle input  describes all of the possible  replacements and, at
the bottom, the medicine molecule for  which you need to calibrate the
machine.  How many  distinct molecules  can be  created after  all the
different ways you can do one replacement on the medicine molecule?

#+begin_src fennel -n :session d1519 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn read-input [lines]
  (let [rules {}]
    (var mol "")
    (each [_ line (ipairs lines)]
      (case (aoc.string-split line " ")
        [m1 "=>" m2]
        (let [v (?. rules m1)]
          (if (= nil v)
              (tset rules m1 [m2])
              (table.insert v m2)))
        [molecule] (set mol molecule)
        "" nil))
    {:mol mol :rules rules}))

(fn string-gsubs [a b c r ?j]
  (let [(i res) (aoc.string-subs a b c ?j)]
    (if (= 0 i) r
        (do
          (table.insert r res)
          (string-gsubs a b c r i)))))

(fn transform [{: mol : rules}]
  (let [res {}]
    (each [_ k (ipairs (aoc.keys rules))]
      (each [_ v (ipairs (. rules k))]
        (lume.map (string-gsubs mol k v [])
                  #(tset res $ true))))
    (aoc.keys res)))

(fn solve [input]
  (-> input
      read-input
      transform
      length))

(solve (aoc.string-from "2015/19.inp"))
#+end_src

#+RESULTS:
: 518

** TODO Day 19.2                                                  :noexport:

Now that the machine is calibrated, you're ready to begin molecule
fabrication.

Molecule fabrication always begins with just a single electron, e, and
applying  replacements  one at  a  time,  just  like the  ones  during
calibration.

For example, suppose you have the following replacements:

#+begin_example
e => H
e => O
H => HO
H => OH
O => HH
#+end_example

If  you'd like  to make  =HOH=,  you start  with  =e=, and  then make  the
following replacements:
- =e => O= to get =O=
- =O => HH= to get =HH=
- =H => OH= (on the second H) to get =HOH=

So,  you could  make =HOH=  after =3  steps=.  Santa's  favorite molecule,
=HOHOHO=, can be made in =6 steps=.

How  long will  it take  to make  the medicine?   Given the  available
=replacements= and the  =medicine molecule= in your puzzle  input, what is
the =fewest number of steps= to go from =e= to the medicine molecule?
** DONE Day 20.1

To keep the Elves busy, Santa  has them deliver some presents by hand,
door-to-door.  He  sends  them  down a  street  with  infinite  houses
numbered sequentially: 1, 2, 3, 4, 5, and so on.

Each Elf  is assigned a number,  too, and delivers presents  to houses
based on that number:
- The first Elf (number 1) delivers presents to every house: 1, 2, 3,
  4, 5, ....
- The second Elf (number 2) delivers presents to every second house:
  2, 4, 6, 8, 10, ....
- Elf number 3 delivers presents to every third house: 3, 6, 9, 12,
  15, ....
  
There are  infinitely many Elves,  numbered starting with 1.  Each Elf
delivers presents equal to ten times his or her number at each house.

So, the first nine houses on the street end up like this:

#+begin_example
House 1 got 10 presents.
House 2 got 30 presents.
House 3 got 40 presents.
House 4 got 70 presents.
House 5 got 60 presents.
House 6 got 120 presents.
House 7 got 80 presents.
House 8 got 150 presents.
House 9 got 130 presents.
#+end_example

The first house gets  10 presents: it is visited only  by Elf 1, which
delivers 1  * 10  = 10  presents. The fourth  house gets  70 presents,
because it is visited by  Elves 1, 2, and 4, for a total  of 10 + 20 +
40 = 70 presents.

What is the lowest house number of  the house to get at least =29000000=
presents?

#+begin_src fennel -n :session d1520 :exports both
(fn count-presents [house]
  (var sum 0)
  (for [elf 1 house]
    (when (= 0 (% house elf))
      (set sum (+ sum (* 10 elf)))))
  sum)

(fn solve [input]
  (var res false)
  (var house 1)
  (while (not res)
    (if (<= input (count-presents house))
        (set res house)
        (set house (+ 1 house))))
  res)

(solve 29000000)
#+end_src

#+RESULTS:
: 665280

** DONE Day 20.2

The  Elves decide  they  don't want  to visit  an  infinite number  of
houses. Instead,  each Elf will  stop after delivering presents  to 50
houses. To  make up for it,  they decide to deliver  presents equal to
eleven times their number at each house.

With these changes, what is the new lowest house number of the house
to get at least as many presents as the number in your puzzle input?

#+begin_src fennel -n :session d1520 :exports both
(fn count-presents2 [house]
  (var sum 0)
  (for [elf 1 house]
    (when (and (= 0 (% house elf))
               (<= (/ house elf) 50))
      (set sum (+ sum (* 11 elf)))))
  sum)

(fn solve2 [input]
  (var res false)
  (var house 1)
  (while (not res)
    (if (<= input (count-presents2 house))
        (set res house)
        (set house (+ 1 house))))
  res)

(solve2 29000000)
#+end_src

#+RESULTS:
: 705600

** DONE Day 21.1

Little Henry Case got a new video game for Christmas. It's an RPG, and
he's stuck on  a boss. He needs  to know what equipment to  buy at the
shop. He hands you the controller.

In this  game, the player  (you) and the  enemy (the boss)  take turns
attacking.  The player  always  goes first.  Each  attack reduces  the
opponent's hit points by at least 1. The first character at or below 0
hit points loses.

Damage  dealt by  an attacker  each turn  is equal  to the  attacker's
damage score minus the defender's armor score. An attacker always does
at least 1  damage. So, if the  attacker has a damage score  of 8, and
the  defender has  an  armor score  of  3, the  defender  loses 5  hit
points. If the defender had an  armor score of 300, the defender would
still lose 1 hit point.

Your damage  score and  armor score  both start at  zero. They  can be
increased by  buying items  in exchange  for gold.  You start  with no
items and have as much gold as you need. Your total damage or armor is
equal to the sum  of those stats from all of your  items. You have 100
hit points.

Here is what the item shop is selling:

#+begin_example
Weapons:    Cost  Damage  Armor
Dagger        8     4       0
Shortsword   10     5       0
Warhammer    25     6       0
Longsword    40     7       0
Greataxe     74     8       0

Armor:      Cost  Damage  Armor
Leather      13     0       1
Chainmail    31     0       2
Splintmail   53     0       3
Bandedmail   75     0       4
Platemail   102     0       5

Rings:      Cost  Damage  Armor
Damage +1    25     1       0
Damage +2    50     2       0
Damage +3   100     3       0
Defense +1   20     0       1
Defense +2   40     0       2
Defense +3   80     0       3
#+end_example

You must buy exactly one  weapon; no dual-wielding. Armor is optional,
but you can't  use more than one.  You can buy 0-2 rings  (at most one
for each hand). You must use any  items you buy. The shop only has one
of each item, so you can't buy, for example, two rings of Damage +3.

For example, suppose you have 8 hit points, 5 damage, and 5 armor, and
that the boss has 12 hit points, 7 damage, and 2 armor:
- The player deals 5-2 = 3 damage; the boss goes down to 9 hit points.
- The boss deals 7-5 = 2 damage; the player goes down to 6 hit points.
- The player deals 5-2 = 3 damage; the boss goes down to 6 hit points.
- The boss deals 7-5 = 2 damage; the player goes down to 4 hit points.
- The player deals 5-2 = 3 damage; the boss goes down to 3 hit points.
- The boss deals 7-5 = 2 damage; the player goes down to 2 hit points.
- The player deals 5-2 = 3 damage; the boss goes down to 0 hit points.

In this scenario, the player wins! (Barely.)

You have  100 hit points. The  boss's actual stats are  in your puzzle
input. What is  the least amount of  gold you can spend  and still win
the fight?

#+begin_src fennel -n :session d1521 :exports both
(local lume (require :lib.lume))
(local aoc (require :lib.aoc))

(fn play2win [attacker defender]
  (if (<= (. attacker :hits) 0)
      defender
      (let [damage (- (. attacker :damage)
                      (. defender :armor))]
        (tset defender :hits (- (. defender :hits)
                                (if (<= damage 0) 1 damage)))
        (play2win defender attacker))))

(fn game [boss inventory score]
  (let [weap (. inventory :weapons)
        arm (. inventory :armor)
        rin (. inventory :rings)
        res []]
    (for [i 1 (# weap)]
      (for [j 1 (# arm)]
        (for [k 0 (# rin)]
          (for [l 0 (# rin)]
            (when (or (not= k l) (= 0 k l))
              (let [armor (+ (. (. arm j) :armor)
                             (or (?. (?. rin k) :armor) 0)
                             (or (?. (?. rin l) :armor) 0))
                    damage (+ (. (. weap i) :damage)
                              (or (?. (?. rin k) :damage) 0)
                              (or (?. (?. rin l) :damage) 0))
                    cost (+ (. (. weap i) :cost)
                            (. (. arm j) :cost)
                            (or (?. (?. rin k) :cost) 0)
                            (or (?. (?. rin l) :cost) 0))
                    newboss {:hits (. boss :hits)
                             :damage (. boss :damage)
                             :armor (. boss :armor)
                             :cost 0}]
                (table.insert
                 res 
                 (score {:hits 100 :armor armor :damage damage :cost cost} newboss))))))))
    res))

(fn solve [boss inventory]
  (-> (game boss inventory play2win)
      (lume.filter #(< 0 (. $ :cost)))
      (lume.map #(. $ :cost))
      (aoc.table-min)))

(local weapons
       [{:name "dagger" :cost 8 :damage 4 :armor 0}
        {:name "shortsword" :cost 10 :damage 5 :armor 0}
        {:name "warhammer" :cost 25 :damage 6 :armor 0}
        {:name "longsword" :cost 40 :damage 7 :armor 0}
        {:name "greataxe" :cost 74 :damage 8 :armor 0}])

(local armor
       [{:name "leather" :cost 13 :damage 0 :armor 1}
        {:name "chainmail" :cost 31 :damage 0 :armor 2}
        {:name "splintmail" :cost 53 :damage 0 :armor 3}
        {:name "bandedmail" :cost 75 :damage 0 :armor 4}
        {:name "platemail" :cost 102 :damage 0 :armor 5}])

(local rings
       [{:name "Damage +1" :cost 25 :damage 1 :armor 0}
        {:name "Damage +2" :cost 50 :damage 2 :armor 0}
        {:name "Damage +3" :cost 100 :damage 3 :armor 0}
        {:name "Defense +1" :cost 20 :damage 0 :armor 1}
        {:name "Defense +2" :cost 40 :damage 0 :armor 2}
        {:name "Defense +3" :cost 80 :damage 0 :armor 3}])

(solve {:hits 103 :damage 9 :armor 2 :cost 0}
       {:weapons weapons :armor armor :rings rings})
#+end_src

#+RESULTS:
: 121


** DONE Day 21.2

Turns out  the shopkeeper is working  with the boss, and  can persuade
you to buy  whatever items he wants. The other  rules still apply, and
he still only has one of each item.

What is  the most  amount of  gold you  can spend  and still  lose the
fight?

#+begin_src fennel -n :session d1521 :exports both
(fn play2loose [attacker defender]
  (if (<= (. attacker :hits) 0)
      attacker
      (let [damage (- (. attacker :damage)
                      (. defender :armor))]
        (tset defender :hits (- (. defender :hits)
                                (if (<= damage 0) 1 damage)))
        (play2loose defender attacker))))

(fn solve2 [boss inventory]
  (-> (game boss inventory play2loose)
      (lume.filter #(< 0 (. $ :cost)))
      (lume.map #(. $ :cost))
      (aoc.table-max)))

(solve2 {:hits 103 :damage 9 :armor 2 :cost 0}
        {:weapons weapons :armor armor :rings rings})
#+end_src

#+RESULTS:
: 201

** TODO Day 22.1                                                  :noexport:

Little Henry Case decides that  defeating bosses with swords and stuff
is boring. Now he's playing the game with a wizard. Of course, he gets
stuck on another boss and needs your help again.

In this  version, combat still proceeds  with the player and  the boss
taking alternating turns.  The player still goes  first. Now, however,
you don't  get any  equipment; instead,  you must  choose one  of your
spells to cast. The first character at or below 0 hit points loses.

Since you're  a wizard,  you don't  get to wear  armor, and  you can't
attack normally. However,  since you do magic  damage, your opponent's
armor  is ignored,  and  so the  boss effectively  has  zero armor  as
well. As  before, if armor (from  a spell, in this  case) would reduce
damage below  1, it  becomes 1  instead - that  is, the  boss' attacks
always deal at least 1 damage.

On each of your turns, you must  select one of your spells to cast. If
you cannot afford  to cast any spell, you lose.  Spells cost mana; you
start with 500  mana, but have no maximum limit.  You must have enough
mana to  cast a spell, and  its cost is immediately  deducted when you
cast it.  Your spells  are Magic Missile,  Drain, Shield,  Poison, and
Recharge.
- Magic Missile costs 53 mana. It instantly does 4 damage.
- Drain costs 73 mana. It instantly does 2 damage and heals you for 2
  hit points.
- Shield costs 113 mana. It starts an effect that lasts for 6
  turns. While it is active, your armor is increased by 7.
- Poison costs 173 mana. It starts an effect that lasts for 6
  turns. At the start of each turn while it is active, it deals the
  boss 3 damage.
- Recharge costs 229 mana. It starts an effect that lasts for 5
  turns. At the start of each turn while it is active, it gives you
  101 new mana.
  
Effects all work the same way. Effects  apply at the start of both the
player's turns and  the boss' turns. Effects are created  with a timer
(the number of turns they last); at the start of each turn, after they
apply any effect  they have, their timer is decreased  by one. If this
decreases the timer to zero, the  effect ends. You cannot cast a spell
that would start  an effect which is already  active. However, effects
can be started on the same turn they end.

For example,  suppose the player has  10 hit points and  250 mana, and
that the boss has 13 hit points and 8 damage:

#+begin_example
-- Player turn --
- Player has 10 hit points, 0 armor, 250 mana
- Boss has 13 hit points
Player casts Poison.

-- Boss turn --
- Player has 10 hit points, 0 armor, 77 mana
- Boss has 13 hit points
Poison deals 3 damage; its timer is now 5.
Boss attacks for 8 damage.

-- Player turn --
- Player has 2 hit points, 0 armor, 77 mana
- Boss has 10 hit points
Poison deals 3 damage; its timer is now 4.
Player casts Magic Missile, dealing 4 damage.

-- Boss turn --
- Player has 2 hit points, 0 armor, 24 mana
- Boss has 3 hit points
Poison deals 3 damage. This kills the boss, and the player wins.
#+end_example

Now, suppose the same initial conditions,  except that the boss has 14
hit points instead:

#+begin_example
-- Player turn --
- Player has 10 hit points, 0 armor, 250 mana
- Boss has 14 hit points
Player casts Recharge.

-- Boss turn --
- Player has 10 hit points, 0 armor, 21 mana
- Boss has 14 hit points
Recharge provides 101 mana; its timer is now 4.
Boss attacks for 8 damage!

-- Player turn --
- Player has 2 hit points, 0 armor, 122 mana
- Boss has 14 hit points
Recharge provides 101 mana; its timer is now 3.
Player casts Shield, increasing armor by 7.

-- Boss turn --
- Player has 2 hit points, 7 armor, 110 mana
- Boss has 14 hit points
Shield's timer is now 5.
Recharge provides 101 mana; its timer is now 2.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 1 hit point, 7 armor, 211 mana
- Boss has 14 hit points
Shield's timer is now 4.
Recharge provides 101 mana; its timer is now 1.
Player casts Drain, dealing 2 damage, and healing 2 hit points.

-- Boss turn --
- Player has 3 hit points, 7 armor, 239 mana
- Boss has 12 hit points
Shield's timer is now 3.
Recharge provides 101 mana; its timer is now 0.
Recharge wears off.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 2 hit points, 7 armor, 340 mana
- Boss has 12 hit points
Shield's timer is now 2.
Player casts Poison.

-- Boss turn --
- Player has 2 hit points, 7 armor, 167 mana
- Boss has 12 hit points
Shield's timer is now 1.
Poison deals 3 damage; its timer is now 5.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 1 hit point, 7 armor, 167 mana
- Boss has 9 hit points
Shield's timer is now 0.
Shield wears off, decreasing armor by 7.
Poison deals 3 damage; its timer is now 4.
Player casts Magic Missile, dealing 4 damage.

-- Boss turn --
- Player has 1 hit point, 0 armor, 114 mana
- Boss has 2 hit points
Poison deals 3 damage. This kills the boss, and the player wins.
#+end_example

You start  with 50 hit points  and 500 mana points.  The boss's actual
stats are in your  puzzle input. What is the least  amount of mana you
can  spend and  still win  the fight?  (Do not  include mana  recharge
effects as "spending" negative mana.)

** TODO Day 22.2                                                  :noexport:

** DONE Day 23.1

Little Jane Marie just got her  very first computer for Christmas from
some unknown  benefactor. It  comes with  instructions and  an example
program, but  the computer  itself seems  to be  malfunctioning. She's
curious what the program does, and would like you to help her run it.

The manual explains  that the computer supports two  registers and six
instructions   (truly,  it   goes   on  to   remind   the  reader,   a
state-of-the-art technology).  The registers  are named  a and  b, can
hold  any non-negative  integer,  and begin  with a  value  of 0.  The
instructions are as follows:
- hlf r sets register r to half its current value, then continues with
  the next instruction.
- tpl r sets register r to triple its current value, then continues
  with the next instruction.
- inc r increments register r, adding 1 to it, then continues with the
  next instruction.
- jmp offset is a jump; it continues with the instruction offset away
  relative to itself.
- jie r, offset is like jmp, but only jumps if register r is even
  ("jump if even").
- jio r, offset is like jmp, but only jumps if register r is 1 ("jump
  if one", not odd).
  
All  three jump  instructions work  with  an offset  relative to  that
instruction. The  offset is  always written  with a prefix  + or  - to
indicate   the   direction  of   the   jump   (forward  or   backward,
respectively). For example, jmp +1 would simply continue with the next
instruction,  while jmp  +0  would continuously  jump  back to  itself
forever.

The program exits when it tries  to run an instruction beyond the ones
defined.

For example,  this program sets  a to  2, because the  jio instruction
causes it to skip the tpl instruction:

#+begin_example
inc a
jio a, +2
tpl a
inc a
#+end_example

What is the value in register b when the program in your puzzle input
is finished executing?

#+begin_src fennel -n :session d1523 :exports both
(local aoc (require :lib.aoc))

(fn hlf [xs x]
  (tset xs x (math.floor (/ (. xs x) 2)))
  1)

(fn tpl [xs x]
  (tset xs x (* 3 (. xs x)))
  1)

(fn inc [xs x]
  (tset xs x (+ 1 (. xs x)))
  1)

(fn jmp [offset]
  (tonumber offset))

(fn jie [xs x offset]
  (if (= 0 (% (. xs x) 2))
    (jmp offset)
    1))

(fn jio [xs x offset]
  (if (= 1 (. xs x))
    (jmp offset)
    1))

(fn eval [line xs]
  (case (aoc.string-split line " ")
    ["hlf" r] (hlf xs r)
    ["inc" r] (inc xs r)
    ["jie" re of] (jie xs (string.sub re 1 -2) of)
    ["jio" re of] (jio xs (string.sub re 1 -2) of)
    ["jmp" of] (jmp of)
    ["tpl" r] (tpl xs r)
    _ (print (.. "No match for " line))))

(fn solve [input res reg]
  (let [count (# input)]
    (var cur 1)
    (while (<= cur count)
      (set cur (+ cur (eval (. input cur) res))))
    (. res reg)))

(fn test [expected input]
  (assert (= expected (solve input {:a 0 :b 0} :a))))

(test 2 ["inc a" "jio a, +2" "tpl a" "inc a"])

(solve (aoc.string-from "2015/23.inp") {:a 0 :b 0} :b)
#+end_src

#+RESULTS:
: 184

** DONE Day 23.2

The  unknown benefactor  is very  thankful for  releasi-- er,  helping
little Jane Marie  with her computer. Definitely not  to distract you,
what  is  the value  in  register  b  after  the program  is  finished
executing if register a starts as 1 instead?

#+begin_src fennel -n :session d1523 :exports both
(solve (aoc.string-from "2015/23.inp") {:a 1 :b 0} :b)
#+end_src

#+RESULTS:
: 231

** TODO Day 24.1                                                  :noexport:

It's Christmas Eve, and Santa is loading up the sleigh for this year's
deliveries.  However, there's  one  small problem:  he  can't get  the
sleigh to  balance. If it isn't  balanced, he can't defy  physics, and
nobody gets presents this year.

No pressure.

Santa has provided you a list of the weights of every package he needs
to fit on the sleigh. The packages  need to be split into three groups
of exactly  the same weight, and  every package has to  fit. The first
group goes in the passenger compartment  of the sleigh, and the second
and third go in containers on  either side. Only when all three groups
weigh exactly the same amount will  the sleigh be able to fly. Defying
physics has rules, you know!

Of course,  that's not  the only  problem. The first  group -  the one
going in the passenger compartment - needs as few packages as possible
so that Santa  has some legroom left over. It  doesn't matter how many
packages are in either of the other  two groups, so long as all of the
groups weigh the same.

Furthermore, Santa  tells you, if  there are multiple ways  to arrange
the packages such that the fewest possible are in the first group, you
need to choose the way where  the first group has the smallest quantum
entanglement to reduce the chance  of any "complications". The quantum
entanglement of a  group of packages is the product  of their weights,
that  is,  the   value  you  get  when  you   multiply  their  weights
together. Only  consider quantum entanglement  if the first  group has
the fewest possible number of packages  in it and all groups weigh the
same amount.

For example,  suppose you have ten  packages with weights 1  through 5
and 7 through 11. For this situation, some of the unique first groups,
their  quantum  entanglements,  and  a way  to  divide  the  remaining
packages are as follows:

#+begin_example
Group 1;             Group 2; Group 3
11 9       (QE= 99); 10 8 2;  7 5 4 3 1
10 9 1     (QE= 90); 11 7 2;  8 5 4 3
10 8 2     (QE=160); 11 9;    7 5 4 3 1
10 7 3     (QE=210); 11 9;    8 5 4 2 1
10 5 4 1   (QE=200); 11 9;    8 7 3 2
10 5 3 2   (QE=300); 11 9;    8 7 4 1
10 4 3 2 1 (QE=240); 11 9;    8 7 5
9 8 3      (QE=216); 11 7 2;  10 5 4 1
9 7 4      (QE=252); 11 8 1;  10 5 3 2
9 5 4 2    (QE=360); 11 8 1;  10 7 3
8 7 5      (QE=280); 11 9;    10 4 3 2 1
8 5 4 3    (QE=480); 11 9;    10 7 2 1
7 5 4 3 1  (QE=420); 11 9;    10 8 2
#+end_example

Of these, although 10 9 1  has the smallest quantum entanglement (90),
the  configuration with  only two  packages,  11 9,  in the  passenger
compartment gives Santa the most  legroom and wins. In this situation,
the   quantum   entanglement   for    the   ideal   configuration   is
therefore 99. Had there been two configurations with only two packages
in  the first  group, the  one with  the smaller  quantum entanglement
would be chosen.

What is the quantum entanglement of the first group of packages in the
ideal configuration?

** TODO Day 24.2                                                  :noexport:

** DONE Day 25.1

Merry Christmas! Santa  is booting up his weather  machine; looks like
you might get a white Christmas after all.

The weather  machine beeps! On  the console of  the machine is  a copy
protection message  asking you  to enter a  code from  the instruction
manual. Apparently, it refuses to run unless you give it that code. No
problem; you'll just look up the code in the--

"Ho ho ho", Santa ponders aloud. "I can't seem to find the manual."

You look  up the support number  for the manufacturer and  give them a
call. Good thing, too - that 49th star wasn't going to earn itself.

"Oh, that machine is quite old!",  they tell you. "That model went out
of support six minutes ago, and  we just finished shredding all of the
manuals. I bet we can find you the code generation algorithm, though."

After  putting you  on  hold for  twenty minutes  (your  call is  very
important to them,  it reminded you repeatedly), they  finally find an
engineer that remembers how the code system works.

The codes are  printed on an infinite sheet of  paper, starting in the
top-left corner. The  codes are filled in by  diagonals: starting with
the  first row  with  an empty  first  box, the  codes  are filled  in
diagonally  up  and to  the  right.  This  process repeats  until  the
infinite paper  is covered. So, the  first few codes are  filled in in
this order:

#+begin_example
   | 1   2   3   4   5   6  
---+---+---+---+---+---+---+
 1 |  1   3   6  10  15  21
 2 |  2   5   9  14  20
 3 |  4   8  13  19
 4 |  7  12  18
 5 | 11  17
 6 | 16
#+end_example

For example, the  12th code would be  written to row 4,  column 2; the
15th code would be written to row 1, column 5.

The voice on the  other end of the phone continues  with how the codes
are actually generated.  The first code is 20151125.  After that, each
code  is generated  by  taking  the previous  one,  multiplying it  by
252533,  and  then keeping  the  remainder  from dividing  that  value
by 33554393.

So, to find the second code (which  ends up in row 2, column 1), start
with  the  previous   value,  20151125.  Multiply  it   by  252533  to
get  5088824049625. Then,  divide  that by  33554393,  which leaves  a
remainder of 31916031. That remainder is the second code.

"Oh!", says the  voice. "It looks like  we missed a scrap  from one of
the manuals. Let me read it to you." You write down his numbers:

#+begin_example
   |    1         2         3         4         5         6
---+---------+---------+---------+---------+---------+---------+
 1 | 20151125  18749137  17289845  30943339  10071777  33511524
 2 | 31916031  21629792  16929656   7726640  15514188   4041754
 3 | 16080970   8057251   1601130   7981243  11661866  16474243
 4 | 24592653  32451966  21345942   9380097  10600672  31527494
 5 |    77061  17552253  28094349   6899651   9250759  31663883
 6 | 33071741   6796745  25397450  24659492   1534922  27995004
#+end_example

"Now remember", the voice continues, "that's not even all of the first
few numbers;  for example, you're  missing the  one at 7,1  that would
come before 6,2. But, it should be  enough to let your-- oh, it's time
for lunch! Bye!" The call disconnects.

Santa looks  nervous. Your  puzzle input contains  the message  on the
machine's console. What code do you give the machine?

#+begin_src fennel -n :session d1525 :exports both
(fn nth-code [n]
  (var res 20151125)
  (for [i 2 n]
    (set res (% (* 252533 res) 33554393)))
  res)

(fn ind2ord [x y]
  (let [xy (+ x y -1)]
    (+ y (math.floor (/ (* xy (- xy 1)) 2)))))

(fn xy-code [x y]
  (let [xy (ind2ord x y)]
    (nth-code xy)))

(fn solve [x y]
  (xy-code x y))

(solve 2981 3075)
#+end_src

#+RESULTS:
: 9132360

** TODO Day 25.2                                                  :noexport:

The   machine  springs   to  life,   then  falls   silent  again.   It
beeps.  "Insufficient  fuel",  the  console reads.  "Fifty  stars  are
required before proceeding. One star is available."

..."one star  is available"? You check  the fuel tank; sure  enough, a
lone star  sits at the  bottom, awaiting  its friends. Looks  like you
need to provide 49 yourself.

You don't have enough stars to start the machine, though. You need 5
more.


** Stats                                                          :noexport:

#+CAPTION: https://adventofcode.com/2015/stats
| 25 |  4 | ▉▉▉▉                                      |
| 24 |  4 | ▉▉▉▉                                      |
| 23 |  5 | ▉▉▉▉▉                                     |
| 22 |  4 | ▉▉▉▉                                      |
| 21 |  5 | ▉▉▉▉▉                                     |
| 20 |  5 | ▉▉▉▉▉                                     |
| 19 |  6 | ▉▉▉▉▉▉                                    |
| 18 |  6 | ▉▉▉▉▉▉                                    |
| 17 |  6 | ▉▉▉▉▉▉                                    |
| 16 |  7 | ▉▉▉▉▉▉▉                                   |
| 15 |  7 | ▉▉▉▉▉▉▉                                   |
| 14 |  7 | ▉▉▉▉▉▉▉                                   |
| 13 |  7 | ▉▉▉▉▉▉▉                                   |
| 12 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 11 |  8 | ▉▉▉▉▉▉▉▉                                  |
| 10 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
|  9 |  9 | ▉▉▉▉▉▉▉▉▉                                 |
|  8 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
|  7 | 10 | ▉▉▉▉▉▉▉▉▉▉                                |
|  6 | 14 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉                            |
|  5 | 18 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                        |
|  4 | 18 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                        |
|  3 | 22 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉                    |
|  2 | 27 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉               |
|  1 | 41 | ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ |
#+TBLFM: $3='(orgtbl-uc-draw-grid $2 0 41 41)
